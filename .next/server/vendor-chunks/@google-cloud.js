"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google-cloud";
exports.ids = ["vendor-chunks/@google-cloud"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/bigquery.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/bigquery.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BigQueryInt = exports.BigQueryTime = exports.BigQueryDatetime = exports.BigQueryTimestamp = exports.Geography = exports.BigQueryDate = exports.BigQueryRange = exports.BigQuery = exports.PROTOCOL_REGEX = exports.common = void 0;\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nconst common = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nexports.common = common;\nconst paginator_1 = __webpack_require__(/*! @google-cloud/paginator */ \"(rsc)/./node_modules/@google-cloud/paginator/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\");\nconst precise_date_1 = __webpack_require__(/*! @google-cloud/precise-date */ \"(rsc)/./node_modules/@google-cloud/precise-date/build/src/index.js\");\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst Big = __webpack_require__(/*! big.js */ \"(rsc)/./node_modules/big.js/big.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst is = __webpack_require__(/*! is */ \"(rsc)/./node_modules/is/index.js\");\nconst uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst dataset_1 = __webpack_require__(/*! ./dataset */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/dataset.js\");\nconst job_1 = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/job.js\");\nconst table_1 = __webpack_require__(/*! ./table */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/table.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/logger.js\");\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\n/**\n * @typedef {object} BigQueryOptions\n * @property {string} [projectId] The project ID from the Google Developer's\n *     Console, e.g. 'grape-spaceship-123'. We will also check the environment\n *     variable `GCLOUD_PROJECT` for your project ID. If your app is running in\n *     an environment which supports {@link\n * https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\n * Application Default Credentials}, your project ID will be detected\n * automatically.\n * @property {string} [keyFilename] Full path to the a .json, .pem, or .p12 key\n *     downloaded from the Google Developers Console. If you provide a path to a\n *     JSON file, the `projectId` option above is not necessary. NOTE: .pem and\n *     .p12 require you to specify the `email` option as well.\n * @property {string} [token] An OAUTH access token. If provided, we will not\n *     manage fetching, re-using, and re-minting access tokens.\n * @property {string} [email] Account email address. Required when using a .pem\n *     or .p12 keyFilename.\n * @property {object} [credentials] Credentials object.\n * @property {string} [credentials.client_email]\n * @property {string} [credentials.private_key]\n * @property {Constructor} [promise] Custom promise module to use instead of\n *     native Promises.\n * @property {string[]} [scopes] Additional OAuth scopes to use in requests. For\n *     example, to access an external data source, you may need the\n *     `https://www.googleapis.com/auth/drive.readonly` scope.\n */\n/**\n * In the following examples from this page and the other modules (`Dataset`,\n * `Table`, etc.), we are going to be using a dataset from\n * {@link http://goo.gl/f2SXcb| data.gov} of higher education institutions.\n *\n * We will create a table with the correct schema, import the public CSV file\n * into that table, and query it for data.\n *\n * This client supports enabling query-related preview features via environmental\n * variables.  By setting the environment variable QUERY_PREVIEW_ENABLED to the string\n * \"TRUE\", the client will enable preview features, though behavior may still be\n * controlled via the bigquery service as well.  Currently, the feature(s) in scope\n * include: stateless queries (query execution without corresponding job metadata).\n *\n * @class\n *\n * See {@link https://cloud.google.com/bigquery/what-is-bigquery| What is BigQuery?}\n *\n * @param {BigQueryOptions} options Constructor options.\n *\n * @example Install the client library with <a href=\"https://www.npmjs.com/\">npm</a>:\n * ```\n * npm install @google-cloud/bigquery\n *\n * ```\n * @example Import the client library\n * ```\n * const {BigQuery} = require('@google-cloud/bigquery');\n *\n * ```\n * @example Create a client that uses <a href=\"https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\">Application Default Credentials (ADC)</a>:\n * ```\n * const bigquery = new BigQuery();\n *\n * ```\n * @example Create a client with <a href=\"https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually\">explicit credentials</a>:\n * ```\n * const bigquery = new BigQuery({\n *   projectId: 'your-project-id',\n *   keyFilename: '/path/to/keyfile.json'\n * });\n *\n * ```\n * @example <caption>include:samples/quickstart.js</caption>\n * region_tag:bigquery_quickstart\n * Full quickstart example:\n */\nclass BigQuery extends common_1.Service {\n    createQueryStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    getDatasetsStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    getJobsStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    constructor(options = {}) {\n        let universeDomain = 'googleapis.com';\n        const servicePath = 'bigquery';\n        if (options.universeDomain) {\n            universeDomain = BigQuery.sanitizeDomain(options.universeDomain);\n        }\n        const EMULATOR_HOST = process.env.BIGQUERY_EMULATOR_HOST;\n        let apiEndpoint = `https://${servicePath}.${universeDomain}`;\n        if (typeof EMULATOR_HOST === 'string') {\n            apiEndpoint = BigQuery.sanitizeEndpoint(EMULATOR_HOST);\n        }\n        if (options.apiEndpoint) {\n            apiEndpoint = BigQuery.sanitizeEndpoint(options.apiEndpoint);\n        }\n        options = Object.assign({}, options, {\n            apiEndpoint,\n        });\n        const baseUrl = EMULATOR_HOST || `${options.apiEndpoint}/bigquery/v2`;\n        const config = {\n            apiEndpoint: options.apiEndpoint,\n            baseUrl,\n            scopes: ['https://www.googleapis.com/auth/bigquery'],\n            packageJson: __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@google-cloud/bigquery/package.json\"),\n            autoRetry: options.autoRetry,\n            maxRetries: options.maxRetries,\n            retryOptions: options.retryOptions,\n        };\n        if (options.scopes) {\n            config.scopes = config.scopes.concat(options.scopes);\n        }\n        super(config, options);\n        const QUERY_PREVIEW_ENABLED = process.env.QUERY_PREVIEW_ENABLED;\n        this._enableQueryPreview = false;\n        if (typeof QUERY_PREVIEW_ENABLED === 'string') {\n            if (QUERY_PREVIEW_ENABLED.toUpperCase() === 'TRUE') {\n                this._enableQueryPreview = true;\n            }\n        }\n        this._universeDomain = universeDomain;\n        this.location = options.location;\n        /**\n         * Run a query scoped to your project as a readable object stream.\n         *\n         * @method\n         * @param {object} query Configuration object. See {@link BigQuery.query} for a complete\n         *     list of options.\n         *\n         * @example\n         * ```\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         *\n         * const query = 'SELECT url FROM `publicdata.samples.github_nested` LIMIT\n         * 100';\n         *\n         * bigquery.createQueryStream(query)\n         *   .on('error', console.error)\n         *   .on('data', function(row) {\n         *     // row is a result from your query.\n         *   })\n         *   .on('end', function() {\n         *     // All rows retrieved.\n         *   });\n         *\n         * //-\n         * // If you anticipate many results, you can end a stream early to prevent\n         * // unnecessary processing and API requests.\n         * //-\n         * bigquery.createQueryStream(query)\n         *   .on('data', function(row) {\n         *     this.end();\n         *   });\n         * ```\n         */\n        this.createQueryStream = paginator_1.paginator.streamify('queryAsStream_');\n        /**\n         * List all or some of the {@link Dataset} objects in your project as\n         * a readable object stream.\n         *\n         * @param {object} [options] Configuration object. See\n         *     {@link BigQuery.getDatasets} for a complete list of options.\n         *\n         * @example\n         * ```\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         *\n         * bigquery.getDatasetsStream()\n         *   .on('error', console.error)\n         *   .on('data', function(dataset) {\n         *     // dataset is a Dataset object.\n         *   })\n         *   .on('end', function() {\n         *     // All datasets retrieved.\n         *   });\n         *\n         * //-\n         * // If you anticipate many results, you can end a stream early to prevent\n         * // unnecessary processing and API requests.\n         * //-\n         * bigquery.getDatasetsStream()\n         *   .on('data', function(dataset) {\n         *     this.end();\n         *   });\n         * ```\n         */\n        this.getDatasetsStream = paginator_1.paginator.streamify('getDatasets');\n        /**\n         * List all or some of the {@link Job} objects in your project as a\n         * readable object stream.\n         *\n         * @param {object} [options] Configuration object. See\n         *     {@link BigQuery.getJobs} for a complete list of options.\n         *\n         * @example\n         * ```\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         *\n         * bigquery.getJobsStream()\n         *   .on('error', console.error)\n         *   .on('data', function(job) {\n         *     // job is a Job object.\n         *   })\n         *   .on('end', function() {\n         *     // All jobs retrieved.\n         *   });\n         *\n         * //-\n         * // If you anticipate many results, you can end a stream early to prevent\n         * // unnecessary processing and API requests.\n         * //-\n         * bigquery.getJobsStream()\n         *   .on('data', function(job) {\n         *     this.end();\n         *   });\n         * ```\n         */\n        this.getJobsStream = paginator_1.paginator.streamify('getJobs');\n        // Disable `prettyPrint` for better performance.\n        // https://github.com/googleapis/nodejs-bigquery/issues/858\n        this.interceptors.push({\n            request: (reqOpts) => {\n                return extend(true, {}, reqOpts, { qs: { prettyPrint: false } });\n            },\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    trace_(msg, ...otherArgs) {\n        (0, logger_1.logger)('[bigquery]', msg, ...otherArgs);\n    }\n    get universeDomain() {\n        return this._universeDomain;\n    }\n    static sanitizeEndpoint(url) {\n        if (!exports.PROTOCOL_REGEX.test(url)) {\n            url = `https://${url}`;\n        }\n        return this.sanitizeDomain(url);\n    }\n    static sanitizeDomain(url) {\n        return url.replace(/\\/+$/, ''); // Remove trailing slashes\n    }\n    /**\n     * Merge a rowset returned from the API with a table schema.\n     *\n     * @private\n     *\n     * @param {object} schema\n     * @param {array} rows\n     * @param {object} options\n     * @param {boolean|IntegerTypeCastOptions} options.wrapIntegers Wrap values of\n     *     'INT64' type in {@link BigQueryInt} objects.\n     *     If a `boolean`, this will wrap values in {@link BigQueryInt} objects.\n     *     If an `object`, this will return a value returned by\n     *     `wrapIntegers.integerTypeCastFunction`.\n     *     Please see {@link IntegerTypeCastOptions} for options descriptions.\n     * @param {array} options.selectedFields List of fields to return.\n     * If unspecified, all fields are returned.\n     * @param {array} options.parseJSON parse a 'JSON' field into a JSON object.\n     * @returns Fields using their matching names from the table's schema.\n     */\n    static mergeSchemaWithRows_(schema, rows, options) {\n        // deep copy schema fields to avoid mutation\n        let schemaFields = extend(true, [], schema === null || schema === void 0 ? void 0 : schema.fields);\n        let selectedFields = extend(true, [], options.selectedFields);\n        if (options.selectedFields && options.selectedFields.length > 0) {\n            const selectedFieldsArray = options.selectedFields.map(c => {\n                return c.split('.');\n            });\n            const currentFields = selectedFieldsArray\n                .map(c => c.shift())\n                .filter(c => c !== undefined);\n            //filter schema fields based on selected fields.\n            schemaFields = schemaFields.filter(field => currentFields\n                .map(c => c.toLowerCase())\n                .indexOf(field.name.toLowerCase()) >= 0);\n            selectedFields = selectedFieldsArray\n                .filter(c => c.length > 0)\n                .map(c => c.join('.'));\n        }\n        return arrify(rows).map(mergeSchema).map(flattenRows);\n        function mergeSchema(row) {\n            return row.f.map((field, index) => {\n                const schemaField = schemaFields[index];\n                let value = field.v;\n                if (schemaField && schemaField.mode === 'REPEATED') {\n                    value = value.map(val => {\n                        return convertSchemaFieldValue(schemaField, val.v, {\n                            ...options,\n                            selectedFields,\n                        });\n                    });\n                }\n                else {\n                    value = convertSchemaFieldValue(schemaField, value, {\n                        ...options,\n                        selectedFields,\n                    });\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const fieldObject = {};\n                fieldObject[schemaField.name] = value;\n                return fieldObject;\n            });\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function flattenRows(rows) {\n            return rows.reduce((acc, row) => {\n                const key = Object.keys(row)[0];\n                acc[key] = row[key];\n                return acc;\n            }, {});\n        }\n    }\n    /**\n     * The `DATE` type represents a logical calendar date, independent of time\n     * zone. It does not represent a specific 24-hour time period. Rather, a given\n     * DATE value represents a different 24-hour period when interpreted in\n     * different time zones, and may represent a shorter or longer day during\n     * Daylight Savings Time transitions.\n     *\n     * @param {object|string} value The date. If a string, this should be in the\n     *     format the API describes: `YYYY-[M]M-[D]D`.\n     *     Otherwise, provide an object.\n     * @param {string|number} value.year Four digits.\n     * @param {string|number} value.month One or two digits.\n     * @param {string|number} value.day One or two digits.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const date = bigquery.date('2017-01-01');\n     *\n     * //-\n     * // Alternatively, provide an object.\n     * //-\n     * const date2 = bigquery.date({\n     *   year: 2017,\n     *   month: 1,\n     *   day: 1\n     * });\n     * ```\n     */\n    static date(value) {\n        return new BigQueryDate(value);\n    }\n    /**\n     * @param {object|string} value The date. If a string, this should be in the\n     *     format the API describes: `YYYY-[M]M-[D]D`.\n     *     Otherwise, provide an object.\n     * @param {string|number} value.year Four digits.\n     * @param {string|number} value.month One or two digits.\n     * @param {string|number} value.day One or two digits.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const date = BigQuery.date('2017-01-01');\n     *\n     * //-\n     * // Alternatively, provide an object.\n     * //-\n     * const date2 = BigQuery.date({\n     *   year: 2017,\n     *   month: 1,\n     *   day: 1\n     * });\n     * ```\n     */\n    date(value) {\n        return BigQuery.date(value);\n    }\n    /**\n     * A `DATETIME` data type represents a point in time. Unlike a `TIMESTAMP`,\n     * this does not refer to an absolute instance in time. Instead, it is the\n     * civil time, or the time that a user would see on a watch or calendar.\n     *\n     * @method BigQuery.datetime\n     * @param {object|string} value The time. If a string, this should be in the\n     *     format the API describes: `YYYY-[M]M-[D]D[ [H]H:[M]M:[S]S[.DDDDDD]]`.\n     *     Otherwise, provide an object.\n     * @param {string|number} value.year Four digits.\n     * @param {string|number} value.month One or two digits.\n     * @param {string|number} value.day One or two digits.\n     * @param {string|number} [value.hours] One or two digits (`00` - `23`).\n     * @param {string|number} [value.minutes] One or two digits (`00` - `59`).\n     * @param {string|number} [value.seconds] One or two digits (`00` - `59`).\n     * @param {string|number} [value.fractional] Up to six digits for microsecond\n     *     precision.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const datetime = BigQuery.datetime('2017-01-01 13:00:00');\n     *\n     * //-\n     * // Alternatively, provide an object.\n     * //-\n     * const datetime = BigQuery.datetime({\n     *   year: 2017,\n     *   month: 1,\n     *   day: 1,\n     *   hours: 14,\n     *   minutes: 0,\n     *   seconds: 0\n     * });\n     * ```\n     */\n    /**\n     * A `DATETIME` data type represents a point in time. Unlike a `TIMESTAMP`,\n     * this does not refer to an absolute instance in time. Instead, it is the\n     * civil time, or the time that a user would see on a watch or calendar.\n     *\n     * @param {object|string} value The time. If a string, this should be in the\n     *     format the API describes: `YYYY-[M]M-[D]D[ [H]H:[M]M:[S]S[.DDDDDD]]`.\n     *     Otherwise, provide an object.\n     * @param {string|number} value.year Four digits.\n     * @param {string|number} value.month One or two digits.\n     * @param {string|number} value.day One or two digits.\n     * @param {string|number} [value.hours] One or two digits (`00` - `23`).\n     * @param {string|number} [value.minutes] One or two digits (`00` - `59`).\n     * @param {string|number} [value.seconds] One or two digits (`00` - `59`).\n     * @param {string|number} [value.fractional] Up to six digits for microsecond\n     *     precision.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const datetime = bigquery.datetime('2017-01-01 13:00:00');\n     *\n     * //-\n     * // Alternatively, provide an object.\n     * //-\n     * const datetime = bigquery.datetime({\n     *   year: 2017,\n     *   month: 1,\n     *   day: 1,\n     *   hours: 14,\n     *   minutes: 0,\n     *   seconds: 0\n     * });\n     * ```\n     */\n    static datetime(value) {\n        return new BigQueryDatetime(value);\n    }\n    datetime(value) {\n        return BigQuery.datetime(value);\n    }\n    /**\n     * A `TIME` data type represents a time, independent of a specific date.\n     *\n     * @method BigQuery.time\n     * @param {object|string} value The time. If a string, this should be in the\n     *     format the API describes: `[H]H:[M]M:[S]S[.DDDDDD]`. Otherwise, provide\n     *     an object.\n     * @param {string|number} [value.hours] One or two digits (`00` - `23`).\n     * @param {string|number} [value.minutes] One or two digits (`00` - `59`).\n     * @param {string|number} [value.seconds] One or two digits (`00` - `59`).\n     * @param {string|number} [value.fractional] Up to six digits for microsecond\n     *     precision.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const time = BigQuery.time('14:00:00'); // 2:00 PM\n     *\n     * //-\n     * // Alternatively, provide an object.\n     * //-\n     * const time = BigQuery.time({\n     *   hours: 14,\n     *   minutes: 0,\n     *   seconds: 0\n     * });\n     * ```\n     */\n    /**\n     * A `TIME` data type represents a time, independent of a specific date.\n     *\n     * @param {object|string} value The time. If a string, this should be in the\n     *     format the API describes: `[H]H:[M]M:[S]S[.DDDDDD]`. Otherwise, provide\n     *     an object.\n     * @param {string|number} [value.hours] One or two digits (`00` - `23`).\n     * @param {string|number} [value.minutes] One or two digits (`00` - `59`).\n     * @param {string|number} [value.seconds] One or two digits (`00` - `59`).\n     * @param {string|number} [value.fractional] Up to six digits for microsecond\n     *     precision.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const time = bigquery.time('14:00:00'); // 2:00 PM\n     *\n     * //-\n     * // Alternatively, provide an object.\n     * //-\n     * const time = bigquery.time({\n     *   hours: 14,\n     *   minutes: 0,\n     *   seconds: 0\n     * });\n     * ```\n     */\n    static time(value) {\n        return new BigQueryTime(value);\n    }\n    time(value) {\n        return BigQuery.time(value);\n    }\n    /**\n     * A timestamp represents an absolute point in time, independent of any time\n     * zone or convention such as Daylight Savings Time.\n     *\n     * The recommended input here is a `Date` or `PreciseDate` class.\n     * If passing as a `string`, it should be Timestamp literals: https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#timestamp_literals.\n     * When passing a `number` input, it should be epoch seconds in float representation.\n     *\n     * @method BigQuery.timestamp\n     * @param {Date|string} value The time.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const timestamp = BigQuery.timestamp(new Date());\n     * ```\n     */\n    static timestamp(value) {\n        return new BigQueryTimestamp(value);\n    }\n    /**\n     * A timestamp represents an absolute point in time, independent of any time\n     * zone or convention such as Daylight Savings Time.\n     *\n     * The recommended input here is a `Date` or `PreciseDate` class.\n     * If passing as a `string`, it should be Timestamp literals: https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#timestamp_literals.\n     * When passing a `number` input, it should be epoch seconds in float representation.\n     *\n     * @param {Date|string|string|number} value The time.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const timestamp = bigquery.timestamp(new Date());\n     * ```\n     */\n    timestamp(value) {\n        return BigQuery.timestamp(value);\n    }\n    /**\n     * A range represents contiguous range between two dates, datetimes, or timestamps.\n     * The lower and upper bound for the range are optional.\n     * The lower bound is inclusive and the upper bound is exclusive.\n     *\n     * @method BigQuery.range\n     * @param {string|BigQueryRangeOptions} value The range API string or start/end with dates/datetimes/timestamp ranges.\n     * @param {string} elementType The range element type - DATE|DATETIME|TIMESTAMP\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const timestampRange = BigQuery.range('[2020-10-01 12:00:00+08, 2020-12-31 12:00:00+08)', 'TIMESTAMP');\n     * ```\n     */\n    static range(value, elementType) {\n        return new BigQueryRange(value, elementType);\n    }\n    /**\n     * A range represents contiguous range between two dates, datetimes, or timestamps.\n     * The lower and upper bound for the range are optional.\n     * The lower bound is inclusive and the upper bound is exclusive.\n     *\n     * @param {string|BigQueryRangeOptions} value The range API string or start/end with dates/datetimes/timestamp ranges.\n     * @param {string} elementType The range element type - DATE|DATETIME|TIMESTAMP\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const timestampRange = bigquery.range('[2020-10-01 12:00:00+08, 2020-12-31 12:00:00+08)', 'TIMESTAMP');\n     * ```\n     */\n    range(value, elementType) {\n        return BigQuery.range(value, elementType);\n    }\n    /**\n     * A BigQueryInt wraps 'INT64' values. Can be used to maintain precision.\n     *\n     * @param {string|number|IntegerTypeCastValue} value The INT64 value to convert.\n     * @param {IntegerTypeCastOptions} typeCastOptions Configuration to convert\n     *     value. Must provide an `integerTypeCastFunction` to handle conversion.\n     * @returns {BigQueryInt}\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     *\n     * const largeIntegerValue = Number.MAX_SAFE_INTEGER + 1;\n     *\n     * const options = {\n     *   integerTypeCastFunction: value => value.split(),\n     * };\n     *\n     * const bqInteger = bigquery.int(largeIntegerValue, options);\n     *\n     * const customValue = bqInteger.valueOf();\n     * // customValue is the value returned from your `integerTypeCastFunction`.\n     * ```\n     */\n    static int(value, typeCastOptions) {\n        return new BigQueryInt(value, typeCastOptions);\n    }\n    int(value, typeCastOptions) {\n        return BigQuery.int(value, typeCastOptions);\n    }\n    /**\n     * A geography value represents a surface area on the Earth\n     * in Well-known Text (WKT) format.\n     *\n     * @param {string} value The geospatial data.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const geography = bigquery.geography('POINT(1, 2)');\n     * ```\n     */\n    static geography(value) {\n        return new Geography(value);\n    }\n    geography(value) {\n        return BigQuery.geography(value);\n    }\n    /**\n     * Convert an INT64 value to Number.\n     *\n     * @private\n     * @param {object} value The INT64 value to convert.\n     */\n    static decodeIntegerValue_(value) {\n        const num = Number(value.integerValue);\n        if (!Number.isSafeInteger(num)) {\n            throw new Error('We attempted to return all of the numeric values, but ' +\n                (value.schemaFieldName ? value.schemaFieldName + ' ' : '') +\n                'value ' +\n                value.integerValue +\n                \" is out of bounds of 'Number.MAX_SAFE_INTEGER'.\\n\" +\n                \"To prevent this error, please consider passing 'options.wrapIntegers' as\\n\" +\n                '{\\n' +\n                '  integerTypeCastFunction: provide <your_custom_function>\\n' +\n                '  fields: optionally specify field name(s) to be custom casted\\n' +\n                '}\\n');\n        }\n        return num;\n    }\n    /**\n     * Return a value's provided type.\n     *\n     * @private\n     *\n     * @throws {error} If the type provided is invalid.\n     *\n     * See {@link https://cloud.google.com/bigquery/data-types| Data Type}\n     *\n     * @param {*} providedType The type.\n     * @returns {string} The valid type provided.\n     */\n    static getTypeDescriptorFromProvidedType_(providedType) {\n        // The list of types can be found in src/types.d.ts\n        const VALID_TYPES = [\n            'DATE',\n            'DATETIME',\n            'TIME',\n            'TIMESTAMP',\n            'BYTES',\n            'NUMERIC',\n            'DECIMAL',\n            'BIGNUMERIC',\n            'BIGDECIMAL',\n            'BOOL',\n            'INT64',\n            'INT',\n            'SMALLINT',\n            'INTEGER',\n            'BIGINT',\n            'TINYINT',\n            'BYTEINT',\n            'FLOAT64',\n            'FLOAT',\n            'STRING',\n            'GEOGRAPHY',\n            'ARRAY',\n            'STRUCT',\n            'JSON',\n            'RANGE',\n        ];\n        if (is.array(providedType)) {\n            providedType = providedType;\n            return {\n                type: 'ARRAY',\n                arrayType: BigQuery.getTypeDescriptorFromProvidedType_(providedType[0]),\n            };\n        }\n        else if (is.object(providedType)) {\n            return {\n                type: 'STRUCT',\n                structTypes: Object.keys(providedType).map(prop => {\n                    return {\n                        name: prop,\n                        type: BigQuery.getTypeDescriptorFromProvidedType_(providedType[prop]),\n                    };\n                }),\n            };\n        }\n        providedType = providedType.toUpperCase();\n        if (!VALID_TYPES.includes(providedType)) {\n            throw new Error(`Invalid type provided: \"${providedType}\"`);\n        }\n        return { type: providedType.toUpperCase() };\n    }\n    /**\n     * Detect a value's type.\n     *\n     * @private\n     *\n     * @throws {error} If the type could not be detected.\n     *\n     * See {@link https://cloud.google.com/bigquery/data-types| Data Type}\n     *\n     * @param {*} value The value.\n     * @returns {string} The type detected from the value.\n     */\n    static getTypeDescriptorFromValue_(value) {\n        let typeName;\n        if (value === null) {\n            throw new Error(\"Parameter types must be provided for null values via the 'types' field in query options.\");\n        }\n        if (value instanceof BigQueryDate) {\n            typeName = 'DATE';\n        }\n        else if (value instanceof BigQueryDatetime) {\n            typeName = 'DATETIME';\n        }\n        else if (value instanceof BigQueryTime) {\n            typeName = 'TIME';\n        }\n        else if (value instanceof BigQueryTimestamp) {\n            typeName = 'TIMESTAMP';\n        }\n        else if (value instanceof Buffer) {\n            typeName = 'BYTES';\n        }\n        else if (value instanceof Big) {\n            if (value.c.length - value.e >= 10) {\n                typeName = 'BIGNUMERIC';\n            }\n            else {\n                typeName = 'NUMERIC';\n            }\n        }\n        else if (value instanceof BigQueryInt) {\n            typeName = 'INT64';\n        }\n        else if (value instanceof Geography) {\n            typeName = 'GEOGRAPHY';\n        }\n        else if (value instanceof BigQueryRange) {\n            return {\n                type: 'RANGE',\n                rangeElementType: {\n                    type: value.elementType,\n                },\n            };\n        }\n        else if (Array.isArray(value)) {\n            if (value.length === 0) {\n                throw new Error(\"Parameter types must be provided for empty arrays via the 'types' field in query options.\");\n            }\n            return {\n                type: 'ARRAY',\n                arrayType: BigQuery.getTypeDescriptorFromValue_(value[0]),\n            };\n        }\n        else if (is.boolean(value)) {\n            typeName = 'BOOL';\n        }\n        else if (is.number(value)) {\n            typeName = value % 1 === 0 ? 'INT64' : 'FLOAT64';\n        }\n        else if (is.object(value)) {\n            return {\n                type: 'STRUCT',\n                structTypes: Object.keys(value).map(prop => {\n                    return {\n                        name: prop,\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        type: BigQuery.getTypeDescriptorFromValue_(value[prop]),\n                    };\n                }),\n            };\n        }\n        else if (is.string(value)) {\n            typeName = 'STRING';\n        }\n        if (!typeName) {\n            throw new Error([\n                'This value could not be translated to a BigQuery data type.',\n                value,\n            ].join('\\n'));\n        }\n        return {\n            type: typeName,\n        };\n    }\n    /**\n     * Convert a value into a `queryParameter` object.\n     *\n     * @private\n     *\n     * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query#request-body| Jobs.query API Reference Docs (see `queryParameters`)}\n     *\n     * @param {*} value The value.\n     * @param {string|ProvidedTypeStruct|ProvidedTypeArray} providedType Provided\n     *     query parameter type.\n     * @returns {object} A properly-formed `queryParameter` object.\n     */\n    static valueToQueryParameter_(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value, providedType) {\n        var _a, _b;\n        if (is.date(value)) {\n            value = BigQuery.timestamp(value);\n        }\n        let parameterType;\n        if (providedType) {\n            parameterType = BigQuery.getTypeDescriptorFromProvidedType_(providedType);\n        }\n        else {\n            parameterType = BigQuery.getTypeDescriptorFromValue_(value);\n        }\n        const queryParameter = { parameterType, parameterValue: {} };\n        const typeName = queryParameter.parameterType.type;\n        if (typeName === 'ARRAY') {\n            queryParameter.parameterValue.arrayValues = value.map(itemValue => {\n                const value = BigQuery._getValue(itemValue, parameterType.arrayType);\n                if (is.object(value) || is.array(value)) {\n                    if (is.array(providedType)) {\n                        providedType = providedType;\n                        return BigQuery.valueToQueryParameter_(value, providedType[0])\n                            .parameterValue;\n                    }\n                    else {\n                        return BigQuery.valueToQueryParameter_(value).parameterValue;\n                    }\n                }\n                return { value };\n            });\n        }\n        else if (typeName === 'STRUCT') {\n            queryParameter.parameterValue.structValues = Object.keys(value).reduce((structValues, prop) => {\n                let nestedQueryParameter;\n                if (providedType) {\n                    nestedQueryParameter = BigQuery.valueToQueryParameter_(value[prop], providedType[prop]);\n                }\n                else {\n                    nestedQueryParameter = BigQuery.valueToQueryParameter_(value[prop]);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                structValues[prop] = nestedQueryParameter.parameterValue;\n                return structValues;\n            }, {});\n        }\n        else if (typeName === 'RANGE') {\n            let rangeValue;\n            if (value instanceof BigQueryRange) {\n                rangeValue = value;\n            }\n            else {\n                rangeValue = BigQuery.range(value, (_b = (_a = queryParameter.parameterType) === null || _a === void 0 ? void 0 : _a.rangeElementType) === null || _b === void 0 ? void 0 : _b.type);\n            }\n            queryParameter.parameterValue.rangeValue = {\n                start: {\n                    value: rangeValue.value.start,\n                },\n                end: {\n                    value: rangeValue.value.end,\n                },\n            };\n        }\n        else if (typeName === 'JSON' && is.object(value)) {\n            queryParameter.parameterValue.value = JSON.stringify(value);\n        }\n        else {\n            queryParameter.parameterValue.value = BigQuery._getValue(value, parameterType);\n        }\n        return queryParameter;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static _getValue(value, type) {\n        if (value === null) {\n            return null;\n        }\n        if (value.type)\n            type = value;\n        return BigQuery._isCustomType(type) ? value.value : value;\n    }\n    static _isCustomType({ type }) {\n        return (type.indexOf('TIME') > -1 ||\n            type.indexOf('DATE') > -1 ||\n            type.indexOf('GEOGRAPHY') > -1 ||\n            type.indexOf('RANGE') > -1 ||\n            type.indexOf('BigQueryInt') > -1);\n    }\n    createDataset(id, optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        const reqOpts = {\n            method: 'POST',\n            uri: '/datasets',\n            json: extend(true, {\n                location: this.location,\n            }, options, {\n                datasetReference: {\n                    datasetId: id,\n                },\n            }),\n        };\n        if (options.projectId) {\n            reqOpts.projectId = options.projectId;\n        }\n        this.request(reqOpts, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            const dataset = this.dataset(id, options);\n            dataset.metadata = resp;\n            callback(null, dataset, resp);\n        });\n    }\n    createQueryJob(opts, callback) {\n        const options = typeof opts === 'object' ? opts : { query: opts };\n        this.trace_('[createQueryJob]', options, callback);\n        if ((!options || !options.query) && !options.pageToken) {\n            throw new Error('A SQL query string is required.');\n        }\n        const query = extend(true, {\n            useLegacySql: false,\n        }, options);\n        this.trace_('[createQueryJob]', query);\n        if (options.destination) {\n            if (!(options.destination instanceof table_1.Table)) {\n                throw new Error('Destination must be a Table object.');\n            }\n            query.destinationTable = {\n                datasetId: options.destination.dataset.id,\n                projectId: options.destination.dataset.projectId,\n                tableId: options.destination.id,\n            };\n            delete query.destination;\n        }\n        if (query.params) {\n            const { parameterMode, params } = this.buildQueryParams_(query.params, query.types);\n            query.parameterMode = parameterMode;\n            query.queryParameters = params;\n            delete query.params;\n        }\n        const reqOpts = {};\n        reqOpts.configuration = {\n            query,\n        };\n        if (typeof query.jobTimeoutMs === 'number') {\n            reqOpts.configuration.jobTimeoutMs = query.jobTimeoutMs.toString();\n            delete query.jobTimeoutMs;\n        }\n        if (query.dryRun) {\n            reqOpts.configuration.dryRun = query.dryRun;\n            delete query.dryRun;\n        }\n        if (query.labels) {\n            reqOpts.configuration.labels = query.labels;\n            delete query.labels;\n        }\n        if (query.jobPrefix) {\n            reqOpts.jobPrefix = query.jobPrefix;\n            delete query.jobPrefix;\n        }\n        if (query.location) {\n            reqOpts.location = query.location;\n            delete query.location;\n        }\n        if (query.jobId) {\n            reqOpts.jobId = query.jobId;\n            delete query.jobId;\n        }\n        this.createJob(reqOpts, callback);\n    }\n    buildQueryParams_(params, types) {\n        if (!params) {\n            return {\n                parameterMode: undefined,\n                params: undefined,\n            };\n        }\n        const parameterMode = is.array(params) ? 'positional' : 'named';\n        const queryParameters = [];\n        if (parameterMode === 'named') {\n            const namedParams = params;\n            for (const namedParameter of Object.getOwnPropertyNames(namedParams)) {\n                const value = namedParams[namedParameter];\n                let queryParameter;\n                if (types) {\n                    if (!is.object(types)) {\n                        throw new Error('Provided types must match the value type passed to `params`');\n                    }\n                    const namedTypes = types;\n                    if (namedTypes[namedParameter]) {\n                        queryParameter = BigQuery.valueToQueryParameter_(value, namedTypes[namedParameter]);\n                    }\n                    else {\n                        queryParameter = BigQuery.valueToQueryParameter_(value);\n                    }\n                }\n                else {\n                    queryParameter = BigQuery.valueToQueryParameter_(value);\n                }\n                queryParameter.name = namedParameter;\n                queryParameters.push(queryParameter);\n            }\n        }\n        else {\n            if (types) {\n                if (!is.array(types)) {\n                    throw new Error('Provided types must match the value type passed to `params`');\n                }\n                const positionalTypes = types;\n                if (params.length !== types.length) {\n                    throw new Error('Incorrect number of parameter types provided.');\n                }\n                params.forEach((value, i) => {\n                    const queryParameter = BigQuery.valueToQueryParameter_(value, positionalTypes[i]);\n                    queryParameters.push(queryParameter);\n                });\n            }\n            else {\n                params.forEach((value) => {\n                    const queryParameter = BigQuery.valueToQueryParameter_(value);\n                    queryParameters.push(queryParameter);\n                });\n            }\n        }\n        return {\n            parameterMode,\n            params: queryParameters,\n        };\n    }\n    createJob(options, callback) {\n        var _a;\n        const JOB_ID_PROVIDED = typeof options.jobId !== 'undefined';\n        const DRY_RUN = ((_a = options.configuration) === null || _a === void 0 ? void 0 : _a.dryRun)\n            ? options.configuration.dryRun\n            : false;\n        const reqOpts = Object.assign({}, options);\n        let jobId = JOB_ID_PROVIDED ? reqOpts.jobId : uuid.v4();\n        if (reqOpts.jobId) {\n            delete reqOpts.jobId;\n        }\n        if (reqOpts.jobPrefix) {\n            jobId = reqOpts.jobPrefix + jobId;\n            delete reqOpts.jobPrefix;\n        }\n        reqOpts.jobReference = {\n            projectId: this.projectId,\n            jobId,\n            location: this.location,\n        };\n        if (options.location) {\n            reqOpts.jobReference.location = options.location;\n            delete reqOpts.location;\n        }\n        const job = this.job(jobId, {\n            location: reqOpts.jobReference.location,\n        });\n        this.request({\n            method: 'POST',\n            uri: '/jobs',\n            json: reqOpts,\n        }, async (err, resp) => {\n            const ALREADY_EXISTS_CODE = 409;\n            if (err) {\n                if (err.code === ALREADY_EXISTS_CODE &&\n                    !JOB_ID_PROVIDED &&\n                    !DRY_RUN) {\n                    // The last insert attempt flaked, but the API still processed the\n                    // request and created the job. Because of our \"autoRetry\" feature,\n                    // we tried the request again, which tried to create it again,\n                    // unnecessarily. We will get the job's metadata and treat it as if\n                    // it just came back from the create call.\n                    err = null;\n                    [resp] = await job.getMetadata();\n                }\n                else {\n                    callback(err, null, resp);\n                    return;\n                }\n            }\n            if (resp.status.errors) {\n                err = new common_1.util.ApiError({\n                    errors: resp.status.errors,\n                    response: resp,\n                });\n            }\n            // Update the location with the one used by the API.\n            job.location = resp.jobReference.location;\n            job.metadata = resp;\n            callback(err, job, resp);\n        });\n    }\n    /**\n     * Create a reference to a dataset.\n     *\n     * @param {string} id ID of the dataset.\n     * @param {object} [options] Dataset options.\n     * @param {string} [options.projectId] The GCP project ID.\n     * @param {string} [options.location] The geographic location of the dataset.\n     *      Required except for US and EU.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const dataset = bigquery.dataset('higher_education');\n     * ```\n     */\n    dataset(id, options) {\n        if (typeof id !== 'string') {\n            throw new TypeError('A dataset ID is required.');\n        }\n        if (this.location) {\n            options = extend({ location: this.location }, options);\n        }\n        return new dataset_1.Dataset(this, id, options);\n    }\n    getDatasets(optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        const reqOpts = {\n            uri: '/datasets',\n            qs: options,\n        };\n        if (options.projectId) {\n            reqOpts.projectId = options.projectId;\n        }\n        this.request(reqOpts, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            let nextQuery = null;\n            if (resp.nextPageToken) {\n                nextQuery = Object.assign({}, options, {\n                    pageToken: resp.nextPageToken,\n                });\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const datasets = (resp.datasets || []).map((dataset) => {\n                const dsOpts = {\n                    location: dataset.location,\n                };\n                if (options.projectId) {\n                    dsOpts.projectId = options.projectId;\n                }\n                const ds = this.dataset(dataset.datasetReference.datasetId, dsOpts);\n                ds.metadata = dataset;\n                return ds;\n            });\n            callback(null, datasets, nextQuery, resp);\n        });\n    }\n    getJobs(optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        this.request({\n            uri: '/jobs',\n            qs: options,\n            useQuerystring: true,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            let nextQuery = null;\n            if (resp.nextPageToken) {\n                nextQuery = Object.assign({}, options, {\n                    pageToken: resp.nextPageToken,\n                });\n            }\n            const jobs = (resp.jobs || []).map((jobObject) => {\n                const job = this.job(jobObject.jobReference.jobId, {\n                    location: jobObject.jobReference.location,\n                });\n                job.metadata = jobObject;\n                return job;\n            });\n            callback(null, jobs, nextQuery, resp);\n        });\n    }\n    /**\n     * Create a reference to an existing job.\n     *\n     * @param {string} id ID of the job.\n     * @param {object} [options] Configuration object.\n     * @param {string} [options.location] The geographic location of the job.\n     *      Required except for US and EU.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     *\n     * const myExistingJob = bigquery.job('job-id');\n     * ```\n     */\n    job(id, options) {\n        if (this.location) {\n            options = extend({ location: this.location }, options);\n        }\n        return new job_1.Job(this, id, options);\n    }\n    query(query, optionsOrCallback, cb) {\n        let options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const queryOpts = typeof query === 'object'\n            ? {\n                wrapIntegers: query.wrapIntegers,\n                parseJSON: query.parseJSON,\n            }\n            : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        this.trace_('[query]', query, options);\n        const queryReq = this.buildQueryRequest_(query, options);\n        this.trace_('[query] queryReq', queryReq);\n        if (!queryReq) {\n            this.createQueryJob(query, (err, job, resp) => {\n                if (err) {\n                    callback(err, null, resp);\n                    return;\n                }\n                if (typeof query === 'object' && query.dryRun) {\n                    callback(null, [], resp);\n                    return;\n                }\n                // The Job is important for the `queryAsStream_` method, so a new query\n                // isn't created each time results are polled for.\n                options = extend({ job }, queryOpts, options);\n                job.getQueryResults(options, callback);\n            });\n            return;\n        }\n        this.runJobsQuery(queryReq, (err, job, res) => {\n            this.trace_('[runJobsQuery callback]: ', query, err, job, res);\n            if (err) {\n                callback(err, null, job);\n                return;\n            }\n            options = extend({ job }, queryOpts, options);\n            if (res && res.jobComplete) {\n                let rows = [];\n                if (res.schema && res.rows) {\n                    rows = BigQuery.mergeSchemaWithRows_(res.schema, res.rows, {\n                        wrapIntegers: options.wrapIntegers || false,\n                        parseJSON: options.parseJSON,\n                    });\n                    delete res.rows;\n                }\n                this.trace_('[runJobsQuery] job complete');\n                options._cachedRows = rows;\n                options._cachedResponse = res;\n                if (res.pageToken) {\n                    this.trace_('[runJobsQuery] has more pages');\n                    options.pageToken = res.pageToken;\n                }\n                else {\n                    this.trace_('[runJobsQuery] no more pages');\n                }\n                job.getQueryResults(options, callback);\n                return;\n            }\n            // If timeout override was provided, return error.\n            if (queryReq.timeoutMs) {\n                const err = new Error(`The query did not complete before ${queryReq.timeoutMs}ms`);\n                callback(err, null, job);\n                return;\n            }\n            delete options.timeoutMs;\n            this.trace_('[runJobsQuery] job not complete');\n            job.getQueryResults(options, callback);\n        });\n    }\n    /**\n     * Check if the given Query can run using the `jobs.query` endpoint.\n     * Returns a bigquery.IQueryRequest that can be used to call `jobs.query`.\n     * Return undefined if is not possible to convert to a bigquery.IQueryRequest.\n     *\n     * @param query string | Query\n     * @param options QueryOptions\n     * @returns bigquery.IQueryRequest | undefined\n     */\n    buildQueryRequest_(query, options) {\n        if (process.env.FAST_QUERY_PATH === 'DISABLED') {\n            return undefined;\n        }\n        const queryObj = typeof query === 'string'\n            ? {\n                query: query,\n            }\n            : query;\n        this.trace_('[buildQueryRequest]', query, options, queryObj);\n        // This is a denylist of settings which prevent us from composing an equivalent\n        // bq.QueryRequest due to differences between configuration parameters accepted\n        // by jobs.insert vs jobs.query.\n        if (!!queryObj.destination ||\n            !!queryObj.tableDefinitions ||\n            !!queryObj.createDisposition ||\n            !!queryObj.writeDisposition ||\n            (!!queryObj.priority && queryObj.priority !== 'INTERACTIVE') ||\n            queryObj.useLegacySql ||\n            !!queryObj.maximumBillingTier ||\n            !!queryObj.timePartitioning ||\n            !!queryObj.rangePartitioning ||\n            !!queryObj.clustering ||\n            !!queryObj.destinationEncryptionConfiguration ||\n            !!queryObj.schemaUpdateOptions ||\n            !!queryObj.jobTimeoutMs ||\n            // User has defined the jobID generation behavior\n            !!queryObj.jobId) {\n            return undefined;\n        }\n        if (queryObj.dryRun) {\n            return undefined;\n        }\n        if (options.job) {\n            return undefined;\n        }\n        const req = {\n            useQueryCache: queryObj.useQueryCache,\n            labels: queryObj.labels,\n            defaultDataset: queryObj.defaultDataset,\n            createSession: queryObj.createSession,\n            maximumBytesBilled: queryObj.maximumBytesBilled,\n            timeoutMs: options.timeoutMs,\n            location: queryObj.location || options.location,\n            formatOptions: {\n                useInt64Timestamp: true,\n            },\n            maxResults: queryObj.maxResults || options.maxResults,\n            query: queryObj.query,\n            useLegacySql: false,\n            requestId: uuid.v4(),\n            jobCreationMode: 'JOB_CREATION_OPTIONAL',\n        };\n        if (!this._enableQueryPreview) {\n            delete req.jobCreationMode;\n        }\n        const { parameterMode, params } = this.buildQueryParams_(queryObj.params, queryObj.types);\n        if (params) {\n            req.queryParameters = params;\n        }\n        if (parameterMode) {\n            req.parameterMode = parameterMode;\n        }\n        return req;\n    }\n    runJobsQuery(req, callback) {\n        this.trace_('[runJobsQuery]', req, callback);\n        this.request({\n            method: 'POST',\n            uri: '/queries',\n            json: req,\n        }, async (err, res) => {\n            this.trace_('jobs.query res:', res, err);\n            if (err) {\n                callback(err, null, res);\n                return;\n            }\n            let job = null;\n            if (res.jobReference) {\n                const jobRef = res.jobReference;\n                job = this.job(jobRef.jobId, {\n                    location: jobRef.location,\n                });\n            }\n            else if (res.queryId) {\n                job = this.job(res.queryId); // stateless query\n            }\n            callback(null, job, res);\n        });\n    }\n    /**\n     * This method will be called by `createQueryStream()`. It is required to\n     * properly set the `autoPaginate` option value.\n     *\n     * @private\n     */\n    queryAsStream_(query, callback) {\n        if (query.job) {\n            query.job.getQueryResults(query, callback);\n            return;\n        }\n        const { location, maxResults, pageToken, wrapIntegers, parseJSON } = query;\n        const opts = {\n            location,\n            maxResults,\n            pageToken,\n            wrapIntegers,\n            parseJSON,\n            autoPaginate: false,\n        };\n        delete query.location;\n        delete query.maxResults;\n        delete query.pageToken;\n        delete query.wrapIntegers;\n        delete query.parseJSON;\n        this.query(query, opts, callback);\n    }\n}\nexports.BigQuery = BigQuery;\nBigQuery.setLogFunction = logger_1.setLogFunction;\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\npaginator_1.paginator.extend(BigQuery, ['getDatasets', 'getJobs']);\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n(0, promisify_1.promisifyAll)(BigQuery, {\n    exclude: [\n        'dataset',\n        'date',\n        'datetime',\n        'geography',\n        'int',\n        'job',\n        'time',\n        'timestamp',\n        'range',\n    ],\n});\nfunction convertSchemaFieldValue(schemaField, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue, options) {\n    if (is.null(value)) {\n        return value;\n    }\n    switch (schemaField.type) {\n        case 'BOOLEAN':\n        case 'BOOL': {\n            value = value.toLowerCase() === 'true';\n            break;\n        }\n        case 'BYTES': {\n            value = Buffer.from(value, 'base64');\n            break;\n        }\n        case 'FLOAT':\n        case 'FLOAT64': {\n            value = Number(value);\n            break;\n        }\n        case 'INTEGER':\n        case 'INT64': {\n            const { wrapIntegers } = options;\n            value = wrapIntegers\n                ? typeof wrapIntegers === 'object'\n                    ? BigQuery.int({ integerValue: value, schemaFieldName: schemaField.name }, wrapIntegers).valueOf()\n                    : BigQuery.int(value)\n                : Number(value);\n            break;\n        }\n        case 'NUMERIC': {\n            value = new Big(value);\n            break;\n        }\n        case 'BIGNUMERIC': {\n            value = new Big(value);\n            break;\n        }\n        case 'RECORD': {\n            value = BigQuery.mergeSchemaWithRows_(schemaField, value, options).pop();\n            break;\n        }\n        case 'DATE': {\n            value = BigQuery.date(value);\n            break;\n        }\n        case 'DATETIME': {\n            value = BigQuery.datetime(value);\n            break;\n        }\n        case 'TIME': {\n            value = BigQuery.time(value);\n            break;\n        }\n        case 'TIMESTAMP': {\n            const pd = new precise_date_1.PreciseDate();\n            pd.setFullTime(precise_date_1.PreciseDate.parseFull(BigInt(value) * BigInt(1000)));\n            value = BigQuery.timestamp(pd);\n            break;\n        }\n        case 'GEOGRAPHY': {\n            value = BigQuery.geography(value);\n            break;\n        }\n        case 'JSON': {\n            const { parseJSON } = options;\n            value = parseJSON ? JSON.parse(value) : value;\n            break;\n        }\n        case 'RANGE': {\n            value = BigQueryRange.fromSchemaValue_(value, schemaField.rangeElementType.type);\n            break;\n        }\n        default:\n            break;\n    }\n    return value;\n}\n/**\n * Range class for BigQuery.\n * A range represents contiguous range between two dates, datetimes, or timestamps.\n * The lower and upper bound for the range are optional.\n * The lower bound is inclusive and the upper bound is exclusive.\n * See https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#range_literals\n */\nclass BigQueryRange {\n    constructor(value, elementType) {\n        if (typeof value === 'string') {\n            if (!elementType) {\n                throw new Error('invalid RANGE. Element type required when using RANGE API string.');\n            }\n            const [start, end] = BigQueryRange.fromStringValue_(value);\n            this.start = this.convertElement_(start, elementType);\n            this.end = this.convertElement_(end, elementType);\n            this.elementType = elementType;\n        }\n        else {\n            const { start, end } = value;\n            if (start && end) {\n                if (typeof start !== typeof end) {\n                    throw Error('upper and lower bound on a RANGE should be of the same type.');\n                }\n            }\n            const inferredType = {\n                BigQueryDate: 'DATE',\n                BigQueryDatetime: 'DATETIME',\n                BigQueryTimestamp: 'TIMESTAMP',\n            }[(start || end || Object).constructor.name] || elementType;\n            this.start = this.convertElement_(start, inferredType);\n            this.end = this.convertElement_(end, inferredType);\n            this.elementType = inferredType;\n        }\n    }\n    /*\n     * Get Range string representation used by the BigQuery API.\n     */\n    get apiValue() {\n        return `[${this.start ? this.start.value : 'UNBOUNDED'}, ${this.end ? this.end.value : 'UNBOUNDED'})`;\n    }\n    /*\n     * Get Range literal representation accordingly to\n     * https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#range_literals\n     */\n    get literalValue() {\n        return `RANGE<${this.elementType}> ${this.apiValue}`;\n    }\n    get value() {\n        return {\n            start: this.start ? this.start.value : 'UNBOUNDED',\n            end: this.end ? this.end.value : 'UNBOUNDED',\n        };\n    }\n    static fromStringValue_(value) {\n        let cleanedValue = value;\n        if (cleanedValue.startsWith('[') || cleanedValue.startsWith('(')) {\n            cleanedValue = cleanedValue.substring(1);\n        }\n        if (cleanedValue.endsWith(')') || cleanedValue.endsWith(']')) {\n            cleanedValue = cleanedValue.substring(0, cleanedValue.length - 1);\n        }\n        const parts = cleanedValue.split(',');\n        if (parts.length !== 2) {\n            throw new Error('invalid RANGE. See RANGE literal format docs for more information.');\n        }\n        const [start, end] = parts.map((s) => s.trim());\n        return [start, end];\n    }\n    static fromSchemaValue_(value, elementType) {\n        const [start, end] = BigQueryRange.fromStringValue_(value);\n        const convertRangeSchemaValue = (value) => {\n            if (value === 'UNBOUNDED' || value === 'NULL') {\n                return null;\n            }\n            return convertSchemaFieldValue({ type: elementType }, value, {\n                wrapIntegers: false,\n            });\n        };\n        return BigQuery.range({\n            start: convertRangeSchemaValue(start),\n            end: convertRangeSchemaValue(end),\n        }, elementType);\n    }\n    convertElement_(value, elementType) {\n        if (typeof value === 'string') {\n            if (value === 'UNBOUNDED' || value === 'NULL') {\n                return undefined;\n            }\n            switch (elementType) {\n                case 'DATE':\n                    return new BigQueryDate(value);\n                case 'DATETIME':\n                    return new BigQueryDatetime(value);\n                case 'TIMESTAMP':\n                    return new BigQueryTimestamp(value);\n            }\n            return undefined;\n        }\n        return value;\n    }\n}\nexports.BigQueryRange = BigQueryRange;\n/**\n * Date class for BigQuery.\n */\nclass BigQueryDate {\n    constructor(value) {\n        if (typeof value === 'object') {\n            value = BigQuery.datetime(value).value;\n        }\n        this.value = value;\n    }\n}\nexports.BigQueryDate = BigQueryDate;\n/**\n * Geography class for BigQuery.\n */\nclass Geography {\n    constructor(value) {\n        this.value = value;\n    }\n}\nexports.Geography = Geography;\n/**\n * Timestamp class for BigQuery.\n *\n * The recommended input here is a `Date` or `PreciseDate` class.\n * If passing as a `string`, it should be Timestamp literals: https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#timestamp_literals.\n * When passing a `number` input, it should be epoch seconds in float representation.\n *\n */\nclass BigQueryTimestamp {\n    constructor(value) {\n        let pd;\n        if (value instanceof precise_date_1.PreciseDate) {\n            pd = value;\n        }\n        else if (value instanceof Date) {\n            pd = new precise_date_1.PreciseDate(value);\n        }\n        else if (typeof value === 'string') {\n            if (/^\\d{4}-\\d{1,2}-\\d{1,2}/.test(value)) {\n                pd = new precise_date_1.PreciseDate(value);\n            }\n            else {\n                const floatValue = Number.parseFloat(value);\n                if (!Number.isNaN(floatValue)) {\n                    pd = this.fromFloatValue_(floatValue);\n                }\n                else {\n                    pd = new precise_date_1.PreciseDate(value);\n                }\n            }\n        }\n        else {\n            pd = this.fromFloatValue_(value);\n        }\n        // to keep backward compatibility, only converts with microsecond\n        // precision if needed.\n        if (pd.getMicroseconds() > 0) {\n            this.value = pd.toISOString();\n        }\n        else {\n            this.value = new Date(pd.getTime()).toJSON();\n        }\n    }\n    fromFloatValue_(value) {\n        const secs = Math.trunc(value);\n        // Timestamps in BigQuery have microsecond precision, so we must\n        // return a round number of microseconds.\n        const micros = Math.trunc((value - secs) * 1e6 + 0.5);\n        const pd = new precise_date_1.PreciseDate([secs, micros * 1000]);\n        return pd;\n    }\n}\nexports.BigQueryTimestamp = BigQueryTimestamp;\n/**\n * Datetime class for BigQuery.\n */\nclass BigQueryDatetime {\n    constructor(value) {\n        if (typeof value === 'object') {\n            let time;\n            if (value.hours) {\n                time = BigQuery.time(value).value;\n            }\n            const y = value.year;\n            const m = value.month;\n            const d = value.day;\n            time = time ? ' ' + time : '';\n            value = `${y}-${m}-${d}${time}`;\n        }\n        else {\n            value = value.replace(/^(.*)T(.*)Z$/, '$1 $2');\n        }\n        this.value = value;\n    }\n}\nexports.BigQueryDatetime = BigQueryDatetime;\n/**\n * Time class for BigQuery.\n */\nclass BigQueryTime {\n    constructor(value) {\n        if (typeof value === 'object') {\n            const h = value.hours;\n            const m = value.minutes || 0;\n            const s = value.seconds || 0;\n            const f = is.defined(value.fractional) ? '.' + value.fractional : '';\n            value = `${h}:${m}:${s}${f}`;\n        }\n        this.value = value;\n    }\n}\nexports.BigQueryTime = BigQueryTime;\n/**\n * Build a BigQueryInt object. For long integers, a string can be provided.\n *\n * @class\n * @param {string|number|IntegerTypeCastValue} value The 'INT64' value.\n * @param {object} [typeCastOptions] Configuration to convert\n *     values of 'INT64' type to a custom value. Must provide an\n *     `integerTypeCastFunction` to handle conversion.\n * @param {function} typeCastOptions.integerTypeCastFunction A custom user\n *     provided function to convert value.\n * @param {string|string[]} [typeCastOptions.fields] Schema field\n *     names to be converted using `integerTypeCastFunction`.\n *\n * @example\n * ```\n * const {BigQuery} = require('@google-cloud/bigquery');\n * const bigquery = new BigQuery();\n * const anInt = bigquery.int(7);\n * ```\n */\nclass BigQueryInt extends Number {\n    constructor(value, typeCastOptions) {\n        super(typeof value === 'object' ? value.integerValue : value);\n        this._schemaFieldName =\n            typeof value === 'object' ? value.schemaFieldName : undefined;\n        this.value =\n            typeof value === 'object'\n                ? value.integerValue.toString()\n                : value.toString();\n        this.type = 'BigQueryInt';\n        if (typeCastOptions) {\n            if (typeof typeCastOptions.integerTypeCastFunction !== 'function') {\n                throw new Error('integerTypeCastFunction is not a function or was not provided.');\n            }\n            const typeCastFields = typeCastOptions.fields\n                ? arrify(typeCastOptions.fields)\n                : undefined;\n            let customCast = true;\n            if (typeCastFields) {\n                customCast = this._schemaFieldName\n                    ? typeCastFields.includes(this._schemaFieldName)\n                        ? true\n                        : false\n                    : false;\n            }\n            customCast &&\n                (this.typeCastFunction = typeCastOptions.integerTypeCastFunction);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    valueOf() {\n        const shouldCustomCast = this.typeCastFunction ? true : false;\n        if (shouldCustomCast) {\n            try {\n                return this.typeCastFunction(this.value);\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    error.message = `integerTypeCastFunction threw an error:\\n\\n  - ${error.message}`;\n                }\n                throw error;\n            }\n        }\n        else {\n            return BigQuery.decodeIntegerValue_({\n                integerValue: this.value,\n                schemaFieldName: this._schemaFieldName,\n            });\n        }\n    }\n    toJSON() {\n        return { type: this.type, value: this.value };\n    }\n}\nexports.BigQueryInt = BigQueryInt;\n//# sourceMappingURL=bigquery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvYmlncXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsd0JBQXdCLEdBQUcseUJBQXlCLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsc0JBQXNCLEdBQUcsY0FBYztBQUNqTyxpQkFBaUIsbUJBQU8sQ0FBQywwRkFBc0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDBGQUFzQjtBQUM3QyxjQUFjO0FBQ2Qsb0JBQW9CLG1CQUFPLENBQUMsZ0dBQXlCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyxzR0FBNEI7QUFDM0QsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxrREFBUTtBQUM1QixlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLDRDQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyw4REFBTTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBVztBQUNyQyxjQUFjLG1CQUFPLENBQUMsMkVBQU87QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVU7QUFDbkMsc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWSxHQUFHLGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsU0FBUztBQUNULDRDQUE0QyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsaUNBQWlDLHNCQUFzQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLE1BQU0sc0JBQXNCO0FBQy9FLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdDQUFnQztBQUMvQyw0QkFBNEIsbUJBQW1CO0FBQy9DLHFEQUFxRCxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlC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LEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQztBQUMvQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixjQUFjO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvYmlncXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpZ1F1ZXJ5SW50ID0gZXhwb3J0cy5CaWdRdWVyeVRpbWUgPSBleHBvcnRzLkJpZ1F1ZXJ5RGF0ZXRpbWUgPSBleHBvcnRzLkJpZ1F1ZXJ5VGltZXN0YW1wID0gZXhwb3J0cy5HZW9ncmFwaHkgPSBleHBvcnRzLkJpZ1F1ZXJ5RGF0ZSA9IGV4cG9ydHMuQmlnUXVlcnlSYW5nZSA9IGV4cG9ydHMuQmlnUXVlcnkgPSBleHBvcnRzLlBST1RPQ09MX1JFR0VYID0gZXhwb3J0cy5jb21tb24gPSB2b2lkIDA7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCJAZ29vZ2xlLWNsb3VkL2NvbW1vblwiKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoXCJAZ29vZ2xlLWNsb3VkL2NvbW1vblwiKTtcbmV4cG9ydHMuY29tbW9uID0gY29tbW9uO1xuY29uc3QgcGFnaW5hdG9yXzEgPSByZXF1aXJlKFwiQGdvb2dsZS1jbG91ZC9wYWdpbmF0b3JcIik7XG5jb25zdCBwcm9taXNpZnlfMSA9IHJlcXVpcmUoXCJAZ29vZ2xlLWNsb3VkL3Byb21pc2lmeVwiKTtcbmNvbnN0IHByZWNpc2VfZGF0ZV8xID0gcmVxdWlyZShcIkBnb29nbGUtY2xvdWQvcHJlY2lzZS1kYXRlXCIpO1xuY29uc3QgYXJyaWZ5ID0gcmVxdWlyZShcImFycmlmeVwiKTtcbmNvbnN0IEJpZyA9IHJlcXVpcmUoXCJiaWcuanNcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuY29uc3QgaXMgPSByZXF1aXJlKFwiaXNcIik7XG5jb25zdCB1dWlkID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBkYXRhc2V0XzEgPSByZXF1aXJlKFwiLi9kYXRhc2V0XCIpO1xuY29uc3Qgam9iXzEgPSByZXF1aXJlKFwiLi9qb2JcIik7XG5jb25zdCB0YWJsZV8xID0gcmVxdWlyZShcIi4vdGFibGVcIik7XG5jb25zdCBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbmV4cG9ydHMuUFJPVE9DT0xfUkVHRVggPSAvXihcXHcqKTpcXC9cXC8vO1xuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBCaWdRdWVyeU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvamVjdElkXSBUaGUgcHJvamVjdCBJRCBmcm9tIHRoZSBHb29nbGUgRGV2ZWxvcGVyJ3NcbiAqICAgICBDb25zb2xlLCBlLmcuICdncmFwZS1zcGFjZXNoaXAtMTIzJy4gV2Ugd2lsbCBhbHNvIGNoZWNrIHRoZSBlbnZpcm9ubWVudFxuICogICAgIHZhcmlhYmxlIGBHQ0xPVURfUFJPSkVDVGAgZm9yIHlvdXIgcHJvamVjdCBJRC4gSWYgeW91ciBhcHAgaXMgcnVubmluZyBpblxuICogICAgIGFuIGVudmlyb25tZW50IHdoaWNoIHN1cHBvcnRzIHtAbGlua1xuICogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vcHJvZHVjdGlvbiNwcm92aWRpbmdfY3JlZGVudGlhbHNfdG9feW91cl9hcHBsaWNhdGlvblxuICogQXBwbGljYXRpb24gRGVmYXVsdCBDcmVkZW50aWFsc30sIHlvdXIgcHJvamVjdCBJRCB3aWxsIGJlIGRldGVjdGVkXG4gKiBhdXRvbWF0aWNhbGx5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXlGaWxlbmFtZV0gRnVsbCBwYXRoIHRvIHRoZSBhIC5qc29uLCAucGVtLCBvciAucDEyIGtleVxuICogICAgIGRvd25sb2FkZWQgZnJvbSB0aGUgR29vZ2xlIERldmVsb3BlcnMgQ29uc29sZS4gSWYgeW91IHByb3ZpZGUgYSBwYXRoIHRvIGFcbiAqICAgICBKU09OIGZpbGUsIHRoZSBgcHJvamVjdElkYCBvcHRpb24gYWJvdmUgaXMgbm90IG5lY2Vzc2FyeS4gTk9URTogLnBlbSBhbmRcbiAqICAgICAucDEyIHJlcXVpcmUgeW91IHRvIHNwZWNpZnkgdGhlIGBlbWFpbGAgb3B0aW9uIGFzIHdlbGwuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Rva2VuXSBBbiBPQVVUSCBhY2Nlc3MgdG9rZW4uIElmIHByb3ZpZGVkLCB3ZSB3aWxsIG5vdFxuICogICAgIG1hbmFnZSBmZXRjaGluZywgcmUtdXNpbmcsIGFuZCByZS1taW50aW5nIGFjY2VzcyB0b2tlbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2VtYWlsXSBBY2NvdW50IGVtYWlsIGFkZHJlc3MuIFJlcXVpcmVkIHdoZW4gdXNpbmcgYSAucGVtXG4gKiAgICAgb3IgLnAxMiBrZXlGaWxlbmFtZS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY3JlZGVudGlhbHNdIENyZWRlbnRpYWxzIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3JlZGVudGlhbHMuY2xpZW50X2VtYWlsXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjcmVkZW50aWFscy5wcml2YXRlX2tleV1cbiAqIEBwcm9wZXJ0eSB7Q29uc3RydWN0b3J9IFtwcm9taXNlXSBDdXN0b20gcHJvbWlzZSBtb2R1bGUgdG8gdXNlIGluc3RlYWQgb2ZcbiAqICAgICBuYXRpdmUgUHJvbWlzZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbc2NvcGVzXSBBZGRpdGlvbmFsIE9BdXRoIHNjb3BlcyB0byB1c2UgaW4gcmVxdWVzdHMuIEZvclxuICogICAgIGV4YW1wbGUsIHRvIGFjY2VzcyBhbiBleHRlcm5hbCBkYXRhIHNvdXJjZSwgeW91IG1heSBuZWVkIHRoZVxuICogICAgIGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLnJlYWRvbmx5YCBzY29wZS5cbiAqL1xuLyoqXG4gKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIGZyb20gdGhpcyBwYWdlIGFuZCB0aGUgb3RoZXIgbW9kdWxlcyAoYERhdGFzZXRgLFxuICogYFRhYmxlYCwgZXRjLiksIHdlIGFyZSBnb2luZyB0byBiZSB1c2luZyBhIGRhdGFzZXQgZnJvbVxuICoge0BsaW5rIGh0dHA6Ly9nb28uZ2wvZjJTWGNifCBkYXRhLmdvdn0gb2YgaGlnaGVyIGVkdWNhdGlvbiBpbnN0aXR1dGlvbnMuXG4gKlxuICogV2Ugd2lsbCBjcmVhdGUgYSB0YWJsZSB3aXRoIHRoZSBjb3JyZWN0IHNjaGVtYSwgaW1wb3J0IHRoZSBwdWJsaWMgQ1NWIGZpbGVcbiAqIGludG8gdGhhdCB0YWJsZSwgYW5kIHF1ZXJ5IGl0IGZvciBkYXRhLlxuICpcbiAqIFRoaXMgY2xpZW50IHN1cHBvcnRzIGVuYWJsaW5nIHF1ZXJ5LXJlbGF0ZWQgcHJldmlldyBmZWF0dXJlcyB2aWEgZW52aXJvbm1lbnRhbFxuICogdmFyaWFibGVzLiAgQnkgc2V0dGluZyB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgUVVFUllfUFJFVklFV19FTkFCTEVEIHRvIHRoZSBzdHJpbmdcbiAqIFwiVFJVRVwiLCB0aGUgY2xpZW50IHdpbGwgZW5hYmxlIHByZXZpZXcgZmVhdHVyZXMsIHRob3VnaCBiZWhhdmlvciBtYXkgc3RpbGwgYmVcbiAqIGNvbnRyb2xsZWQgdmlhIHRoZSBiaWdxdWVyeSBzZXJ2aWNlIGFzIHdlbGwuICBDdXJyZW50bHksIHRoZSBmZWF0dXJlKHMpIGluIHNjb3BlXG4gKiBpbmNsdWRlOiBzdGF0ZWxlc3MgcXVlcmllcyAocXVlcnkgZXhlY3V0aW9uIHdpdGhvdXQgY29ycmVzcG9uZGluZyBqb2IgbWV0YWRhdGEpLlxuICpcbiAqIEBjbGFzc1xuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L3doYXQtaXMtYmlncXVlcnl8IFdoYXQgaXMgQmlnUXVlcnk/fVxuICpcbiAqIEBwYXJhbSB7QmlnUXVlcnlPcHRpb25zfSBvcHRpb25zIENvbnN0cnVjdG9yIG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGUgSW5zdGFsbCB0aGUgY2xpZW50IGxpYnJhcnkgd2l0aCA8YSBocmVmPVwiaHR0cHM6Ly93d3cubnBtanMuY29tL1wiPm5wbTwvYT46XG4gKiBgYGBcbiAqIG5wbSBpbnN0YWxsIEBnb29nbGUtY2xvdWQvYmlncXVlcnlcbiAqXG4gKiBgYGBcbiAqIEBleGFtcGxlIEltcG9ydCB0aGUgY2xpZW50IGxpYnJhcnlcbiAqIGBgYFxuICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAqXG4gKiBgYGBcbiAqIEBleGFtcGxlIENyZWF0ZSBhIGNsaWVudCB0aGF0IHVzZXMgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kb2NzL2F1dGhlbnRpY2F0aW9uL3Byb2R1Y3Rpb24jcHJvdmlkaW5nX2NyZWRlbnRpYWxzX3RvX3lvdXJfYXBwbGljYXRpb25cIj5BcHBsaWNhdGlvbiBEZWZhdWx0IENyZWRlbnRpYWxzIChBREMpPC9hPjpcbiAqIGBgYFxuICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAqXG4gKiBgYGBcbiAqIEBleGFtcGxlIENyZWF0ZSBhIGNsaWVudCB3aXRoIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9wcm9kdWN0aW9uI29idGFpbmluZ19hbmRfcHJvdmlkaW5nX3NlcnZpY2VfYWNjb3VudF9jcmVkZW50aWFsc19tYW51YWxseVwiPmV4cGxpY2l0IGNyZWRlbnRpYWxzPC9hPjpcbiAqIGBgYFxuICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoe1xuICogICBwcm9qZWN0SWQ6ICd5b3VyLXByb2plY3QtaWQnLFxuICogICBrZXlGaWxlbmFtZTogJy9wYXRoL3RvL2tleWZpbGUuanNvbidcbiAqIH0pO1xuICpcbiAqIGBgYFxuICogQGV4YW1wbGUgPGNhcHRpb24+aW5jbHVkZTpzYW1wbGVzL3F1aWNrc3RhcnQuanM8L2NhcHRpb24+XG4gKiByZWdpb25fdGFnOmJpZ3F1ZXJ5X3F1aWNrc3RhcnRcbiAqIEZ1bGwgcXVpY2tzdGFydCBleGFtcGxlOlxuICovXG5jbGFzcyBCaWdRdWVyeSBleHRlbmRzIGNvbW1vbl8xLlNlcnZpY2Uge1xuICAgIGNyZWF0ZVF1ZXJ5U3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gcGxhY2Vob2xkZXIgYm9keSwgb3ZlcndyaXR0ZW4gaW4gY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBwYWdpbmF0b3JfMS5SZXNvdXJjZVN0cmVhbSh7fSwgKCkgPT4geyB9KTtcbiAgICB9XG4gICAgZ2V0RGF0YXNldHNTdHJlYW0ob3B0aW9ucykge1xuICAgICAgICAvLyBwbGFjZWhvbGRlciBib2R5LCBvdmVyd3JpdHRlbiBpbiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IHBhZ2luYXRvcl8xLlJlc291cmNlU3RyZWFtKHt9LCAoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBnZXRKb2JzU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gcGxhY2Vob2xkZXIgYm9keSwgb3ZlcndyaXR0ZW4gaW4gY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBwYWdpbmF0b3JfMS5SZXNvdXJjZVN0cmVhbSh7fSwgKCkgPT4geyB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB1bml2ZXJzZURvbWFpbiA9ICdnb29nbGVhcGlzLmNvbSc7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VQYXRoID0gJ2JpZ3F1ZXJ5JztcbiAgICAgICAgaWYgKG9wdGlvbnMudW5pdmVyc2VEb21haW4pIHtcbiAgICAgICAgICAgIHVuaXZlcnNlRG9tYWluID0gQmlnUXVlcnkuc2FuaXRpemVEb21haW4ob3B0aW9ucy51bml2ZXJzZURvbWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgRU1VTEFUT1JfSE9TVCA9IHByb2Nlc3MuZW52LkJJR1FVRVJZX0VNVUxBVE9SX0hPU1Q7XG4gICAgICAgIGxldCBhcGlFbmRwb2ludCA9IGBodHRwczovLyR7c2VydmljZVBhdGh9LiR7dW5pdmVyc2VEb21haW59YDtcbiAgICAgICAgaWYgKHR5cGVvZiBFTVVMQVRPUl9IT1NUID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXBpRW5kcG9pbnQgPSBCaWdRdWVyeS5zYW5pdGl6ZUVuZHBvaW50KEVNVUxBVE9SX0hPU1QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFwaUVuZHBvaW50KSB7XG4gICAgICAgICAgICBhcGlFbmRwb2ludCA9IEJpZ1F1ZXJ5LnNhbml0aXplRW5kcG9pbnQob3B0aW9ucy5hcGlFbmRwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFwaUVuZHBvaW50LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IEVNVUxBVE9SX0hPU1QgfHwgYCR7b3B0aW9ucy5hcGlFbmRwb2ludH0vYmlncXVlcnkvdjJgO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICBhcGlFbmRwb2ludDogb3B0aW9ucy5hcGlFbmRwb2ludCxcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICBzY29wZXM6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9iaWdxdWVyeSddLFxuICAgICAgICAgICAgcGFja2FnZUpzb246IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLFxuICAgICAgICAgICAgYXV0b1JldHJ5OiBvcHRpb25zLmF1dG9SZXRyeSxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJldHJ5T3B0aW9uczogb3B0aW9ucy5yZXRyeU9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgY29uZmlnLnNjb3BlcyA9IGNvbmZpZy5zY29wZXMuY29uY2F0KG9wdGlvbnMuc2NvcGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihjb25maWcsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBRVUVSWV9QUkVWSUVXX0VOQUJMRUQgPSBwcm9jZXNzLmVudi5RVUVSWV9QUkVWSUVXX0VOQUJMRUQ7XG4gICAgICAgIHRoaXMuX2VuYWJsZVF1ZXJ5UHJldmlldyA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIFFVRVJZX1BSRVZJRVdfRU5BQkxFRCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChRVUVSWV9QUkVWSUVXX0VOQUJMRUQudG9VcHBlckNhc2UoKSA9PT0gJ1RSVUUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlUXVlcnlQcmV2aWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91bml2ZXJzZURvbWFpbiA9IHVuaXZlcnNlRG9tYWluO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1biBhIHF1ZXJ5IHNjb3BlZCB0byB5b3VyIHByb2plY3QgYXMgYSByZWFkYWJsZSBvYmplY3Qgc3RyZWFtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeSBDb25maWd1cmF0aW9uIG9iamVjdC4gU2VlIHtAbGluayBCaWdRdWVyeS5xdWVyeX0gZm9yIGEgY29tcGxldGVcbiAgICAgICAgICogICAgIGxpc3Qgb2Ygb3B0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHF1ZXJ5ID0gJ1NFTEVDVCB1cmwgRlJPTSBgcHVibGljZGF0YS5zYW1wbGVzLmdpdGh1Yl9uZXN0ZWRgIExJTUlUXG4gICAgICAgICAqIDEwMCc7XG4gICAgICAgICAqXG4gICAgICAgICAqIGJpZ3F1ZXJ5LmNyZWF0ZVF1ZXJ5U3RyZWFtKHF1ZXJ5KVxuICAgICAgICAgKiAgIC5vbignZXJyb3InLCBjb25zb2xlLmVycm9yKVxuICAgICAgICAgKiAgIC5vbignZGF0YScsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgKiAgICAgLy8gcm93IGlzIGEgcmVzdWx0IGZyb20geW91ciBxdWVyeS5cbiAgICAgICAgICogICB9KVxuICAgICAgICAgKiAgIC5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgICAvLyBBbGwgcm93cyByZXRyaWV2ZWQuXG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vLVxuICAgICAgICAgKiAvLyBJZiB5b3UgYW50aWNpcGF0ZSBtYW55IHJlc3VsdHMsIHlvdSBjYW4gZW5kIGEgc3RyZWFtIGVhcmx5IHRvIHByZXZlbnRcbiAgICAgICAgICogLy8gdW5uZWNlc3NhcnkgcHJvY2Vzc2luZyBhbmQgQVBJIHJlcXVlc3RzLlxuICAgICAgICAgKiAvLy1cbiAgICAgICAgICogYmlncXVlcnkuY3JlYXRlUXVlcnlTdHJlYW0ocXVlcnkpXG4gICAgICAgICAqICAgLm9uKCdkYXRhJywgZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAqICAgICB0aGlzLmVuZCgpO1xuICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUXVlcnlTdHJlYW0gPSBwYWdpbmF0b3JfMS5wYWdpbmF0b3Iuc3RyZWFtaWZ5KCdxdWVyeUFzU3RyZWFtXycpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgb3Igc29tZSBvZiB0aGUge0BsaW5rIERhdGFzZXR9IG9iamVjdHMgaW4geW91ciBwcm9qZWN0IGFzXG4gICAgICAgICAqIGEgcmVhZGFibGUgb2JqZWN0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9iamVjdC4gU2VlXG4gICAgICAgICAqICAgICB7QGxpbmsgQmlnUXVlcnkuZ2V0RGF0YXNldHN9IGZvciBhIGNvbXBsZXRlIGxpc3Qgb2Ygb3B0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGJpZ3F1ZXJ5LmdldERhdGFzZXRzU3RyZWFtKClcbiAgICAgICAgICogICAub24oJ2Vycm9yJywgY29uc29sZS5lcnJvcilcbiAgICAgICAgICogICAub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhc2V0KSB7XG4gICAgICAgICAqICAgICAvLyBkYXRhc2V0IGlzIGEgRGF0YXNldCBvYmplY3QuXG4gICAgICAgICAqICAgfSlcbiAgICAgICAgICogICAub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgKiAgICAgLy8gQWxsIGRhdGFzZXRzIHJldHJpZXZlZC5cbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8tXG4gICAgICAgICAqIC8vIElmIHlvdSBhbnRpY2lwYXRlIG1hbnkgcmVzdWx0cywgeW91IGNhbiBlbmQgYSBzdHJlYW0gZWFybHkgdG8gcHJldmVudFxuICAgICAgICAgKiAvLyB1bm5lY2Vzc2FyeSBwcm9jZXNzaW5nIGFuZCBBUEkgcmVxdWVzdHMuXG4gICAgICAgICAqIC8vLVxuICAgICAgICAgKiBiaWdxdWVyeS5nZXREYXRhc2V0c1N0cmVhbSgpXG4gICAgICAgICAqICAgLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YXNldCkge1xuICAgICAgICAgKiAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERhdGFzZXRzU3RyZWFtID0gcGFnaW5hdG9yXzEucGFnaW5hdG9yLnN0cmVhbWlmeSgnZ2V0RGF0YXNldHMnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIG9yIHNvbWUgb2YgdGhlIHtAbGluayBKb2J9IG9iamVjdHMgaW4geW91ciBwcm9qZWN0IGFzIGFcbiAgICAgICAgICogcmVhZGFibGUgb2JqZWN0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9iamVjdC4gU2VlXG4gICAgICAgICAqICAgICB7QGxpbmsgQmlnUXVlcnkuZ2V0Sm9ic30gZm9yIGEgY29tcGxldGUgbGlzdCBvZiBvcHRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogYmlncXVlcnkuZ2V0Sm9ic1N0cmVhbSgpXG4gICAgICAgICAqICAgLm9uKCdlcnJvcicsIGNvbnNvbGUuZXJyb3IpXG4gICAgICAgICAqICAgLm9uKCdkYXRhJywgZnVuY3Rpb24oam9iKSB7XG4gICAgICAgICAqICAgICAvLyBqb2IgaXMgYSBKb2Igb2JqZWN0LlxuICAgICAgICAgKiAgIH0pXG4gICAgICAgICAqICAgLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgIC8vIEFsbCBqb2JzIHJldHJpZXZlZC5cbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8tXG4gICAgICAgICAqIC8vIElmIHlvdSBhbnRpY2lwYXRlIG1hbnkgcmVzdWx0cywgeW91IGNhbiBlbmQgYSBzdHJlYW0gZWFybHkgdG8gcHJldmVudFxuICAgICAgICAgKiAvLyB1bm5lY2Vzc2FyeSBwcm9jZXNzaW5nIGFuZCBBUEkgcmVxdWVzdHMuXG4gICAgICAgICAqIC8vLVxuICAgICAgICAgKiBiaWdxdWVyeS5nZXRKb2JzU3RyZWFtKClcbiAgICAgICAgICogICAub24oJ2RhdGEnLCBmdW5jdGlvbihqb2IpIHtcbiAgICAgICAgICogICAgIHRoaXMuZW5kKCk7XG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRKb2JzU3RyZWFtID0gcGFnaW5hdG9yXzEucGFnaW5hdG9yLnN0cmVhbWlmeSgnZ2V0Sm9icycpO1xuICAgICAgICAvLyBEaXNhYmxlIGBwcmV0dHlQcmludGAgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvbm9kZWpzLWJpZ3F1ZXJ5L2lzc3Vlcy84NThcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMucHVzaCh7XG4gICAgICAgICAgICByZXF1ZXN0OiAocmVxT3B0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmQodHJ1ZSwge30sIHJlcU9wdHMsIHsgcXM6IHsgcHJldHR5UHJpbnQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0cmFjZV8obXNnLCAuLi5vdGhlckFyZ3MpIHtcbiAgICAgICAgKDAsIGxvZ2dlcl8xLmxvZ2dlcikoJ1tiaWdxdWVyeV0nLCBtc2csIC4uLm90aGVyQXJncyk7XG4gICAgfVxuICAgIGdldCB1bml2ZXJzZURvbWFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VuaXZlcnNlRG9tYWluO1xuICAgIH1cbiAgICBzdGF0aWMgc2FuaXRpemVFbmRwb2ludCh1cmwpIHtcbiAgICAgICAgaWYgKCFleHBvcnRzLlBST1RPQ09MX1JFR0VYLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgdXJsID0gYGh0dHBzOi8vJHt1cmx9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zYW5pdGl6ZURvbWFpbih1cmwpO1xuICAgIH1cbiAgICBzdGF0aWMgc2FuaXRpemVEb21haW4odXJsKSB7XG4gICAgICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFwvKyQvLCAnJyk7IC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlIGEgcm93c2V0IHJldHVybmVkIGZyb20gdGhlIEFQSSB3aXRoIGEgdGFibGUgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAgICAgKiBAcGFyYW0ge2FycmF5fSByb3dzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58SW50ZWdlclR5cGVDYXN0T3B0aW9uc30gb3B0aW9ucy53cmFwSW50ZWdlcnMgV3JhcCB2YWx1ZXMgb2ZcbiAgICAgKiAgICAgJ0lOVDY0JyB0eXBlIGluIHtAbGluayBCaWdRdWVyeUludH0gb2JqZWN0cy5cbiAgICAgKiAgICAgSWYgYSBgYm9vbGVhbmAsIHRoaXMgd2lsbCB3cmFwIHZhbHVlcyBpbiB7QGxpbmsgQmlnUXVlcnlJbnR9IG9iamVjdHMuXG4gICAgICogICAgIElmIGFuIGBvYmplY3RgLCB0aGlzIHdpbGwgcmV0dXJuIGEgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgKiAgICAgYHdyYXBJbnRlZ2Vycy5pbnRlZ2VyVHlwZUNhc3RGdW5jdGlvbmAuXG4gICAgICogICAgIFBsZWFzZSBzZWUge0BsaW5rIEludGVnZXJUeXBlQ2FzdE9wdGlvbnN9IGZvciBvcHRpb25zIGRlc2NyaXB0aW9ucy5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBvcHRpb25zLnNlbGVjdGVkRmllbGRzIExpc3Qgb2YgZmllbGRzIHRvIHJldHVybi5cbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHthcnJheX0gb3B0aW9ucy5wYXJzZUpTT04gcGFyc2UgYSAnSlNPTicgZmllbGQgaW50byBhIEpTT04gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEZpZWxkcyB1c2luZyB0aGVpciBtYXRjaGluZyBuYW1lcyBmcm9tIHRoZSB0YWJsZSdzIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2VTY2hlbWFXaXRoUm93c18oc2NoZW1hLCByb3dzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGRlZXAgY29weSBzY2hlbWEgZmllbGRzIHRvIGF2b2lkIG11dGF0aW9uXG4gICAgICAgIGxldCBzY2hlbWFGaWVsZHMgPSBleHRlbmQodHJ1ZSwgW10sIHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS5maWVsZHMpO1xuICAgICAgICBsZXQgc2VsZWN0ZWRGaWVsZHMgPSBleHRlbmQodHJ1ZSwgW10sIG9wdGlvbnMuc2VsZWN0ZWRGaWVsZHMpO1xuICAgICAgICBpZiAob3B0aW9ucy5zZWxlY3RlZEZpZWxkcyAmJiBvcHRpb25zLnNlbGVjdGVkRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRmllbGRzQXJyYXkgPSBvcHRpb25zLnNlbGVjdGVkRmllbGRzLm1hcChjID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5zcGxpdCgnLicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RmllbGRzID0gc2VsZWN0ZWRGaWVsZHNBcnJheVxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLnNoaWZ0KCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjID0+IGMgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAvL2ZpbHRlciBzY2hlbWEgZmllbGRzIGJhc2VkIG9uIHNlbGVjdGVkIGZpZWxkcy5cbiAgICAgICAgICAgIHNjaGVtYUZpZWxkcyA9IHNjaGVtYUZpZWxkcy5maWx0ZXIoZmllbGQgPT4gY3VycmVudEZpZWxkc1xuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgLmluZGV4T2YoZmllbGQubmFtZS50b0xvd2VyQ2FzZSgpKSA+PSAwKTtcbiAgICAgICAgICAgIHNlbGVjdGVkRmllbGRzID0gc2VsZWN0ZWRGaWVsZHNBcnJheVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgLm1hcChjID0+IGMuam9pbignLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyaWZ5KHJvd3MpLm1hcChtZXJnZVNjaGVtYSkubWFwKGZsYXR0ZW5Sb3dzKTtcbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VTY2hlbWEocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gcm93LmYubWFwKChmaWVsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFGaWVsZCA9IHNjaGVtYUZpZWxkc1tpbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmllbGQudjtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hRmllbGQgJiYgc2NoZW1hRmllbGQubW9kZSA9PT0gJ1JFUEVBVEVEJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh2YWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRTY2hlbWFGaWVsZFZhbHVlKHNjaGVtYUZpZWxkLCB2YWwudiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRTY2hlbWFGaWVsZFZhbHVlKHNjaGVtYUZpZWxkLCB2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRmllbGRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGZpZWxkT2JqZWN0W3NjaGVtYUZpZWxkLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkT2JqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZnVuY3Rpb24gZmxhdHRlblJvd3Mocm93cykge1xuICAgICAgICAgICAgcmV0dXJuIHJvd3MucmVkdWNlKChhY2MsIHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKHJvdylbMF07XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSByb3dba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgREFURWAgdHlwZSByZXByZXNlbnRzIGEgbG9naWNhbCBjYWxlbmRhciBkYXRlLCBpbmRlcGVuZGVudCBvZiB0aW1lXG4gICAgICogem9uZS4gSXQgZG9lcyBub3QgcmVwcmVzZW50IGEgc3BlY2lmaWMgMjQtaG91ciB0aW1lIHBlcmlvZC4gUmF0aGVyLCBhIGdpdmVuXG4gICAgICogREFURSB2YWx1ZSByZXByZXNlbnRzIGEgZGlmZmVyZW50IDI0LWhvdXIgcGVyaW9kIHdoZW4gaW50ZXJwcmV0ZWQgaW5cbiAgICAgKiBkaWZmZXJlbnQgdGltZSB6b25lcywgYW5kIG1heSByZXByZXNlbnQgYSBzaG9ydGVyIG9yIGxvbmdlciBkYXkgZHVyaW5nXG4gICAgICogRGF5bGlnaHQgU2F2aW5ncyBUaW1lIHRyYW5zaXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgZGF0ZS4gSWYgYSBzdHJpbmcsIHRoaXMgc2hvdWxkIGJlIGluIHRoZVxuICAgICAqICAgICBmb3JtYXQgdGhlIEFQSSBkZXNjcmliZXM6IGBZWVlZLVtNXU0tW0RdRGAuXG4gICAgICogICAgIE90aGVyd2lzZSwgcHJvdmlkZSBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZS55ZWFyIEZvdXIgZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUubW9udGggT25lIG9yIHR3byBkaWdpdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZS5kYXkgT25lIG9yIHR3byBkaWdpdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCBkYXRlID0gYmlncXVlcnkuZGF0ZSgnMjAxNy0wMS0wMScpO1xuICAgICAqXG4gICAgICogLy8tXG4gICAgICogLy8gQWx0ZXJuYXRpdmVseSwgcHJvdmlkZSBhbiBvYmplY3QuXG4gICAgICogLy8tXG4gICAgICogY29uc3QgZGF0ZTIgPSBiaWdxdWVyeS5kYXRlKHtcbiAgICAgKiAgIHllYXI6IDIwMTcsXG4gICAgICogICBtb250aDogMSxcbiAgICAgKiAgIGRheTogMVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBkYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnUXVlcnlEYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgZGF0ZS4gSWYgYSBzdHJpbmcsIHRoaXMgc2hvdWxkIGJlIGluIHRoZVxuICAgICAqICAgICBmb3JtYXQgdGhlIEFQSSBkZXNjcmliZXM6IGBZWVlZLVtNXU0tW0RdRGAuXG4gICAgICogICAgIE90aGVyd2lzZSwgcHJvdmlkZSBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZS55ZWFyIEZvdXIgZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUubW9udGggT25lIG9yIHR3byBkaWdpdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZS5kYXkgT25lIG9yIHR3byBkaWdpdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgZGF0ZSA9IEJpZ1F1ZXJ5LmRhdGUoJzIwMTctMDEtMDEnKTtcbiAgICAgKlxuICAgICAqIC8vLVxuICAgICAqIC8vIEFsdGVybmF0aXZlbHksIHByb3ZpZGUgYW4gb2JqZWN0LlxuICAgICAqIC8vLVxuICAgICAqIGNvbnN0IGRhdGUyID0gQmlnUXVlcnkuZGF0ZSh7XG4gICAgICogICB5ZWFyOiAyMDE3LFxuICAgICAqICAgbW9udGg6IDEsXG4gICAgICogICBkYXk6IDFcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCaWdRdWVyeS5kYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBgREFURVRJTUVgIGRhdGEgdHlwZSByZXByZXNlbnRzIGEgcG9pbnQgaW4gdGltZS4gVW5saWtlIGEgYFRJTUVTVEFNUGAsXG4gICAgICogdGhpcyBkb2VzIG5vdCByZWZlciB0byBhbiBhYnNvbHV0ZSBpbnN0YW5jZSBpbiB0aW1lLiBJbnN0ZWFkLCBpdCBpcyB0aGVcbiAgICAgKiBjaXZpbCB0aW1lLCBvciB0aGUgdGltZSB0aGF0IGEgdXNlciB3b3VsZCBzZWUgb24gYSB3YXRjaCBvciBjYWxlbmRhci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgQmlnUXVlcnkuZGF0ZXRpbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB0aW1lLiBJZiBhIHN0cmluZywgdGhpcyBzaG91bGQgYmUgaW4gdGhlXG4gICAgICogICAgIGZvcm1hdCB0aGUgQVBJIGRlc2NyaWJlczogYFlZWVktW01dTS1bRF1EWyBbSF1IOltNXU06W1NdU1suREREREREXV1gLlxuICAgICAqICAgICBPdGhlcndpc2UsIHByb3ZpZGUgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUueWVhciBGb3VyIGRpZ2l0cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlLm1vbnRoIE9uZSBvciB0d28gZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUuZGF5IE9uZSBvciB0d28gZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ZhbHVlLmhvdXJzXSBPbmUgb3IgdHdvIGRpZ2l0cyAoYDAwYCAtIGAyM2ApLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ZhbHVlLm1pbnV0ZXNdIE9uZSBvciB0d28gZGlnaXRzIChgMDBgIC0gYDU5YCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbdmFsdWUuc2Vjb25kc10gT25lIG9yIHR3byBkaWdpdHMgKGAwMGAgLSBgNTlgKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFt2YWx1ZS5mcmFjdGlvbmFsXSBVcCB0byBzaXggZGlnaXRzIGZvciBtaWNyb3NlY29uZFxuICAgICAqICAgICBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgZGF0ZXRpbWUgPSBCaWdRdWVyeS5kYXRldGltZSgnMjAxNy0wMS0wMSAxMzowMDowMCcpO1xuICAgICAqXG4gICAgICogLy8tXG4gICAgICogLy8gQWx0ZXJuYXRpdmVseSwgcHJvdmlkZSBhbiBvYmplY3QuXG4gICAgICogLy8tXG4gICAgICogY29uc3QgZGF0ZXRpbWUgPSBCaWdRdWVyeS5kYXRldGltZSh7XG4gICAgICogICB5ZWFyOiAyMDE3LFxuICAgICAqICAgbW9udGg6IDEsXG4gICAgICogICBkYXk6IDEsXG4gICAgICogICBob3VyczogMTQsXG4gICAgICogICBtaW51dGVzOiAwLFxuICAgICAqICAgc2Vjb25kczogMFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEEgYERBVEVUSU1FYCBkYXRhIHR5cGUgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUuIFVubGlrZSBhIGBUSU1FU1RBTVBgLFxuICAgICAqIHRoaXMgZG9lcyBub3QgcmVmZXIgdG8gYW4gYWJzb2x1dGUgaW5zdGFuY2UgaW4gdGltZS4gSW5zdGVhZCwgaXQgaXMgdGhlXG4gICAgICogY2l2aWwgdGltZSwgb3IgdGhlIHRpbWUgdGhhdCBhIHVzZXIgd291bGQgc2VlIG9uIGEgd2F0Y2ggb3IgY2FsZW5kYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB0aW1lLiBJZiBhIHN0cmluZywgdGhpcyBzaG91bGQgYmUgaW4gdGhlXG4gICAgICogICAgIGZvcm1hdCB0aGUgQVBJIGRlc2NyaWJlczogYFlZWVktW01dTS1bRF1EWyBbSF1IOltNXU06W1NdU1suREREREREXV1gLlxuICAgICAqICAgICBPdGhlcndpc2UsIHByb3ZpZGUgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUueWVhciBGb3VyIGRpZ2l0cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlLm1vbnRoIE9uZSBvciB0d28gZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUuZGF5IE9uZSBvciB0d28gZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ZhbHVlLmhvdXJzXSBPbmUgb3IgdHdvIGRpZ2l0cyAoYDAwYCAtIGAyM2ApLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ZhbHVlLm1pbnV0ZXNdIE9uZSBvciB0d28gZGlnaXRzIChgMDBgIC0gYDU5YCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbdmFsdWUuc2Vjb25kc10gT25lIG9yIHR3byBkaWdpdHMgKGAwMGAgLSBgNTlgKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFt2YWx1ZS5mcmFjdGlvbmFsXSBVcCB0byBzaXggZGlnaXRzIGZvciBtaWNyb3NlY29uZFxuICAgICAqICAgICBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCBkYXRldGltZSA9IGJpZ3F1ZXJ5LmRhdGV0aW1lKCcyMDE3LTAxLTAxIDEzOjAwOjAwJyk7XG4gICAgICpcbiAgICAgKiAvLy1cbiAgICAgKiAvLyBBbHRlcm5hdGl2ZWx5LCBwcm92aWRlIGFuIG9iamVjdC5cbiAgICAgKiAvLy1cbiAgICAgKiBjb25zdCBkYXRldGltZSA9IGJpZ3F1ZXJ5LmRhdGV0aW1lKHtcbiAgICAgKiAgIHllYXI6IDIwMTcsXG4gICAgICogICBtb250aDogMSxcbiAgICAgKiAgIGRheTogMSxcbiAgICAgKiAgIGhvdXJzOiAxNCxcbiAgICAgKiAgIG1pbnV0ZXM6IDAsXG4gICAgICogICBzZWNvbmRzOiAwXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGRhdGV0aW1lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnUXVlcnlEYXRldGltZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRhdGV0aW1lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCaWdRdWVyeS5kYXRldGltZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgYFRJTUVgIGRhdGEgdHlwZSByZXByZXNlbnRzIGEgdGltZSwgaW5kZXBlbmRlbnQgb2YgYSBzcGVjaWZpYyBkYXRlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBCaWdRdWVyeS50aW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdGltZS4gSWYgYSBzdHJpbmcsIHRoaXMgc2hvdWxkIGJlIGluIHRoZVxuICAgICAqICAgICBmb3JtYXQgdGhlIEFQSSBkZXNjcmliZXM6IGBbSF1IOltNXU06W1NdU1suREREREREXWAuIE90aGVyd2lzZSwgcHJvdmlkZVxuICAgICAqICAgICBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbdmFsdWUuaG91cnNdIE9uZSBvciB0d28gZGlnaXRzIChgMDBgIC0gYDIzYCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbdmFsdWUubWludXRlc10gT25lIG9yIHR3byBkaWdpdHMgKGAwMGAgLSBgNTlgKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFt2YWx1ZS5zZWNvbmRzXSBPbmUgb3IgdHdvIGRpZ2l0cyAoYDAwYCAtIGA1OWApLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ZhbHVlLmZyYWN0aW9uYWxdIFVwIHRvIHNpeCBkaWdpdHMgZm9yIG1pY3Jvc2Vjb25kXG4gICAgICogICAgIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgKiBjb25zdCB0aW1lID0gQmlnUXVlcnkudGltZSgnMTQ6MDA6MDAnKTsgLy8gMjowMCBQTVxuICAgICAqXG4gICAgICogLy8tXG4gICAgICogLy8gQWx0ZXJuYXRpdmVseSwgcHJvdmlkZSBhbiBvYmplY3QuXG4gICAgICogLy8tXG4gICAgICogY29uc3QgdGltZSA9IEJpZ1F1ZXJ5LnRpbWUoe1xuICAgICAqICAgaG91cnM6IDE0LFxuICAgICAqICAgbWludXRlczogMCxcbiAgICAgKiAgIHNlY29uZHM6IDBcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIGBUSU1FYCBkYXRhIHR5cGUgcmVwcmVzZW50cyBhIHRpbWUsIGluZGVwZW5kZW50IG9mIGEgc3BlY2lmaWMgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHRpbWUuIElmIGEgc3RyaW5nLCB0aGlzIHNob3VsZCBiZSBpbiB0aGVcbiAgICAgKiAgICAgZm9ybWF0IHRoZSBBUEkgZGVzY3JpYmVzOiBgW0hdSDpbTV1NOltTXVNbLkRERERERF1gLiBPdGhlcndpc2UsIHByb3ZpZGVcbiAgICAgKiAgICAgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ZhbHVlLmhvdXJzXSBPbmUgb3IgdHdvIGRpZ2l0cyAoYDAwYCAtIGAyM2ApLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ZhbHVlLm1pbnV0ZXNdIE9uZSBvciB0d28gZGlnaXRzIChgMDBgIC0gYDU5YCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbdmFsdWUuc2Vjb25kc10gT25lIG9yIHR3byBkaWdpdHMgKGAwMGAgLSBgNTlgKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFt2YWx1ZS5mcmFjdGlvbmFsXSBVcCB0byBzaXggZGlnaXRzIGZvciBtaWNyb3NlY29uZFxuICAgICAqICAgICBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCB0aW1lID0gYmlncXVlcnkudGltZSgnMTQ6MDA6MDAnKTsgLy8gMjowMCBQTVxuICAgICAqXG4gICAgICogLy8tXG4gICAgICogLy8gQWx0ZXJuYXRpdmVseSwgcHJvdmlkZSBhbiBvYmplY3QuXG4gICAgICogLy8tXG4gICAgICogY29uc3QgdGltZSA9IGJpZ3F1ZXJ5LnRpbWUoe1xuICAgICAqICAgaG91cnM6IDE0LFxuICAgICAqICAgbWludXRlczogMCxcbiAgICAgKiAgIHNlY29uZHM6IDBcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgdGltZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ1F1ZXJ5VGltZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRpbWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJpZ1F1ZXJ5LnRpbWUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHRpbWVzdGFtcCByZXByZXNlbnRzIGFuIGFic29sdXRlIHBvaW50IGluIHRpbWUsIGluZGVwZW5kZW50IG9mIGFueSB0aW1lXG4gICAgICogem9uZSBvciBjb252ZW50aW9uIHN1Y2ggYXMgRGF5bGlnaHQgU2F2aW5ncyBUaW1lLlxuICAgICAqXG4gICAgICogVGhlIHJlY29tbWVuZGVkIGlucHV0IGhlcmUgaXMgYSBgRGF0ZWAgb3IgYFByZWNpc2VEYXRlYCBjbGFzcy5cbiAgICAgKiBJZiBwYXNzaW5nIGFzIGEgYHN0cmluZ2AsIGl0IHNob3VsZCBiZSBUaW1lc3RhbXAgbGl0ZXJhbHM6IGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9zdGFuZGFyZC1zcWwvbGV4aWNhbCN0aW1lc3RhbXBfbGl0ZXJhbHMuXG4gICAgICogV2hlbiBwYXNzaW5nIGEgYG51bWJlcmAgaW5wdXQsIGl0IHNob3VsZCBiZSBlcG9jaCBzZWNvbmRzIGluIGZsb2F0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBCaWdRdWVyeS50aW1lc3RhbXBcbiAgICAgKiBAcGFyYW0ge0RhdGV8c3RyaW5nfSB2YWx1ZSBUaGUgdGltZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgKiBjb25zdCB0aW1lc3RhbXAgPSBCaWdRdWVyeS50aW1lc3RhbXAobmV3IERhdGUoKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIHRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ1F1ZXJ5VGltZXN0YW1wKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB0aW1lc3RhbXAgcmVwcmVzZW50cyBhbiBhYnNvbHV0ZSBwb2ludCBpbiB0aW1lLCBpbmRlcGVuZGVudCBvZiBhbnkgdGltZVxuICAgICAqIHpvbmUgb3IgY29udmVudGlvbiBzdWNoIGFzIERheWxpZ2h0IFNhdmluZ3MgVGltZS5cbiAgICAgKlxuICAgICAqIFRoZSByZWNvbW1lbmRlZCBpbnB1dCBoZXJlIGlzIGEgYERhdGVgIG9yIGBQcmVjaXNlRGF0ZWAgY2xhc3MuXG4gICAgICogSWYgcGFzc2luZyBhcyBhIGBzdHJpbmdgLCBpdCBzaG91bGQgYmUgVGltZXN0YW1wIGxpdGVyYWxzOiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2Uvc3RhbmRhcmQtc3FsL2xleGljYWwjdGltZXN0YW1wX2xpdGVyYWxzLlxuICAgICAqIFdoZW4gcGFzc2luZyBhIGBudW1iZXJgIGlucHV0LCBpdCBzaG91bGQgYmUgZXBvY2ggc2Vjb25kcyBpbiBmbG9hdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RGF0ZXxzdHJpbmd8c3RyaW5nfG51bWJlcn0gdmFsdWUgVGhlIHRpbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCB0aW1lc3RhbXAgPSBiaWdxdWVyeS50aW1lc3RhbXAobmV3IERhdGUoKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGltZXN0YW1wKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCaWdRdWVyeS50aW1lc3RhbXAodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJhbmdlIHJlcHJlc2VudHMgY29udGlndW91cyByYW5nZSBiZXR3ZWVuIHR3byBkYXRlcywgZGF0ZXRpbWVzLCBvciB0aW1lc3RhbXBzLlxuICAgICAqIFRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgZm9yIHRoZSByYW5nZSBhcmUgb3B0aW9uYWwuXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIGlzIGluY2x1c2l2ZSBhbmQgdGhlIHVwcGVyIGJvdW5kIGlzIGV4Y2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgQmlnUXVlcnkucmFuZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xCaWdRdWVyeVJhbmdlT3B0aW9uc30gdmFsdWUgVGhlIHJhbmdlIEFQSSBzdHJpbmcgb3Igc3RhcnQvZW5kIHdpdGggZGF0ZXMvZGF0ZXRpbWVzL3RpbWVzdGFtcCByYW5nZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlIFRoZSByYW5nZSBlbGVtZW50IHR5cGUgLSBEQVRFfERBVEVUSU1FfFRJTUVTVEFNUFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAqIGNvbnN0IHRpbWVzdGFtcFJhbmdlID0gQmlnUXVlcnkucmFuZ2UoJ1syMDIwLTEwLTAxIDEyOjAwOjAwKzA4LCAyMDIwLTEyLTMxIDEyOjAwOjAwKzA4KScsICdUSU1FU1RBTVAnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgcmFuZ2UodmFsdWUsIGVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnUXVlcnlSYW5nZSh2YWx1ZSwgZWxlbWVudFR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJhbmdlIHJlcHJlc2VudHMgY29udGlndW91cyByYW5nZSBiZXR3ZWVuIHR3byBkYXRlcywgZGF0ZXRpbWVzLCBvciB0aW1lc3RhbXBzLlxuICAgICAqIFRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgZm9yIHRoZSByYW5nZSBhcmUgb3B0aW9uYWwuXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIGlzIGluY2x1c2l2ZSBhbmQgdGhlIHVwcGVyIGJvdW5kIGlzIGV4Y2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJpZ1F1ZXJ5UmFuZ2VPcHRpb25zfSB2YWx1ZSBUaGUgcmFuZ2UgQVBJIHN0cmluZyBvciBzdGFydC9lbmQgd2l0aCBkYXRlcy9kYXRldGltZXMvdGltZXN0YW1wIHJhbmdlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGUgVGhlIHJhbmdlIGVsZW1lbnQgdHlwZSAtIERBVEV8REFURVRJTUV8VElNRVNUQU1QXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCB0aW1lc3RhbXBSYW5nZSA9IGJpZ3F1ZXJ5LnJhbmdlKCdbMjAyMC0xMC0wMSAxMjowMDowMCswOCwgMjAyMC0xMi0zMSAxMjowMDowMCswOCknLCAnVElNRVNUQU1QJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmFuZ2UodmFsdWUsIGVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBCaWdRdWVyeS5yYW5nZSh2YWx1ZSwgZWxlbWVudFR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEJpZ1F1ZXJ5SW50IHdyYXBzICdJTlQ2NCcgdmFsdWVzLiBDYW4gYmUgdXNlZCB0byBtYWludGFpbiBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8SW50ZWdlclR5cGVDYXN0VmFsdWV9IHZhbHVlIFRoZSBJTlQ2NCB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7SW50ZWdlclR5cGVDYXN0T3B0aW9uc30gdHlwZUNhc3RPcHRpb25zIENvbmZpZ3VyYXRpb24gdG8gY29udmVydFxuICAgICAqICAgICB2YWx1ZS4gTXVzdCBwcm92aWRlIGFuIGBpbnRlZ2VyVHlwZUNhc3RGdW5jdGlvbmAgdG8gaGFuZGxlIGNvbnZlcnNpb24uXG4gICAgICogQHJldHVybnMge0JpZ1F1ZXJ5SW50fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICpcbiAgICAgKiBjb25zdCBsYXJnZUludGVnZXJWYWx1ZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICsgMTtcbiAgICAgKlxuICAgICAqIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICogICBpbnRlZ2VyVHlwZUNhc3RGdW5jdGlvbjogdmFsdWUgPT4gdmFsdWUuc3BsaXQoKSxcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogY29uc3QgYnFJbnRlZ2VyID0gYmlncXVlcnkuaW50KGxhcmdlSW50ZWdlclZhbHVlLCBvcHRpb25zKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGN1c3RvbVZhbHVlID0gYnFJbnRlZ2VyLnZhbHVlT2YoKTtcbiAgICAgKiAvLyBjdXN0b21WYWx1ZSBpcyB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB5b3VyIGBpbnRlZ2VyVHlwZUNhc3RGdW5jdGlvbmAuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGludCh2YWx1ZSwgdHlwZUNhc3RPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnUXVlcnlJbnQodmFsdWUsIHR5cGVDYXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIGludCh2YWx1ZSwgdHlwZUNhc3RPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBCaWdRdWVyeS5pbnQodmFsdWUsIHR5cGVDYXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2VvZ3JhcGh5IHZhbHVlIHJlcHJlc2VudHMgYSBzdXJmYWNlIGFyZWEgb24gdGhlIEVhcnRoXG4gICAgICogaW4gV2VsbC1rbm93biBUZXh0IChXS1QpIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgZ2Vvc3BhdGlhbCBkYXRhLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICogY29uc3QgZ2VvZ3JhcGh5ID0gYmlncXVlcnkuZ2VvZ3JhcGh5KCdQT0lOVCgxLCAyKScpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZW9ncmFwaHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW9ncmFwaHkodmFsdWUpO1xuICAgIH1cbiAgICBnZW9ncmFwaHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJpZ1F1ZXJ5Lmdlb2dyYXBoeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gSU5UNjQgdmFsdWUgdG8gTnVtYmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgVGhlIElOVDY0IHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICovXG4gICAgc3RhdGljIGRlY29kZUludGVnZXJWYWx1ZV8odmFsdWUpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKHZhbHVlLmludGVnZXJWYWx1ZSk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBhdHRlbXB0ZWQgdG8gcmV0dXJuIGFsbCBvZiB0aGUgbnVtZXJpYyB2YWx1ZXMsIGJ1dCAnICtcbiAgICAgICAgICAgICAgICAodmFsdWUuc2NoZW1hRmllbGROYW1lID8gdmFsdWUuc2NoZW1hRmllbGROYW1lICsgJyAnIDogJycpICtcbiAgICAgICAgICAgICAgICAndmFsdWUgJyArXG4gICAgICAgICAgICAgICAgdmFsdWUuaW50ZWdlclZhbHVlICtcbiAgICAgICAgICAgICAgICBcIiBpcyBvdXQgb2YgYm91bmRzIG9mICdOdW1iZXIuTUFYX1NBRkVfSU5URUdFUicuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiVG8gcHJldmVudCB0aGlzIGVycm9yLCBwbGVhc2UgY29uc2lkZXIgcGFzc2luZyAnb3B0aW9ucy53cmFwSW50ZWdlcnMnIGFzXFxuXCIgK1xuICAgICAgICAgICAgICAgICd7XFxuJyArXG4gICAgICAgICAgICAgICAgJyAgaW50ZWdlclR5cGVDYXN0RnVuY3Rpb246IHByb3ZpZGUgPHlvdXJfY3VzdG9tX2Z1bmN0aW9uPlxcbicgK1xuICAgICAgICAgICAgICAgICcgIGZpZWxkczogb3B0aW9uYWxseSBzcGVjaWZ5IGZpZWxkIG5hbWUocykgdG8gYmUgY3VzdG9tIGNhc3RlZFxcbicgK1xuICAgICAgICAgICAgICAgICd9XFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdmFsdWUncyBwcm92aWRlZCB0eXBlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aGUgdHlwZSBwcm92aWRlZCBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZGF0YS10eXBlc3wgRGF0YSBUeXBlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBwcm92aWRlZFR5cGUgVGhlIHR5cGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHZhbGlkIHR5cGUgcHJvdmlkZWQuXG4gICAgICovXG4gICAgc3RhdGljIGdldFR5cGVEZXNjcmlwdG9yRnJvbVByb3ZpZGVkVHlwZV8ocHJvdmlkZWRUeXBlKSB7XG4gICAgICAgIC8vIFRoZSBsaXN0IG9mIHR5cGVzIGNhbiBiZSBmb3VuZCBpbiBzcmMvdHlwZXMuZC50c1xuICAgICAgICBjb25zdCBWQUxJRF9UWVBFUyA9IFtcbiAgICAgICAgICAgICdEQVRFJyxcbiAgICAgICAgICAgICdEQVRFVElNRScsXG4gICAgICAgICAgICAnVElNRScsXG4gICAgICAgICAgICAnVElNRVNUQU1QJyxcbiAgICAgICAgICAgICdCWVRFUycsXG4gICAgICAgICAgICAnTlVNRVJJQycsXG4gICAgICAgICAgICAnREVDSU1BTCcsXG4gICAgICAgICAgICAnQklHTlVNRVJJQycsXG4gICAgICAgICAgICAnQklHREVDSU1BTCcsXG4gICAgICAgICAgICAnQk9PTCcsXG4gICAgICAgICAgICAnSU5UNjQnLFxuICAgICAgICAgICAgJ0lOVCcsXG4gICAgICAgICAgICAnU01BTExJTlQnLFxuICAgICAgICAgICAgJ0lOVEVHRVInLFxuICAgICAgICAgICAgJ0JJR0lOVCcsXG4gICAgICAgICAgICAnVElOWUlOVCcsXG4gICAgICAgICAgICAnQllURUlOVCcsXG4gICAgICAgICAgICAnRkxPQVQ2NCcsXG4gICAgICAgICAgICAnRkxPQVQnLFxuICAgICAgICAgICAgJ1NUUklORycsXG4gICAgICAgICAgICAnR0VPR1JBUEhZJyxcbiAgICAgICAgICAgICdBUlJBWScsXG4gICAgICAgICAgICAnU1RSVUNUJyxcbiAgICAgICAgICAgICdKU09OJyxcbiAgICAgICAgICAgICdSQU5HRScsXG4gICAgICAgIF07XG4gICAgICAgIGlmIChpcy5hcnJheShwcm92aWRlZFR5cGUpKSB7XG4gICAgICAgICAgICBwcm92aWRlZFR5cGUgPSBwcm92aWRlZFR5cGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBUlJBWScsXG4gICAgICAgICAgICAgICAgYXJyYXlUeXBlOiBCaWdRdWVyeS5nZXRUeXBlRGVzY3JpcHRvckZyb21Qcm92aWRlZFR5cGVfKHByb3ZpZGVkVHlwZVswXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLm9iamVjdChwcm92aWRlZFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdTVFJVQ1QnLFxuICAgICAgICAgICAgICAgIHN0cnVjdFR5cGVzOiBPYmplY3Qua2V5cyhwcm92aWRlZFR5cGUpLm1hcChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBCaWdRdWVyeS5nZXRUeXBlRGVzY3JpcHRvckZyb21Qcm92aWRlZFR5cGVfKHByb3ZpZGVkVHlwZVtwcm9wXSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVkVHlwZSA9IHByb3ZpZGVkVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoIVZBTElEX1RZUEVTLmluY2x1ZGVzKHByb3ZpZGVkVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0eXBlIHByb3ZpZGVkOiBcIiR7cHJvdmlkZWRUeXBlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogcHJvdmlkZWRUeXBlLnRvVXBwZXJDYXNlKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGEgdmFsdWUncyB0eXBlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aGUgdHlwZSBjb3VsZCBub3QgYmUgZGV0ZWN0ZWQuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kYXRhLXR5cGVzfCBEYXRhIFR5cGV9XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHlwZSBkZXRlY3RlZCBmcm9tIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VHlwZURlc2NyaXB0b3JGcm9tVmFsdWVfKHZhbHVlKSB7XG4gICAgICAgIGxldCB0eXBlTmFtZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgdHlwZXMgbXVzdCBiZSBwcm92aWRlZCBmb3IgbnVsbCB2YWx1ZXMgdmlhIHRoZSAndHlwZXMnIGZpZWxkIGluIHF1ZXJ5IG9wdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ1F1ZXJ5RGF0ZSkge1xuICAgICAgICAgICAgdHlwZU5hbWUgPSAnREFURSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdRdWVyeURhdGV0aW1lKSB7XG4gICAgICAgICAgICB0eXBlTmFtZSA9ICdEQVRFVElNRSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdRdWVyeVRpbWUpIHtcbiAgICAgICAgICAgIHR5cGVOYW1lID0gJ1RJTUUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnUXVlcnlUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHR5cGVOYW1lID0gJ1RJTUVTVEFNUCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgIHR5cGVOYW1lID0gJ0JZVEVTJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmMubGVuZ3RoIC0gdmFsdWUuZSA+PSAxMCkge1xuICAgICAgICAgICAgICAgIHR5cGVOYW1lID0gJ0JJR05VTUVSSUMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZU5hbWUgPSAnTlVNRVJJQyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdRdWVyeUludCkge1xuICAgICAgICAgICAgdHlwZU5hbWUgPSAnSU5UNjQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgR2VvZ3JhcGh5KSB7XG4gICAgICAgICAgICB0eXBlTmFtZSA9ICdHRU9HUkFQSFknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnUXVlcnlSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkFOR0UnLFxuICAgICAgICAgICAgICAgIHJhbmdlRWxlbWVudFR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdmFsdWUuZWxlbWVudFR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgdHlwZXMgbXVzdCBiZSBwcm92aWRlZCBmb3IgZW1wdHkgYXJyYXlzIHZpYSB0aGUgJ3R5cGVzJyBmaWVsZCBpbiBxdWVyeSBvcHRpb25zLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FSUkFZJyxcbiAgICAgICAgICAgICAgICBhcnJheVR5cGU6IEJpZ1F1ZXJ5LmdldFR5cGVEZXNjcmlwdG9yRnJvbVZhbHVlXyh2YWx1ZVswXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLmJvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICB0eXBlTmFtZSA9ICdCT09MJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpcy5udW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB0eXBlTmFtZSA9IHZhbHVlICUgMSA9PT0gMCA/ICdJTlQ2NCcgOiAnRkxPQVQ2NCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMub2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU1RSVUNUJyxcbiAgICAgICAgICAgICAgICBzdHJ1Y3RUeXBlczogT2JqZWN0LmtleXModmFsdWUpLm1hcChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQmlnUXVlcnkuZ2V0VHlwZURlc2NyaXB0b3JGcm9tVmFsdWVfKHZhbHVlW3Byb3BdKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdHlwZU5hbWUgPSAnU1RSSU5HJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGVOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICAgICAgICAgICdUaGlzIHZhbHVlIGNvdWxkIG5vdCBiZSB0cmFuc2xhdGVkIHRvIGEgQmlnUXVlcnkgZGF0YSB0eXBlLicsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZU5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgYHF1ZXJ5UGFyYW1ldGVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvcmVzdC92Mi9qb2JzL3F1ZXJ5I3JlcXVlc3QtYm9keXwgSm9icy5xdWVyeSBBUEkgUmVmZXJlbmNlIERvY3MgKHNlZSBgcXVlcnlQYXJhbWV0ZXJzYCl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xQcm92aWRlZFR5cGVTdHJ1Y3R8UHJvdmlkZWRUeXBlQXJyYXl9IHByb3ZpZGVkVHlwZSBQcm92aWRlZFxuICAgICAqICAgICBxdWVyeSBwYXJhbWV0ZXIgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBIHByb3Blcmx5LWZvcm1lZCBgcXVlcnlQYXJhbWV0ZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsdWVUb1F1ZXJ5UGFyYW1ldGVyXyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHZhbHVlLCBwcm92aWRlZFR5cGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGlzLmRhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJpZ1F1ZXJ5LnRpbWVzdGFtcCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtZXRlclR5cGU7XG4gICAgICAgIGlmIChwcm92aWRlZFR5cGUpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlclR5cGUgPSBCaWdRdWVyeS5nZXRUeXBlRGVzY3JpcHRvckZyb21Qcm92aWRlZFR5cGVfKHByb3ZpZGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJUeXBlID0gQmlnUXVlcnkuZ2V0VHlwZURlc2NyaXB0b3JGcm9tVmFsdWVfKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlciA9IHsgcGFyYW1ldGVyVHlwZSwgcGFyYW1ldGVyVmFsdWU6IHt9IH07XG4gICAgICAgIGNvbnN0IHR5cGVOYW1lID0gcXVlcnlQYXJhbWV0ZXIucGFyYW1ldGVyVHlwZS50eXBlO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09ICdBUlJBWScpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyLnBhcmFtZXRlclZhbHVlLmFycmF5VmFsdWVzID0gdmFsdWUubWFwKGl0ZW1WYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdRdWVyeS5fZ2V0VmFsdWUoaXRlbVZhbHVlLCBwYXJhbWV0ZXJUeXBlLmFycmF5VHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzLm9iamVjdCh2YWx1ZSkgfHwgaXMuYXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcy5hcnJheShwcm92aWRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZFR5cGUgPSBwcm92aWRlZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnUXVlcnkudmFsdWVUb1F1ZXJ5UGFyYW1ldGVyXyh2YWx1ZSwgcHJvdmlkZWRUeXBlWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYXJhbWV0ZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdRdWVyeS52YWx1ZVRvUXVlcnlQYXJhbWV0ZXJfKHZhbHVlKS5wYXJhbWV0ZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZU5hbWUgPT09ICdTVFJVQ1QnKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtZXRlci5wYXJhbWV0ZXJWYWx1ZS5zdHJ1Y3RWYWx1ZXMgPSBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKChzdHJ1Y3RWYWx1ZXMsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbmVzdGVkUXVlcnlQYXJhbWV0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRRdWVyeVBhcmFtZXRlciA9IEJpZ1F1ZXJ5LnZhbHVlVG9RdWVyeVBhcmFtZXRlcl8odmFsdWVbcHJvcF0sIHByb3ZpZGVkVHlwZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRRdWVyeVBhcmFtZXRlciA9IEJpZ1F1ZXJ5LnZhbHVlVG9RdWVyeVBhcmFtZXRlcl8odmFsdWVbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHN0cnVjdFZhbHVlc1twcm9wXSA9IG5lc3RlZFF1ZXJ5UGFyYW1ldGVyLnBhcmFtZXRlclZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3RWYWx1ZXM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZU5hbWUgPT09ICdSQU5HRScpIHtcbiAgICAgICAgICAgIGxldCByYW5nZVZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnUXVlcnlSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlVmFsdWUgPSBCaWdRdWVyeS5yYW5nZSh2YWx1ZSwgKF9iID0gKF9hID0gcXVlcnlQYXJhbWV0ZXIucGFyYW1ldGVyVHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhbmdlRWxlbWVudFR5cGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyLnBhcmFtZXRlclZhbHVlLnJhbmdlVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJhbmdlVmFsdWUudmFsdWUuc3RhcnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJhbmdlVmFsdWUudmFsdWUuZW5kLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVOYW1lID09PSAnSlNPTicgJiYgaXMub2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXIucGFyYW1ldGVyVmFsdWUudmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtZXRlci5wYXJhbWV0ZXJWYWx1ZS52YWx1ZSA9IEJpZ1F1ZXJ5Ll9nZXRWYWx1ZSh2YWx1ZSwgcGFyYW1ldGVyVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1ldGVyO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBfZ2V0VmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSlcbiAgICAgICAgICAgIHR5cGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIEJpZ1F1ZXJ5Ll9pc0N1c3RvbVR5cGUodHlwZSkgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgX2lzQ3VzdG9tVHlwZSh7IHR5cGUgfSkge1xuICAgICAgICByZXR1cm4gKHR5cGUuaW5kZXhPZignVElNRScpID4gLTEgfHxcbiAgICAgICAgICAgIHR5cGUuaW5kZXhPZignREFURScpID4gLTEgfHxcbiAgICAgICAgICAgIHR5cGUuaW5kZXhPZignR0VPR1JBUEhZJykgPiAtMSB8fFxuICAgICAgICAgICAgdHlwZS5pbmRleE9mKCdSQU5HRScpID4gLTEgfHxcbiAgICAgICAgICAgIHR5cGUuaW5kZXhPZignQmlnUXVlcnlJbnQnKSA+IC0xKTtcbiAgICB9XG4gICAgY3JlYXRlRGF0YXNldChpZCwgb3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zT3JDYWxsYmFjayA6IGNiO1xuICAgICAgICBjb25zdCByZXFPcHRzID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmk6ICcvZGF0YXNldHMnLFxuICAgICAgICAgICAganNvbjogZXh0ZW5kKHRydWUsIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0UmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogaWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHJlcU9wdHMucHJvamVjdElkID0gb3B0aW9ucy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0KHJlcU9wdHMsIChlcnIsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGFzZXQoaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZGF0YXNldC5tZXRhZGF0YSA9IHJlc3A7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhc2V0LCByZXNwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVF1ZXJ5Sm9iKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgPyBvcHRzIDogeyBxdWVyeTogb3B0cyB9O1xuICAgICAgICB0aGlzLnRyYWNlXygnW2NyZWF0ZVF1ZXJ5Sm9iXScsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKCghb3B0aW9ucyB8fCAhb3B0aW9ucy5xdWVyeSkgJiYgIW9wdGlvbnMucGFnZVRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgU1FMIHF1ZXJ5IHN0cmluZyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeSA9IGV4dGVuZCh0cnVlLCB7XG4gICAgICAgICAgICB1c2VMZWdhY3lTcWw6IGZhbHNlLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50cmFjZV8oJ1tjcmVhdGVRdWVyeUpvYl0nLCBxdWVyeSk7XG4gICAgICAgIGlmIChvcHRpb25zLmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zLmRlc3RpbmF0aW9uIGluc3RhbmNlb2YgdGFibGVfMS5UYWJsZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rlc3RpbmF0aW9uIG11c3QgYmUgYSBUYWJsZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyeS5kZXN0aW5hdGlvblRhYmxlID0ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogb3B0aW9ucy5kZXN0aW5hdGlvbi5kYXRhc2V0LmlkLFxuICAgICAgICAgICAgICAgIHByb2plY3RJZDogb3B0aW9ucy5kZXN0aW5hdGlvbi5kYXRhc2V0LnByb2plY3RJZCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiBvcHRpb25zLmRlc3RpbmF0aW9uLmlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5kZXN0aW5hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkucGFyYW1zKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBhcmFtZXRlck1vZGUsIHBhcmFtcyB9ID0gdGhpcy5idWlsZFF1ZXJ5UGFyYW1zXyhxdWVyeS5wYXJhbXMsIHF1ZXJ5LnR5cGVzKTtcbiAgICAgICAgICAgIHF1ZXJ5LnBhcmFtZXRlck1vZGUgPSBwYXJhbWV0ZXJNb2RlO1xuICAgICAgICAgICAgcXVlcnkucXVlcnlQYXJhbWV0ZXJzID0gcGFyYW1zO1xuICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5LnBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXFPcHRzID0ge307XG4gICAgICAgIHJlcU9wdHMuY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5LmpvYlRpbWVvdXRNcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJlcU9wdHMuY29uZmlndXJhdGlvbi5qb2JUaW1lb3V0TXMgPSBxdWVyeS5qb2JUaW1lb3V0TXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5qb2JUaW1lb3V0TXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LmRyeVJ1bikge1xuICAgICAgICAgICAgcmVxT3B0cy5jb25maWd1cmF0aW9uLmRyeVJ1biA9IHF1ZXJ5LmRyeVJ1bjtcbiAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5kcnlSdW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LmxhYmVscykge1xuICAgICAgICAgICAgcmVxT3B0cy5jb25maWd1cmF0aW9uLmxhYmVscyA9IHF1ZXJ5LmxhYmVscztcbiAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5sYWJlbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LmpvYlByZWZpeCkge1xuICAgICAgICAgICAgcmVxT3B0cy5qb2JQcmVmaXggPSBxdWVyeS5qb2JQcmVmaXg7XG4gICAgICAgICAgICBkZWxldGUgcXVlcnkuam9iUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5sb2NhdGlvbikge1xuICAgICAgICAgICAgcmVxT3B0cy5sb2NhdGlvbiA9IHF1ZXJ5LmxvY2F0aW9uO1xuICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5LmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5qb2JJZCkge1xuICAgICAgICAgICAgcmVxT3B0cy5qb2JJZCA9IHF1ZXJ5LmpvYklkO1xuICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5LmpvYklkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlSm9iKHJlcU9wdHMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYnVpbGRRdWVyeVBhcmFtc18ocGFyYW1zLCB0eXBlcykge1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJNb2RlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlck1vZGUgPSBpcy5hcnJheShwYXJhbXMpID8gJ3Bvc2l0aW9uYWwnIDogJ25hbWVkJztcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGlmIChwYXJhbWV0ZXJNb2RlID09PSAnbmFtZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lZFBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZWRQYXJhbWV0ZXIgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobmFtZWRQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuYW1lZFBhcmFtc1tuYW1lZFBhcmFtZXRlcl07XG4gICAgICAgICAgICAgICAgbGV0IHF1ZXJ5UGFyYW1ldGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzLm9iamVjdCh0eXBlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgdHlwZXMgbXVzdCBtYXRjaCB0aGUgdmFsdWUgdHlwZSBwYXNzZWQgdG8gYHBhcmFtc2AnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lZFR5cGVzID0gdHlwZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lZFR5cGVzW25hbWVkUGFyYW1ldGVyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXIgPSBCaWdRdWVyeS52YWx1ZVRvUXVlcnlQYXJhbWV0ZXJfKHZhbHVlLCBuYW1lZFR5cGVzW25hbWVkUGFyYW1ldGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlciA9IEJpZ1F1ZXJ5LnZhbHVlVG9RdWVyeVBhcmFtZXRlcl8odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlciA9IEJpZ1F1ZXJ5LnZhbHVlVG9RdWVyeVBhcmFtZXRlcl8odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlci5uYW1lID0gbmFtZWRQYXJhbWV0ZXI7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzLnB1c2gocXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpcy5hcnJheSh0eXBlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCB0eXBlcyBtdXN0IG1hdGNoIHRoZSB2YWx1ZSB0eXBlIHBhc3NlZCB0byBgcGFyYW1zYCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbmFsVHlwZXMgPSB0eXBlcztcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gdHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG51bWJlciBvZiBwYXJhbWV0ZXIgdHlwZXMgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlciA9IEJpZ1F1ZXJ5LnZhbHVlVG9RdWVyeVBhcmFtZXRlcl8odmFsdWUsIHBvc2l0aW9uYWxUeXBlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVycy5wdXNoKHF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlciA9IEJpZ1F1ZXJ5LnZhbHVlVG9RdWVyeVBhcmFtZXRlcl8odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnMucHVzaChxdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcmFtZXRlck1vZGUsXG4gICAgICAgICAgICBwYXJhbXM6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlSm9iKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgSk9CX0lEX1BST1ZJREVEID0gdHlwZW9mIG9wdGlvbnMuam9iSWQgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICBjb25zdCBEUllfUlVOID0gKChfYSA9IG9wdGlvbnMuY29uZmlndXJhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyeVJ1bilcbiAgICAgICAgICAgID8gb3B0aW9ucy5jb25maWd1cmF0aW9uLmRyeVJ1blxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVxT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICBsZXQgam9iSWQgPSBKT0JfSURfUFJPVklERUQgPyByZXFPcHRzLmpvYklkIDogdXVpZC52NCgpO1xuICAgICAgICBpZiAocmVxT3B0cy5qb2JJZCkge1xuICAgICAgICAgICAgZGVsZXRlIHJlcU9wdHMuam9iSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcU9wdHMuam9iUHJlZml4KSB7XG4gICAgICAgICAgICBqb2JJZCA9IHJlcU9wdHMuam9iUHJlZml4ICsgam9iSWQ7XG4gICAgICAgICAgICBkZWxldGUgcmVxT3B0cy5qb2JQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgcmVxT3B0cy5qb2JSZWZlcmVuY2UgPSB7XG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMucHJvamVjdElkLFxuICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJlcU9wdHMuam9iUmVmZXJlbmNlLmxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbjtcbiAgICAgICAgICAgIGRlbGV0ZSByZXFPcHRzLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9iKGpvYklkLCB7XG4gICAgICAgICAgICBsb2NhdGlvbjogcmVxT3B0cy5qb2JSZWZlcmVuY2UubG9jYXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmk6ICcvam9icycsXG4gICAgICAgICAgICBqc29uOiByZXFPcHRzLFxuICAgICAgICB9LCBhc3luYyAoZXJyLCByZXNwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBBTFJFQURZX0VYSVNUU19DT0RFID0gNDA5O1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gQUxSRUFEWV9FWElTVFNfQ09ERSAmJlxuICAgICAgICAgICAgICAgICAgICAhSk9CX0lEX1BST1ZJREVEICYmXG4gICAgICAgICAgICAgICAgICAgICFEUllfUlVOKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IGluc2VydCBhdHRlbXB0IGZsYWtlZCwgYnV0IHRoZSBBUEkgc3RpbGwgcHJvY2Vzc2VkIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGFuZCBjcmVhdGVkIHRoZSBqb2IuIEJlY2F1c2Ugb2Ygb3VyIFwiYXV0b1JldHJ5XCIgZmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgdHJpZWQgdGhlIHJlcXVlc3QgYWdhaW4sIHdoaWNoIHRyaWVkIHRvIGNyZWF0ZSBpdCBhZ2FpbixcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5uZWNlc3NhcmlseS4gV2Ugd2lsbCBnZXQgdGhlIGpvYidzIG1ldGFkYXRhIGFuZCB0cmVhdCBpdCBhcyBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBqdXN0IGNhbWUgYmFjayBmcm9tIHRoZSBjcmVhdGUgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgW3Jlc3BdID0gYXdhaXQgam9iLmdldE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBjb21tb25fMS51dGlsLkFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiByZXNwLnN0YXR1cy5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhdGlvbiB3aXRoIHRoZSBvbmUgdXNlZCBieSB0aGUgQVBJLlxuICAgICAgICAgICAgam9iLmxvY2F0aW9uID0gcmVzcC5qb2JSZWZlcmVuY2UubG9jYXRpb247XG4gICAgICAgICAgICBqb2IubWV0YWRhdGEgPSByZXNwO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBqb2IsIHJlc3ApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIGEgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgZGF0YXNldC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIERhdGFzZXQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvamVjdElkXSBUaGUgR0NQIHByb2plY3QgSUQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2F0aW9uXSBUaGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgZGF0YXNldC5cbiAgICAgKiAgICAgIFJlcXVpcmVkIGV4Y2VwdCBmb3IgVVMgYW5kIEVVLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ2hpZ2hlcl9lZHVjYXRpb24nKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkYXRhc2V0KGlkLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGRhdGFzZXQgSUQgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBleHRlbmQoeyBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbiB9LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGRhdGFzZXRfMS5EYXRhc2V0KHRoaXMsIGlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0RGF0YXNldHMob3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zT3JDYWxsYmFjayA6IGNiO1xuICAgICAgICBjb25zdCByZXFPcHRzID0ge1xuICAgICAgICAgICAgdXJpOiAnL2RhdGFzZXRzJyxcbiAgICAgICAgICAgIHFzOiBvcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHJlcU9wdHMucHJvamVjdElkID0gb3B0aW9ucy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0KHJlcU9wdHMsIChlcnIsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlc3AubmV4dFBhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIG5leHRRdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRva2VuOiByZXNwLm5leHRQYWdlVG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QgZGF0YXNldHMgPSAocmVzcC5kYXRhc2V0cyB8fCBbXSkubWFwKChkYXRhc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHNPcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogZGF0YXNldC5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBkc09wdHMucHJvamVjdElkID0gb3B0aW9ucy5wcm9qZWN0SWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRzID0gdGhpcy5kYXRhc2V0KGRhdGFzZXQuZGF0YXNldFJlZmVyZW5jZS5kYXRhc2V0SWQsIGRzT3B0cyk7XG4gICAgICAgICAgICAgICAgZHMubWV0YWRhdGEgPSBkYXRhc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBkcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YXNldHMsIG5leHRRdWVyeSwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRKb2JzKG9wdGlvbnNPckNhbGxiYWNrLCBjYikge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnb2JqZWN0JyA/IG9wdGlvbnNPckNhbGxiYWNrIDoge307XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc09yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHVyaTogJy9qb2JzJyxcbiAgICAgICAgICAgIHFzOiBvcHRpb25zLFxuICAgICAgICAgICAgdXNlUXVlcnlzdHJpbmc6IHRydWUsXG4gICAgICAgIH0sIChlcnIsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlc3AubmV4dFBhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIG5leHRRdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRva2VuOiByZXNwLm5leHRQYWdlVG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqb2JzID0gKHJlc3Auam9icyB8fCBbXSkubWFwKChqb2JPYmplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYihqb2JPYmplY3Quam9iUmVmZXJlbmNlLmpvYklkLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBqb2JPYmplY3Quam9iUmVmZXJlbmNlLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGpvYi5tZXRhZGF0YSA9IGpvYk9iamVjdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gam9iO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBqb2JzLCBuZXh0UXVlcnksIHJlc3ApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgam9iLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2F0aW9uXSBUaGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgam9iLlxuICAgICAqICAgICAgUmVxdWlyZWQgZXhjZXB0IGZvciBVUyBhbmQgRVUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IG15RXhpc3RpbmdKb2IgPSBiaWdxdWVyeS5qb2IoJ2pvYi1pZCcpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGpvYihpZCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7IGxvY2F0aW9uOiB0aGlzLmxvY2F0aW9uIH0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgam9iXzEuSm9iKHRoaXMsIGlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcXVlcnkocXVlcnksIG9wdGlvbnNPckNhbGxiYWNrLCBjYikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBvcHRpb25zT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBxdWVyeU9wdHMgPSB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB3cmFwSW50ZWdlcnM6IHF1ZXJ5LndyYXBJbnRlZ2VycyxcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHF1ZXJ5LnBhcnNlSlNPTixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc09yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgdGhpcy50cmFjZV8oJ1txdWVyeV0nLCBxdWVyeSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVxID0gdGhpcy5idWlsZFF1ZXJ5UmVxdWVzdF8ocXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYWNlXygnW3F1ZXJ5XSBxdWVyeVJlcScsIHF1ZXJ5UmVxKTtcbiAgICAgICAgaWYgKCFxdWVyeVJlcSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVRdWVyeUpvYihxdWVyeSwgKGVyciwgam9iLCByZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnICYmIHF1ZXJ5LmRyeVJ1bikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBbXSwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIEpvYiBpcyBpbXBvcnRhbnQgZm9yIHRoZSBgcXVlcnlBc1N0cmVhbV9gIG1ldGhvZCwgc28gYSBuZXcgcXVlcnlcbiAgICAgICAgICAgICAgICAvLyBpc24ndCBjcmVhdGVkIGVhY2ggdGltZSByZXN1bHRzIGFyZSBwb2xsZWQgZm9yLlxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBleHRlbmQoeyBqb2IgfSwgcXVlcnlPcHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBqb2IuZ2V0UXVlcnlSZXN1bHRzKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuSm9ic1F1ZXJ5KHF1ZXJ5UmVxLCAoZXJyLCBqb2IsIHJlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFjZV8oJ1tydW5Kb2JzUXVlcnkgY2FsbGJhY2tdOiAnLCBxdWVyeSwgZXJyLCBqb2IsIHJlcyk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsLCBqb2IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSBleHRlbmQoeyBqb2IgfSwgcXVlcnlPcHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmpvYkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzLnNjaGVtYSAmJiByZXMucm93cykge1xuICAgICAgICAgICAgICAgICAgICByb3dzID0gQmlnUXVlcnkubWVyZ2VTY2hlbWFXaXRoUm93c18ocmVzLnNjaGVtYSwgcmVzLnJvd3MsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBJbnRlZ2Vyczogb3B0aW9ucy53cmFwSW50ZWdlcnMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IG9wdGlvbnMucGFyc2VKU09OLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcy5yb3dzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlXygnW3J1bkpvYnNRdWVyeV0gam9iIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5fY2FjaGVkUm93cyA9IHJvd3M7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5fY2FjaGVkUmVzcG9uc2UgPSByZXM7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5wYWdlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZV8oJ1tydW5Kb2JzUXVlcnldIGhhcyBtb3JlIHBhZ2VzJyk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnZVRva2VuID0gcmVzLnBhZ2VUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfKCdbcnVuSm9ic1F1ZXJ5XSBubyBtb3JlIHBhZ2VzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpvYi5nZXRRdWVyeVJlc3VsdHMob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRpbWVvdXQgb3ZlcnJpZGUgd2FzIHByb3ZpZGVkLCByZXR1cm4gZXJyb3IuXG4gICAgICAgICAgICBpZiAocXVlcnlSZXEudGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBUaGUgcXVlcnkgZGlkIG5vdCBjb21wbGV0ZSBiZWZvcmUgJHtxdWVyeVJlcS50aW1lb3V0TXN9bXNgKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIGpvYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMudGltZW91dE1zO1xuICAgICAgICAgICAgdGhpcy50cmFjZV8oJ1tydW5Kb2JzUXVlcnldIGpvYiBub3QgY29tcGxldGUnKTtcbiAgICAgICAgICAgIGpvYi5nZXRRdWVyeVJlc3VsdHMob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIFF1ZXJ5IGNhbiBydW4gdXNpbmcgdGhlIGBqb2JzLnF1ZXJ5YCBlbmRwb2ludC5cbiAgICAgKiBSZXR1cm5zIGEgYmlncXVlcnkuSVF1ZXJ5UmVxdWVzdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbGwgYGpvYnMucXVlcnlgLlxuICAgICAqIFJldHVybiB1bmRlZmluZWQgaWYgaXMgbm90IHBvc3NpYmxlIHRvIGNvbnZlcnQgdG8gYSBiaWdxdWVyeS5JUXVlcnlSZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IHN0cmluZyB8IFF1ZXJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMgUXVlcnlPcHRpb25zXG4gICAgICogQHJldHVybnMgYmlncXVlcnkuSVF1ZXJ5UmVxdWVzdCB8IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGJ1aWxkUXVlcnlSZXF1ZXN0XyhxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuRkFTVF9RVUVSWV9QQVRIID09PSAnRElTQUJMRUQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5T2JqID0gdHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBxdWVyeTtcbiAgICAgICAgdGhpcy50cmFjZV8oJ1tidWlsZFF1ZXJ5UmVxdWVzdF0nLCBxdWVyeSwgb3B0aW9ucywgcXVlcnlPYmopO1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGVueWxpc3Qgb2Ygc2V0dGluZ3Mgd2hpY2ggcHJldmVudCB1cyBmcm9tIGNvbXBvc2luZyBhbiBlcXVpdmFsZW50XG4gICAgICAgIC8vIGJxLlF1ZXJ5UmVxdWVzdCBkdWUgdG8gZGlmZmVyZW5jZXMgYmV0d2VlbiBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgLy8gYnkgam9icy5pbnNlcnQgdnMgam9icy5xdWVyeS5cbiAgICAgICAgaWYgKCEhcXVlcnlPYmouZGVzdGluYXRpb24gfHxcbiAgICAgICAgICAgICEhcXVlcnlPYmoudGFibGVEZWZpbml0aW9ucyB8fFxuICAgICAgICAgICAgISFxdWVyeU9iai5jcmVhdGVEaXNwb3NpdGlvbiB8fFxuICAgICAgICAgICAgISFxdWVyeU9iai53cml0ZURpc3Bvc2l0aW9uIHx8XG4gICAgICAgICAgICAoISFxdWVyeU9iai5wcmlvcml0eSAmJiBxdWVyeU9iai5wcmlvcml0eSAhPT0gJ0lOVEVSQUNUSVZFJykgfHxcbiAgICAgICAgICAgIHF1ZXJ5T2JqLnVzZUxlZ2FjeVNxbCB8fFxuICAgICAgICAgICAgISFxdWVyeU9iai5tYXhpbXVtQmlsbGluZ1RpZXIgfHxcbiAgICAgICAgICAgICEhcXVlcnlPYmoudGltZVBhcnRpdGlvbmluZyB8fFxuICAgICAgICAgICAgISFxdWVyeU9iai5yYW5nZVBhcnRpdGlvbmluZyB8fFxuICAgICAgICAgICAgISFxdWVyeU9iai5jbHVzdGVyaW5nIHx8XG4gICAgICAgICAgICAhIXF1ZXJ5T2JqLmRlc3RpbmF0aW9uRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24gfHxcbiAgICAgICAgICAgICEhcXVlcnlPYmouc2NoZW1hVXBkYXRlT3B0aW9ucyB8fFxuICAgICAgICAgICAgISFxdWVyeU9iai5qb2JUaW1lb3V0TXMgfHxcbiAgICAgICAgICAgIC8vIFVzZXIgaGFzIGRlZmluZWQgdGhlIGpvYklEIGdlbmVyYXRpb24gYmVoYXZpb3JcbiAgICAgICAgICAgICEhcXVlcnlPYmouam9iSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5T2JqLmRyeVJ1bikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5qb2IpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICAgICAgdXNlUXVlcnlDYWNoZTogcXVlcnlPYmoudXNlUXVlcnlDYWNoZSxcbiAgICAgICAgICAgIGxhYmVsczogcXVlcnlPYmoubGFiZWxzLFxuICAgICAgICAgICAgZGVmYXVsdERhdGFzZXQ6IHF1ZXJ5T2JqLmRlZmF1bHREYXRhc2V0LFxuICAgICAgICAgICAgY3JlYXRlU2Vzc2lvbjogcXVlcnlPYmouY3JlYXRlU2Vzc2lvbixcbiAgICAgICAgICAgIG1heGltdW1CeXRlc0JpbGxlZDogcXVlcnlPYmoubWF4aW11bUJ5dGVzQmlsbGVkLFxuICAgICAgICAgICAgdGltZW91dE1zOiBvcHRpb25zLnRpbWVvdXRNcyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBxdWVyeU9iai5sb2NhdGlvbiB8fCBvcHRpb25zLmxvY2F0aW9uLFxuICAgICAgICAgICAgZm9ybWF0T3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHVzZUludDY0VGltZXN0YW1wOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heFJlc3VsdHM6IHF1ZXJ5T2JqLm1heFJlc3VsdHMgfHwgb3B0aW9ucy5tYXhSZXN1bHRzLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5T2JqLnF1ZXJ5LFxuICAgICAgICAgICAgdXNlTGVnYWN5U3FsOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDogdXVpZC52NCgpLFxuICAgICAgICAgICAgam9iQ3JlYXRpb25Nb2RlOiAnSk9CX0NSRUFUSU9OX09QVElPTkFMJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVRdWVyeVByZXZpZXcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXEuam9iQ3JlYXRpb25Nb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGFyYW1ldGVyTW9kZSwgcGFyYW1zIH0gPSB0aGlzLmJ1aWxkUXVlcnlQYXJhbXNfKHF1ZXJ5T2JqLnBhcmFtcywgcXVlcnlPYmoudHlwZXMpO1xuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXEucXVlcnlQYXJhbWV0ZXJzID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJNb2RlKSB7XG4gICAgICAgICAgICByZXEucGFyYW1ldGVyTW9kZSA9IHBhcmFtZXRlck1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgcnVuSm9ic1F1ZXJ5KHJlcSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy50cmFjZV8oJ1tydW5Kb2JzUXVlcnldJywgcmVxLCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVyaTogJy9xdWVyaWVzJyxcbiAgICAgICAgICAgIGpzb246IHJlcSxcbiAgICAgICAgfSwgYXN5bmMgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlXygnam9icy5xdWVyeSByZXM6JywgcmVzLCBlcnIpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgam9iID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXMuam9iUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9iUmVmID0gcmVzLmpvYlJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICBqb2IgPSB0aGlzLmpvYihqb2JSZWYuam9iSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGpvYlJlZi5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5xdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgam9iID0gdGhpcy5qb2IocmVzLnF1ZXJ5SWQpOyAvLyBzdGF0ZWxlc3MgcXVlcnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGpvYiwgcmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGJ5IGBjcmVhdGVRdWVyeVN0cmVhbSgpYC4gSXQgaXMgcmVxdWlyZWQgdG9cbiAgICAgKiBwcm9wZXJseSBzZXQgdGhlIGBhdXRvUGFnaW5hdGVgIG9wdGlvbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcXVlcnlBc1N0cmVhbV8ocXVlcnksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChxdWVyeS5qb2IpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmpvYi5nZXRRdWVyeVJlc3VsdHMocXVlcnksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxvY2F0aW9uLCBtYXhSZXN1bHRzLCBwYWdlVG9rZW4sIHdyYXBJbnRlZ2VycywgcGFyc2VKU09OIH0gPSBxdWVyeTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgbWF4UmVzdWx0cyxcbiAgICAgICAgICAgIHBhZ2VUb2tlbixcbiAgICAgICAgICAgIHdyYXBJbnRlZ2VycyxcbiAgICAgICAgICAgIHBhcnNlSlNPTixcbiAgICAgICAgICAgIGF1dG9QYWdpbmF0ZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBxdWVyeS5sb2NhdGlvbjtcbiAgICAgICAgZGVsZXRlIHF1ZXJ5Lm1heFJlc3VsdHM7XG4gICAgICAgIGRlbGV0ZSBxdWVyeS5wYWdlVG9rZW47XG4gICAgICAgIGRlbGV0ZSBxdWVyeS53cmFwSW50ZWdlcnM7XG4gICAgICAgIGRlbGV0ZSBxdWVyeS5wYXJzZUpTT047XG4gICAgICAgIHRoaXMucXVlcnkocXVlcnksIG9wdHMsIGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnRzLkJpZ1F1ZXJ5ID0gQmlnUXVlcnk7XG5CaWdRdWVyeS5zZXRMb2dGdW5jdGlvbiA9IGxvZ2dlcl8xLnNldExvZ0Z1bmN0aW9uO1xuLyohIERldmVsb3BlciBEb2N1bWVudGF0aW9uXG4gKlxuICogVGhlc2UgbWV0aG9kcyBjYW4gYmUgYXV0by1wYWdpbmF0ZWQuXG4gKi9cbnBhZ2luYXRvcl8xLnBhZ2luYXRvci5leHRlbmQoQmlnUXVlcnksIFsnZ2V0RGF0YXNldHMnLCAnZ2V0Sm9icyddKTtcbi8qISBEZXZlbG9wZXIgRG9jdW1lbnRhdGlvblxuICpcbiAqIEFsbCBhc3luYyBtZXRob2RzIChleGNlcHQgZm9yIHN0cmVhbXMpIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSBpbiB0aGUgZXZlbnRcbiAqIHRoYXQgYSBjYWxsYmFjayBpcyBvbWl0dGVkLlxuICovXG4oMCwgcHJvbWlzaWZ5XzEucHJvbWlzaWZ5QWxsKShCaWdRdWVyeSwge1xuICAgIGV4Y2x1ZGU6IFtcbiAgICAgICAgJ2RhdGFzZXQnLFxuICAgICAgICAnZGF0ZScsXG4gICAgICAgICdkYXRldGltZScsXG4gICAgICAgICdnZW9ncmFwaHknLFxuICAgICAgICAnaW50JyxcbiAgICAgICAgJ2pvYicsXG4gICAgICAgICd0aW1lJyxcbiAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICdyYW5nZScsXG4gICAgXSxcbn0pO1xuZnVuY3Rpb24gY29udmVydFNjaGVtYUZpZWxkVmFsdWUoc2NoZW1hRmllbGQsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzLm51bGwodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3dpdGNoIChzY2hlbWFGaWVsZC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0JPT0xFQU4nOlxuICAgICAgICBjYXNlICdCT09MJzoge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdCWVRFUyc6IHtcbiAgICAgICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0ZMT0FUJzpcbiAgICAgICAgY2FzZSAnRkxPQVQ2NCc6IHtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lOVEVHRVInOlxuICAgICAgICBjYXNlICdJTlQ2NCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgd3JhcEludGVnZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgdmFsdWUgPSB3cmFwSW50ZWdlcnNcbiAgICAgICAgICAgICAgICA/IHR5cGVvZiB3cmFwSW50ZWdlcnMgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID8gQmlnUXVlcnkuaW50KHsgaW50ZWdlclZhbHVlOiB2YWx1ZSwgc2NoZW1hRmllbGROYW1lOiBzY2hlbWFGaWVsZC5uYW1lIH0sIHdyYXBJbnRlZ2VycykudmFsdWVPZigpXG4gICAgICAgICAgICAgICAgICAgIDogQmlnUXVlcnkuaW50KHZhbHVlKVxuICAgICAgICAgICAgICAgIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ05VTUVSSUMnOiB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBCaWcodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQklHTlVNRVJJQyc6IHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEJpZyh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSRUNPUkQnOiB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJpZ1F1ZXJ5Lm1lcmdlU2NoZW1hV2l0aFJvd3NfKHNjaGVtYUZpZWxkLCB2YWx1ZSwgb3B0aW9ucykucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdEQVRFJzoge1xuICAgICAgICAgICAgdmFsdWUgPSBCaWdRdWVyeS5kYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0RBVEVUSU1FJzoge1xuICAgICAgICAgICAgdmFsdWUgPSBCaWdRdWVyeS5kYXRldGltZSh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdUSU1FJzoge1xuICAgICAgICAgICAgdmFsdWUgPSBCaWdRdWVyeS50aW1lKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1RJTUVTVEFNUCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHBkID0gbmV3IHByZWNpc2VfZGF0ZV8xLlByZWNpc2VEYXRlKCk7XG4gICAgICAgICAgICBwZC5zZXRGdWxsVGltZShwcmVjaXNlX2RhdGVfMS5QcmVjaXNlRGF0ZS5wYXJzZUZ1bGwoQmlnSW50KHZhbHVlKSAqIEJpZ0ludCgxMDAwKSkpO1xuICAgICAgICAgICAgdmFsdWUgPSBCaWdRdWVyeS50aW1lc3RhbXAocGQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnR0VPR1JBUEhZJzoge1xuICAgICAgICAgICAgdmFsdWUgPSBCaWdRdWVyeS5nZW9ncmFwaHkodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSlNPTic6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFyc2VKU09OIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUpTT04gPyBKU09OLnBhcnNlKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnUkFOR0UnOiB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJpZ1F1ZXJ5UmFuZ2UuZnJvbVNjaGVtYVZhbHVlXyh2YWx1ZSwgc2NoZW1hRmllbGQucmFuZ2VFbGVtZW50VHlwZS50eXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBSYW5nZSBjbGFzcyBmb3IgQmlnUXVlcnkuXG4gKiBBIHJhbmdlIHJlcHJlc2VudHMgY29udGlndW91cyByYW5nZSBiZXR3ZWVuIHR3byBkYXRlcywgZGF0ZXRpbWVzLCBvciB0aW1lc3RhbXBzLlxuICogVGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZCBmb3IgdGhlIHJhbmdlIGFyZSBvcHRpb25hbC5cbiAqIFRoZSBsb3dlciBib3VuZCBpcyBpbmNsdXNpdmUgYW5kIHRoZSB1cHBlciBib3VuZCBpcyBleGNsdXNpdmUuXG4gKiBTZWUgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvcmVmZXJlbmNlL3N0YW5kYXJkLXNxbC9sZXhpY2FsI3JhbmdlX2xpdGVyYWxzXG4gKi9cbmNsYXNzIEJpZ1F1ZXJ5UmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBlbGVtZW50VHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSQU5HRS4gRWxlbWVudCB0eXBlIHJlcXVpcmVkIHdoZW4gdXNpbmcgUkFOR0UgQVBJIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IEJpZ1F1ZXJ5UmFuZ2UuZnJvbVN0cmluZ1ZhbHVlXyh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5jb252ZXJ0RWxlbWVudF8oc3RhcnQsIGVsZW1lbnRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gdGhpcy5jb252ZXJ0RWxlbWVudF8oZW5kLCBlbGVtZW50VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgIT09IHR5cGVvZiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3VwcGVyIGFuZCBsb3dlciBib3VuZCBvbiBhIFJBTkdFIHNob3VsZCBiZSBvZiB0aGUgc2FtZSB0eXBlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IHtcbiAgICAgICAgICAgICAgICBCaWdRdWVyeURhdGU6ICdEQVRFJyxcbiAgICAgICAgICAgICAgICBCaWdRdWVyeURhdGV0aW1lOiAnREFURVRJTUUnLFxuICAgICAgICAgICAgICAgIEJpZ1F1ZXJ5VGltZXN0YW1wOiAnVElNRVNUQU1QJyxcbiAgICAgICAgICAgIH1bKHN0YXJ0IHx8IGVuZCB8fCBPYmplY3QpLmNvbnN0cnVjdG9yLm5hbWVdIHx8IGVsZW1lbnRUeXBlO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuY29udmVydEVsZW1lbnRfKHN0YXJ0LCBpbmZlcnJlZFR5cGUpO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSB0aGlzLmNvbnZlcnRFbGVtZW50XyhlbmQsIGluZmVycmVkVHlwZSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID0gaW5mZXJyZWRUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogR2V0IFJhbmdlIHN0cmluZyByZXByZXNlbnRhdGlvbiB1c2VkIGJ5IHRoZSBCaWdRdWVyeSBBUEkuXG4gICAgICovXG4gICAgZ2V0IGFwaVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhcnQgPyB0aGlzLnN0YXJ0LnZhbHVlIDogJ1VOQk9VTkRFRCd9LCAke3RoaXMuZW5kID8gdGhpcy5lbmQudmFsdWUgOiAnVU5CT1VOREVEJ30pYDtcbiAgICB9XG4gICAgLypcbiAgICAgKiBHZXQgUmFuZ2UgbGl0ZXJhbCByZXByZXNlbnRhdGlvbiBhY2NvcmRpbmdseSB0b1xuICAgICAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9zdGFuZGFyZC1zcWwvbGV4aWNhbCNyYW5nZV9saXRlcmFsc1xuICAgICAqL1xuICAgIGdldCBsaXRlcmFsVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBgUkFOR0U8JHt0aGlzLmVsZW1lbnRUeXBlfT4gJHt0aGlzLmFwaVZhbHVlfWA7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ID8gdGhpcy5zdGFydC52YWx1ZSA6ICdVTkJPVU5ERUQnLFxuICAgICAgICAgICAgZW5kOiB0aGlzLmVuZCA/IHRoaXMuZW5kLnZhbHVlIDogJ1VOQk9VTkRFRCcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nVmFsdWVfKHZhbHVlKSB7XG4gICAgICAgIGxldCBjbGVhbmVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGNsZWFuZWRWYWx1ZS5zdGFydHNXaXRoKCdbJykgfHwgY2xlYW5lZFZhbHVlLnN0YXJ0c1dpdGgoJygnKSkge1xuICAgICAgICAgICAgY2xlYW5lZFZhbHVlID0gY2xlYW5lZFZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xlYW5lZFZhbHVlLmVuZHNXaXRoKCcpJykgfHwgY2xlYW5lZFZhbHVlLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgIGNsZWFuZWRWYWx1ZSA9IGNsZWFuZWRWYWx1ZS5zdWJzdHJpbmcoMCwgY2xlYW5lZFZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gY2xlYW5lZFZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSQU5HRS4gU2VlIFJBTkdFIGxpdGVyYWwgZm9ybWF0IGRvY3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcGFydHMubWFwKChzKSA9PiBzLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2NoZW1hVmFsdWVfKHZhbHVlLCBlbGVtZW50VHlwZSkge1xuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBCaWdRdWVyeVJhbmdlLmZyb21TdHJpbmdWYWx1ZV8odmFsdWUpO1xuICAgICAgICBjb25zdCBjb252ZXJ0UmFuZ2VTY2hlbWFWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnVU5CT1VOREVEJyB8fCB2YWx1ZSA9PT0gJ05VTEwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFNjaGVtYUZpZWxkVmFsdWUoeyB0eXBlOiBlbGVtZW50VHlwZSB9LCB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHdyYXBJbnRlZ2VyczogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJpZ1F1ZXJ5LnJhbmdlKHtcbiAgICAgICAgICAgIHN0YXJ0OiBjb252ZXJ0UmFuZ2VTY2hlbWFWYWx1ZShzdGFydCksXG4gICAgICAgICAgICBlbmQ6IGNvbnZlcnRSYW5nZVNjaGVtYVZhbHVlKGVuZCksXG4gICAgICAgIH0sIGVsZW1lbnRUeXBlKTtcbiAgICB9XG4gICAgY29udmVydEVsZW1lbnRfKHZhbHVlLCBlbGVtZW50VHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnVU5CT1VOREVEJyB8fCB2YWx1ZSA9PT0gJ05VTEwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdEQVRFJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdRdWVyeURhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RBVEVUSU1FJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdRdWVyeURhdGV0aW1lKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlICdUSU1FU1RBTVAnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ1F1ZXJ5VGltZXN0YW1wKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQmlnUXVlcnlSYW5nZSA9IEJpZ1F1ZXJ5UmFuZ2U7XG4vKipcbiAqIERhdGUgY2xhc3MgZm9yIEJpZ1F1ZXJ5LlxuICovXG5jbGFzcyBCaWdRdWVyeURhdGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJpZ1F1ZXJ5LmRhdGV0aW1lKHZhbHVlKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5CaWdRdWVyeURhdGUgPSBCaWdRdWVyeURhdGU7XG4vKipcbiAqIEdlb2dyYXBoeSBjbGFzcyBmb3IgQmlnUXVlcnkuXG4gKi9cbmNsYXNzIEdlb2dyYXBoeSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VvZ3JhcGh5ID0gR2VvZ3JhcGh5O1xuLyoqXG4gKiBUaW1lc3RhbXAgY2xhc3MgZm9yIEJpZ1F1ZXJ5LlxuICpcbiAqIFRoZSByZWNvbW1lbmRlZCBpbnB1dCBoZXJlIGlzIGEgYERhdGVgIG9yIGBQcmVjaXNlRGF0ZWAgY2xhc3MuXG4gKiBJZiBwYXNzaW5nIGFzIGEgYHN0cmluZ2AsIGl0IHNob3VsZCBiZSBUaW1lc3RhbXAgbGl0ZXJhbHM6IGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9zdGFuZGFyZC1zcWwvbGV4aWNhbCN0aW1lc3RhbXBfbGl0ZXJhbHMuXG4gKiBXaGVuIHBhc3NpbmcgYSBgbnVtYmVyYCBpbnB1dCwgaXQgc2hvdWxkIGJlIGVwb2NoIHNlY29uZHMgaW4gZmxvYXQgcmVwcmVzZW50YXRpb24uXG4gKlxuICovXG5jbGFzcyBCaWdRdWVyeVRpbWVzdGFtcCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgbGV0IHBkO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBwcmVjaXNlX2RhdGVfMS5QcmVjaXNlRGF0ZSkge1xuICAgICAgICAgICAgcGQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHBkID0gbmV3IHByZWNpc2VfZGF0ZV8xLlByZWNpc2VEYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGR7NH0tXFxkezEsMn0tXFxkezEsMn0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcGQgPSBuZXcgcHJlY2lzZV9kYXRlXzEuUHJlY2lzZURhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXRWYWx1ZSA9IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbG9hdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBwZCA9IHRoaXMuZnJvbUZsb2F0VmFsdWVfKGZsb2F0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGQgPSBuZXcgcHJlY2lzZV9kYXRlXzEuUHJlY2lzZURhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBkID0gdGhpcy5mcm9tRmxvYXRWYWx1ZV8odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvIGtlZXAgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgb25seSBjb252ZXJ0cyB3aXRoIG1pY3Jvc2Vjb25kXG4gICAgICAgIC8vIHByZWNpc2lvbiBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChwZC5nZXRNaWNyb3NlY29uZHMoKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwZC50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBEYXRlKHBkLmdldFRpbWUoKSkudG9KU09OKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbUZsb2F0VmFsdWVfKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNlY3MgPSBNYXRoLnRydW5jKHZhbHVlKTtcbiAgICAgICAgLy8gVGltZXN0YW1wcyBpbiBCaWdRdWVyeSBoYXZlIG1pY3Jvc2Vjb25kIHByZWNpc2lvbiwgc28gd2UgbXVzdFxuICAgICAgICAvLyByZXR1cm4gYSByb3VuZCBudW1iZXIgb2YgbWljcm9zZWNvbmRzLlxuICAgICAgICBjb25zdCBtaWNyb3MgPSBNYXRoLnRydW5jKCh2YWx1ZSAtIHNlY3MpICogMWU2ICsgMC41KTtcbiAgICAgICAgY29uc3QgcGQgPSBuZXcgcHJlY2lzZV9kYXRlXzEuUHJlY2lzZURhdGUoW3NlY3MsIG1pY3JvcyAqIDEwMDBdKTtcbiAgICAgICAgcmV0dXJuIHBkO1xuICAgIH1cbn1cbmV4cG9ydHMuQmlnUXVlcnlUaW1lc3RhbXAgPSBCaWdRdWVyeVRpbWVzdGFtcDtcbi8qKlxuICogRGF0ZXRpbWUgY2xhc3MgZm9yIEJpZ1F1ZXJ5LlxuICovXG5jbGFzcyBCaWdRdWVyeURhdGV0aW1lIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbGV0IHRpbWU7XG4gICAgICAgICAgICBpZiAodmFsdWUuaG91cnMpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gQmlnUXVlcnkudGltZSh2YWx1ZSkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB5ID0gdmFsdWUueWVhcjtcbiAgICAgICAgICAgIGNvbnN0IG0gPSB2YWx1ZS5tb250aDtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB2YWx1ZS5kYXk7XG4gICAgICAgICAgICB0aW1lID0gdGltZSA/ICcgJyArIHRpbWUgOiAnJztcbiAgICAgICAgICAgIHZhbHVlID0gYCR7eX0tJHttfS0ke2R9JHt0aW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oLiopVCguKilaJC8sICckMSAkMicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLkJpZ1F1ZXJ5RGF0ZXRpbWUgPSBCaWdRdWVyeURhdGV0aW1lO1xuLyoqXG4gKiBUaW1lIGNsYXNzIGZvciBCaWdRdWVyeS5cbiAqL1xuY2xhc3MgQmlnUXVlcnlUaW1lIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgaCA9IHZhbHVlLmhvdXJzO1xuICAgICAgICAgICAgY29uc3QgbSA9IHZhbHVlLm1pbnV0ZXMgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB2YWx1ZS5zZWNvbmRzIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBmID0gaXMuZGVmaW5lZCh2YWx1ZS5mcmFjdGlvbmFsKSA/ICcuJyArIHZhbHVlLmZyYWN0aW9uYWwgOiAnJztcbiAgICAgICAgICAgIHZhbHVlID0gYCR7aH06JHttfToke3N9JHtmfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQmlnUXVlcnlUaW1lID0gQmlnUXVlcnlUaW1lO1xuLyoqXG4gKiBCdWlsZCBhIEJpZ1F1ZXJ5SW50IG9iamVjdC4gRm9yIGxvbmcgaW50ZWdlcnMsIGEgc3RyaW5nIGNhbiBiZSBwcm92aWRlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxJbnRlZ2VyVHlwZUNhc3RWYWx1ZX0gdmFsdWUgVGhlICdJTlQ2NCcgdmFsdWUuXG4gKiBAcGFyYW0ge29iamVjdH0gW3R5cGVDYXN0T3B0aW9uc10gQ29uZmlndXJhdGlvbiB0byBjb252ZXJ0XG4gKiAgICAgdmFsdWVzIG9mICdJTlQ2NCcgdHlwZSB0byBhIGN1c3RvbSB2YWx1ZS4gTXVzdCBwcm92aWRlIGFuXG4gKiAgICAgYGludGVnZXJUeXBlQ2FzdEZ1bmN0aW9uYCB0byBoYW5kbGUgY29udmVyc2lvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVDYXN0T3B0aW9ucy5pbnRlZ2VyVHlwZUNhc3RGdW5jdGlvbiBBIGN1c3RvbSB1c2VyXG4gKiAgICAgcHJvdmlkZWQgZnVuY3Rpb24gdG8gY29udmVydCB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdHlwZUNhc3RPcHRpb25zLmZpZWxkc10gU2NoZW1hIGZpZWxkXG4gKiAgICAgbmFtZXMgdG8gYmUgY29udmVydGVkIHVzaW5nIGBpbnRlZ2VyVHlwZUNhc3RGdW5jdGlvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gKiBjb25zdCBhbkludCA9IGJpZ3F1ZXJ5LmludCg3KTtcbiAqIGBgYFxuICovXG5jbGFzcyBCaWdRdWVyeUludCBleHRlbmRzIE51bWJlciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHR5cGVDYXN0T3B0aW9ucykge1xuICAgICAgICBzdXBlcih0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUuaW50ZWdlclZhbHVlIDogdmFsdWUpO1xuICAgICAgICB0aGlzLl9zY2hlbWFGaWVsZE5hbWUgPVxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlLnNjaGVtYUZpZWxkTmFtZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyB2YWx1ZS5pbnRlZ2VyVmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ0JpZ1F1ZXJ5SW50JztcbiAgICAgICAgaWYgKHR5cGVDYXN0T3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlQ2FzdE9wdGlvbnMuaW50ZWdlclR5cGVDYXN0RnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVnZXJUeXBlQ2FzdEZ1bmN0aW9uIGlzIG5vdCBhIGZ1bmN0aW9uIG9yIHdhcyBub3QgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlQ2FzdEZpZWxkcyA9IHR5cGVDYXN0T3B0aW9ucy5maWVsZHNcbiAgICAgICAgICAgICAgICA/IGFycmlmeSh0eXBlQ2FzdE9wdGlvbnMuZmllbGRzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGN1c3RvbUNhc3QgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVDYXN0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ2FzdCA9IHRoaXMuX3NjaGVtYUZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IHR5cGVDYXN0RmllbGRzLmluY2x1ZGVzKHRoaXMuX3NjaGVtYUZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VzdG9tQ2FzdCAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnR5cGVDYXN0RnVuY3Rpb24gPSB0eXBlQ2FzdE9wdGlvbnMuaW50ZWdlclR5cGVDYXN0RnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ3VzdG9tQ2FzdCA9IHRoaXMudHlwZUNhc3RGdW5jdGlvbiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgaWYgKHNob3VsZEN1c3RvbUNhc3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZUNhc3RGdW5jdGlvbih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgaW50ZWdlclR5cGVDYXN0RnVuY3Rpb24gdGhyZXcgYW4gZXJyb3I6XFxuXFxuICAtICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdRdWVyeS5kZWNvZGVJbnRlZ2VyVmFsdWVfKHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyVmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgc2NoZW1hRmllbGROYW1lOiB0aGlzLl9zY2hlbWFGaWVsZE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IHRoaXMudHlwZSwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG59XG5leHBvcnRzLkJpZ1F1ZXJ5SW50ID0gQmlnUXVlcnlJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdxdWVyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/bigquery.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/dataset.js":
/*!******************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/dataset.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Dataset = void 0;\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nconst paginator_1 = __webpack_require__(/*! @google-cloud/paginator */ \"(rsc)/./node_modules/@google-cloud/paginator/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst table_1 = __webpack_require__(/*! ./table */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/table.js\");\nconst model_1 = __webpack_require__(/*! ./model */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/model.js\");\nconst routine_1 = __webpack_require__(/*! ./routine */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/routine.js\");\n/**\n * Interact with your BigQuery dataset. Create a Dataset instance with\n * {@link BigQuery#createDataset} or {@link BigQuery#dataset}.\n *\n * @class\n * @param {BigQuery} bigQuery {@link BigQuery} instance.\n * @param {string} id The ID of the Dataset.\n * @param {object} [options] Dataset options.\n * @param {string} [options.projectId] The GCP project ID.\n * @param {string} [options.location] The geographic location of the dataset.\n *      Defaults to US.\n *\n * @example\n * ```\n * const {BigQuery} = require('@google-cloud/bigquery');\n * const bigquery = new BigQuery();\n * const dataset = bigquery.dataset('institutions');\n * ```\n */\nclass Dataset extends common_1.ServiceObject {\n    getModelsStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    getRoutinesStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    getTablesStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    constructor(bigQuery, id, options) {\n        const methods = {\n            /**\n             * @callback CreateDatasetCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Dataset} dataset The newly created dataset.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} CreateDatasetResponse\n             * @property {Dataset} 0 The newly created dataset.\n             * @property {object} 1 The full API response body.\n             */\n            /**\n             * Create a dataset.\n             *\n             * @method Dataset#create\n             * @param {CreateDatasetCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {Dataset} callback.dataset The newly created dataset.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<CreateDatasetResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('institutions');\n             * dataset.create((err, dataset, apiResponse) => {\n             *   if (!err) {\n             *     // The dataset was created successfully.\n             *   }\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * dataset.create().then((data) => {\n             *   const dataset = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            create: true,\n            /**\n             * @callback DatasetExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Indicates if the dataset exists.\n             */\n            /**\n             * @typedef {array} DatasetExistsResponse\n             * @property {boolean} 0 Indicates if the dataset exists.\n             */\n            /**\n             * Check if the dataset exists.\n             *\n             * @method Dataset#exists\n             * @param {DatasetExistsCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {boolean} callback.exists Whether the dataset exists or not.\n             * @returns {Promise<DatasetExistsResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('institutions');\n             * dataset.exists((err, exists) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * dataset.exists().then((data) => {\n             *   const exists = data[0];\n             * });\n             * ```\n             */\n            exists: true,\n            /**\n             * @callback GetDatasetCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Dataset} dataset The dataset.\n             * @param {object} apiResponse The full API response body.\n             */\n            /**\n             * @typedef {array} GetDatasetResponse\n             * @property {Dataset} 0 The dataset.\n             * @property {object} 1 The full API response body.\n             */\n            /**\n             * Get a dataset if it exists.\n             *\n             * You may optionally use this to \"get or create\" an object by providing\n             * an object with `autoCreate` set to `true`. Any extra configuration that\n             * is normally required for the `create` method must be contained within\n             * this object as well.\n             *\n             * @method Dataset#get\n             * @param {options} [options] Configuration object.\n             * @param {boolean} [options.autoCreate=false] Automatically create the\n             *     object if it does not exist.\n             * @param {GetDatasetCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {Dataset} callback.dataset The dataset.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<GetDatasetResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('institutions');\n             * dataset.get((err, dataset, apiResponse) => {\n             *   if (!err) {\n             *     // `dataset.metadata` has been populated.\n             *   }\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * dataset.get().then((data) => {\n             *   const dataset = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            get: true,\n            /**\n             * @callback GetDatasetMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The dataset metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} GetDatasetMetadataResponse\n             * @property {object} 0 The dataset metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * Get the metadata for the Dataset.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/v2/datasets/get| Datasets: get API Documentation}\n             *\n             * @method Dataset#getMetadata\n             * @param {GetDatasetMetadataCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.metadata The dataset's metadata.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<GetDatasetMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('institutions');\n             * dataset.getMetadata((err, metadata, apiResponse) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * dataset.getMetadata().then((data) => {\n             *   const metadata = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            getMetadata: true,\n            /**\n             * @callback SetDatasetMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} SetDatasetMetadataResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * Sets the metadata of the Dataset object.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/v2/datasets/patch| Datasets: patch API Documentation}\n             *\n             * @method Dataset#setMetadata\n             * @param {object} metadata Metadata to save on the Dataset.\n             * @param {SetDatasetMetadataCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<SetDatasetMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('institutions');\n             *\n             * const metadata = {\n             *   description: 'Info for every institution in the 2013 IPEDS universe'\n             * };\n             *\n             * dataset.setMetadata(metadata, (err, apiResponse) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * dataset.setMetadata(metadata).then((data) => {\n             *   const apiResponse = data[0];\n             * });\n             * ```\n             */\n            setMetadata: true,\n        };\n        super({\n            parent: bigQuery,\n            baseUrl: '/datasets',\n            id,\n            methods,\n            createMethod: (id, optionsOrCallback, cb) => {\n                let options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n                const callback = typeof optionsOrCallback === 'function'\n                    ? optionsOrCallback\n                    : cb;\n                if (this.location) {\n                    options = extend({}, options, { location: this.location });\n                }\n                if (this.projectId) {\n                    options = extend({}, options, { projectId: this.projectId });\n                }\n                return bigQuery.createDataset(id, options, callback);\n            },\n        });\n        if (options && options.location) {\n            this.location = options.location;\n        }\n        if (options === null || options === void 0 ? void 0 : options.projectId) {\n            this.projectId = options.projectId;\n        }\n        else {\n            this.projectId = bigQuery.projectId;\n        }\n        this.bigQuery = bigQuery;\n        // Catch all for read-modify-write cycle\n        // https://cloud.google.com/bigquery/docs/api-performance#read-patch-write\n        this.interceptors.push({\n            request: (reqOpts) => {\n                if (reqOpts.method === 'PATCH' && reqOpts.json.etag) {\n                    reqOpts.headers = reqOpts.headers || {};\n                    reqOpts.headers['If-Match'] = reqOpts.json.etag;\n                }\n                if (this.projectId) {\n                    // Override projectId if provided\n                    reqOpts.uri = reqOpts.uri.replace(`/projects/${this.bigQuery.projectId}/`, `/projects/${this.projectId}/`);\n                }\n                return reqOpts;\n            },\n        });\n        /**\n         * List all or some of the {@link Model} objects in your project\n         * as a readable object stream.\n         *\n         * @method Dataset#getModelsStream\n         * @param {object} [options] Configuration object. See\n         *     {@link Dataset#getModels} for a complete list of options.\n         * @return {stream}\n         *\n         * @example\n         * ```\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         * const dataset = bigquery.dataset('institutions');\n         *\n         * dataset.getModelsStream()\n         *   .on('error', console.error)\n         *   .on('data', (model) => {})\n         *   .on('end', () => {\n         *     // All models have been retrieved\n         *   });\n         *\n         * ```\n         * @example If you anticipate many results, you can end a stream early to prevent unnecessary processing and API requests.\n         * ```\n         * dataset.getModelsStream()\n         *   .on('data', function(model) {\n         *     this.end();\n         *   });\n         * ```\n         */\n        this.getModelsStream = paginator_1.paginator.streamify('getModels');\n        /**\n         * List all or some of the {@link Routine} objects in your project as a\n         * readable object stream.\n         *\n         * @method Dataset#getRoutinesStream\n         * @param {GetRoutinesOptions} [options] Configuration object.\n         * @returns {stream}\n         *\n         * @example\n         * ```\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         * const dataset = bigquery.dataset('institutions');\n         *\n         * dataset.getRoutinesStream()\n         *   .on('error', console.error)\n         *   .on('data', (routine) => {})\n         *   .on('end', () => {\n         *     // All routines have been retrieved\n         *   });\n         *\n         * ```\n         * @example If you anticipate many results, you can end a stream early to prevent unnecessary processing and API requests.\n         * ```\n         * dataset.getRoutinesStream()\n         *   .on('data', function(routine) {\n         *     this.end();\n         *   });\n         * ```\n         */\n        this.getRoutinesStream = paginator_1.paginator.streamify('getRoutines');\n        /**\n         * List all or some of the {@link Table} objects in your project\n         * as a readable object stream.\n         *\n         * @method Dataset#getTablesStream\n         * @param {object} [options] Configuration object. See\n         *     {@link Dataset#getTables} for a complete list of options.\n         * @return {stream}\n         *\n         * @example\n         * ```\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         * const dataset = bigquery.dataset('institutions');\n         *\n         * dataset.getTablesStream()\n         *   .on('error', console.error)\n         *   .on('data', (table) => {})\n         *   .on('end', () => {\n         *     // All tables have been retrieved\n         *   });\n         *\n         * //-\n         * // If you anticipate many results, you can end a stream early to prevent\n         * // unnecessary processing and API requests.\n         * //-\n         * dataset.getTablesStream()\n         *   .on('data', function(table) {\n         *     this.end();\n         *   });\n         * ```\n         */\n        this.getTablesStream = paginator_1.paginator.streamify('getTables');\n    }\n    createQueryJob(options, callback) {\n        if (typeof options === 'string') {\n            options = {\n                query: options,\n            };\n        }\n        options = extend(true, {}, options, {\n            defaultDataset: {\n                datasetId: this.id,\n            },\n            location: this.location,\n        });\n        return this.bigQuery.createQueryJob(options, callback);\n    }\n    /**\n     * Run a query scoped to your dataset as a readable object stream.\n     *\n     * See {@link BigQuery#createQueryStream} for full documentation of this\n     * method.\n     *\n     * @param {object} options See {@link BigQuery#createQueryStream} for full\n     *     documentation of this method.\n     * @returns {stream}\n     */\n    createQueryStream(options) {\n        if (typeof options === 'string') {\n            options = {\n                query: options,\n            };\n        }\n        options = extend(true, {}, options, {\n            defaultDataset: {\n                datasetId: this.id,\n            },\n            location: this.location,\n        });\n        return this.bigQuery.createQueryStream(options);\n    }\n    createRoutine(id, config, callback) {\n        const json = Object.assign({}, config, {\n            routineReference: {\n                routineId: id,\n                datasetId: this.id,\n                projectId: this.projectId,\n            },\n        });\n        this.request({\n            method: 'POST',\n            uri: '/routines',\n            json,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            const routine = this.routine(resp.routineReference.routineId);\n            routine.metadata = resp;\n            callback(null, routine, resp);\n        });\n    }\n    createTable(id, optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        const body = table_1.Table.formatMetadata_(options);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        body.tableReference = {\n            datasetId: this.id,\n            projectId: this.projectId,\n            tableId: id,\n        };\n        this.request({\n            method: 'POST',\n            uri: '/tables',\n            json: body,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            const table = this.table(resp.tableReference.tableId, {\n                location: resp.location,\n            });\n            table.metadata = resp;\n            callback(null, table, resp);\n        });\n    }\n    delete(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        const query = {\n            deleteContents: !!options.force,\n        };\n        this.request({\n            method: 'DELETE',\n            uri: '',\n            qs: query,\n        }, callback);\n    }\n    getModels(optsOrCb, cb) {\n        const options = typeof optsOrCb === 'object' ? optsOrCb : {};\n        const callback = typeof optsOrCb === 'function' ? optsOrCb : cb;\n        this.request({\n            uri: '/models',\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            let nextQuery = null;\n            if (resp.nextPageToken) {\n                nextQuery = Object.assign({}, options, {\n                    pageToken: resp.nextPageToken,\n                });\n            }\n            const models = (resp.models || []).map(modelObject => {\n                const model = this.model(modelObject.modelReference.modelId);\n                model.metadata = modelObject;\n                return model;\n            });\n            callback(null, models, nextQuery, resp);\n        });\n    }\n    getRoutines(optsOrCb, cb) {\n        const options = typeof optsOrCb === 'object' ? optsOrCb : {};\n        const callback = typeof optsOrCb === 'function' ? optsOrCb : cb;\n        this.request({\n            uri: '/routines',\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            let nextQuery = null;\n            if (resp.nextPageToken) {\n                nextQuery = Object.assign({}, options, {\n                    pageToken: resp.nextPageToken,\n                });\n            }\n            const routines = (resp.routines || []).map(metadata => {\n                const routine = this.routine(metadata.routineReference.routineId);\n                routine.metadata = metadata;\n                return routine;\n            });\n            callback(null, routines, nextQuery, resp);\n        });\n    }\n    getTables(optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        this.request({\n            uri: '/tables',\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            let nextQuery = null;\n            if (resp.nextPageToken) {\n                nextQuery = Object.assign({}, options, {\n                    pageToken: resp.nextPageToken,\n                });\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const tables = (resp.tables || []).map((tableObject) => {\n                const table = this.table(tableObject.tableReference.tableId, {\n                    location: tableObject.location,\n                });\n                table.metadata = tableObject;\n                return table;\n            });\n            callback(null, tables, nextQuery, resp);\n        });\n    }\n    /**\n     * Create a {@link Model} object.\n     *\n     * @throws {TypeError} if model ID is missing.\n     *\n     * @param {string} id The ID of the model.\n     * @return {Model}\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const dataset = bigquery.dataset('institutions');\n     *\n     * const model = dataset.model('my-model');\n     * ```\n     */\n    model(id) {\n        if (typeof id !== 'string') {\n            throw new TypeError('A model ID is required.');\n        }\n        return new model_1.Model(this, id);\n    }\n    query(options, callback) {\n        if (typeof options === 'string') {\n            options = {\n                query: options,\n            };\n        }\n        options = extend(true, {}, options, {\n            defaultDataset: {\n                datasetId: this.id,\n            },\n            location: this.location,\n        });\n        return this.bigQuery.query(options, callback);\n    }\n    /**\n     * Create a {@link Routine} object.\n     *\n     * @throws {TypeError} if routine ID is missing.\n     *\n     * @param {string} id The ID of the routine.\n     * @returns {Routine}\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const dataset = bigquery.dataset('institutions');\n     *\n     * const routine = dataset.routine('my_routine');\n     * ```\n     */\n    routine(id) {\n        if (typeof id !== 'string') {\n            throw new TypeError('A routine ID is required.');\n        }\n        return new routine_1.Routine(this, id);\n    }\n    /**\n     * Create a {@link Table} object.\n     *\n     * @throws {TypeError} if table ID is missing.\n     *\n     * @param {string} id The ID of the table.\n     * @param {object} [options] Table options.\n     * @param {string} [options.location] The geographic location of the table, by\n     *      default this value is inherited from the dataset. This can be used to\n     *      configure the location of all jobs created through a table instance.\n     * It cannot be used to set the actual location of the table. This value will\n     *      be superseded by any API responses containing location data for the\n     *      table.\n     * @return {Table}\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const dataset = bigquery.dataset('institutions');\n     *\n     * const institutions = dataset.table('institution_data');\n     * ```\n     */\n    table(id, options) {\n        if (typeof id !== 'string') {\n            throw new TypeError('A table ID is required.');\n        }\n        options = extend({\n            location: this.location,\n            projectId: this.projectId,\n        }, options);\n        return new table_1.Table(this, id, options);\n    }\n}\nexports.Dataset = Dataset;\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\npaginator_1.paginator.extend(Dataset, ['getModels', 'getRoutines', 'getTables']);\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n(0, promisify_1.promisifyAll)(Dataset, {\n    exclude: ['model', 'routine', 'table'],\n});\n//# sourceMappingURL=dataset.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvZGF0YXNldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsaUJBQWlCLG1CQUFPLENBQUMsMEZBQXNCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBeUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFXO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJLDhCQUE4QixJQUFJLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0EsV0FBVyxVQUFVLFVBQVUsZ0JBQWdCO0FBQy9DLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsMEJBQTBCLFNBQVM7QUFDbkMsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBLGVBQWUsUUFBUSxhQUFhLGtDQUFrQztBQUN0RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvZGF0YXNldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IDIwMTQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFzZXQgPSB2b2lkIDA7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCJAZ29vZ2xlLWNsb3VkL2NvbW1vblwiKTtcbmNvbnN0IHBhZ2luYXRvcl8xID0gcmVxdWlyZShcIkBnb29nbGUtY2xvdWQvcGFnaW5hdG9yXCIpO1xuY29uc3QgcHJvbWlzaWZ5XzEgPSByZXF1aXJlKFwiQGdvb2dsZS1jbG91ZC9wcm9taXNpZnlcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuY29uc3QgdGFibGVfMSA9IHJlcXVpcmUoXCIuL3RhYmxlXCIpO1xuY29uc3QgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3Qgcm91dGluZV8xID0gcmVxdWlyZShcIi4vcm91dGluZVwiKTtcbi8qKlxuICogSW50ZXJhY3Qgd2l0aCB5b3VyIEJpZ1F1ZXJ5IGRhdGFzZXQuIENyZWF0ZSBhIERhdGFzZXQgaW5zdGFuY2Ugd2l0aFxuICoge0BsaW5rIEJpZ1F1ZXJ5I2NyZWF0ZURhdGFzZXR9IG9yIHtAbGluayBCaWdRdWVyeSNkYXRhc2V0fS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7QmlnUXVlcnl9IGJpZ1F1ZXJ5IHtAbGluayBCaWdRdWVyeX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBEYXRhc2V0LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBEYXRhc2V0IG9wdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvamVjdElkXSBUaGUgR0NQIHByb2plY3QgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYXRpb25dIFRoZSBnZW9ncmFwaGljIGxvY2F0aW9uIG9mIHRoZSBkYXRhc2V0LlxuICogICAgICBEZWZhdWx0cyB0byBVUy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdpbnN0aXR1dGlvbnMnKTtcbiAqIGBgYFxuICovXG5jbGFzcyBEYXRhc2V0IGV4dGVuZHMgY29tbW9uXzEuU2VydmljZU9iamVjdCB7XG4gICAgZ2V0TW9kZWxzU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gcGxhY2Vob2xkZXIgYm9keSwgb3ZlcndyaXR0ZW4gaW4gY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBwYWdpbmF0b3JfMS5SZXNvdXJjZVN0cmVhbSh7fSwgKCkgPT4geyB9KTtcbiAgICB9XG4gICAgZ2V0Um91dGluZXNTdHJlYW0ob3B0aW9ucykge1xuICAgICAgICAvLyBwbGFjZWhvbGRlciBib2R5LCBvdmVyd3JpdHRlbiBpbiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IHBhZ2luYXRvcl8xLlJlc291cmNlU3RyZWFtKHt9LCAoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBnZXRUYWJsZXNTdHJlYW0ob3B0aW9ucykge1xuICAgICAgICAvLyBwbGFjZWhvbGRlciBib2R5LCBvdmVyd3JpdHRlbiBpbiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IHBhZ2luYXRvcl8xLlJlc291cmNlU3RyZWFtKHt9LCAoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihiaWdRdWVyeSwgaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNhbGxiYWNrIENyZWF0ZURhdGFzZXRDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RhdGFzZXR9IGRhdGFzZXQgVGhlIG5ld2x5IGNyZWF0ZWQgZGF0YXNldC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBDcmVhdGVEYXRhc2V0UmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RGF0YXNldH0gMCBUaGUgbmV3bHkgY3JlYXRlZCBkYXRhc2V0LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDEgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlIGJvZHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGEgZGF0YXNldC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIERhdGFzZXQjY3JlYXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZURhdGFzZXRDYWxsYmFja30gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9lcnJvcn0gY2FsbGJhY2suZXJyIEFuIGVycm9yIHJldHVybmVkIHdoaWxlIG1ha2luZyB0aGlzXG4gICAgICAgICAgICAgKiAgICAgcmVxdWVzdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGF0YXNldH0gY2FsbGJhY2suZGF0YXNldCBUaGUgbmV3bHkgY3JlYXRlZCBkYXRhc2V0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrLmFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENyZWF0ZURhdGFzZXRSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnaW5zdGl0dXRpb25zJyk7XG4gICAgICAgICAgICAgKiBkYXRhc2V0LmNyZWF0ZSgoZXJyLCBkYXRhc2V0LCBhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICogICBpZiAoIWVycikge1xuICAgICAgICAgICAgICogICAgIC8vIFRoZSBkYXRhc2V0IHdhcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICAgICAqICAgfVxuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiAvLyBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCwgd2UnbGwgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICAgICAgICAgICAqIC8vLVxuICAgICAgICAgICAgICogZGF0YXNldC5jcmVhdGUoKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICogICBjb25zdCBhcGlSZXNwb25zZSA9IGRhdGFbMV07XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjcmVhdGU6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBEYXRhc2V0RXhpc3RzQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBleGlzdHMgSW5kaWNhdGVzIGlmIHRoZSBkYXRhc2V0IGV4aXN0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IERhdGFzZXRFeGlzdHNSZXNwb25zZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSAwIEluZGljYXRlcyBpZiB0aGUgZGF0YXNldCBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIGRhdGFzZXQgZXhpc3RzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgRGF0YXNldCNleGlzdHNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGF0YXNldEV4aXN0c0NhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7P2Vycm9yfSBjYWxsYmFjay5lcnIgQW4gZXJyb3IgcmV0dXJuZWQgd2hpbGUgbWFraW5nIHRoaXNcbiAgICAgICAgICAgICAqICAgICByZXF1ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjYWxsYmFjay5leGlzdHMgV2hldGhlciB0aGUgZGF0YXNldCBleGlzdHMgb3Igbm90LlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGF0YXNldEV4aXN0c1Jlc3BvbnNlPn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdpbnN0aXR1dGlvbnMnKTtcbiAgICAgICAgICAgICAqIGRhdGFzZXQuZXhpc3RzKChlcnIsIGV4aXN0cykgPT4ge30pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vLVxuICAgICAgICAgICAgICogLy8gSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQsIHdlJ2xsIHJldHVybiBhIFByb21pc2UuXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIGRhdGFzZXQuZXhpc3RzKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICogICBjb25zdCBleGlzdHMgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXhpc3RzOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2FsbGJhY2sgR2V0RGF0YXNldENhbGxiYWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9FcnJvcn0gZXJyIFJlcXVlc3QgZXJyb3IsIGlmIGFueS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldCBUaGUgZGF0YXNldC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UgYm9keS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IEdldERhdGFzZXRSZXNwb25zZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtEYXRhc2V0fSAwIFRoZSBkYXRhc2V0LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDEgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlIGJvZHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGEgZGF0YXNldCBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogWW91IG1heSBvcHRpb25hbGx5IHVzZSB0aGlzIHRvIFwiZ2V0IG9yIGNyZWF0ZVwiIGFuIG9iamVjdCBieSBwcm92aWRpbmdcbiAgICAgICAgICAgICAqIGFuIG9iamVjdCB3aXRoIGBhdXRvQ3JlYXRlYCBzZXQgdG8gYHRydWVgLiBBbnkgZXh0cmEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAgICAgICAgICAgKiBpcyBub3JtYWxseSByZXF1aXJlZCBmb3IgdGhlIGBjcmVhdGVgIG1ldGhvZCBtdXN0IGJlIGNvbnRhaW5lZCB3aXRoaW5cbiAgICAgICAgICAgICAqIHRoaXMgb2JqZWN0IGFzIHdlbGwuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBEYXRhc2V0I2dldFxuICAgICAgICAgICAgICogQHBhcmFtIHtvcHRpb25zfSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9DcmVhdGU9ZmFsc2VdIEF1dG9tYXRpY2FsbHkgY3JlYXRlIHRoZVxuICAgICAgICAgICAgICogICAgIG9iamVjdCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7R2V0RGF0YXNldENhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7P2Vycm9yfSBjYWxsYmFjay5lcnIgQW4gZXJyb3IgcmV0dXJuZWQgd2hpbGUgbWFraW5nIHRoaXNcbiAgICAgICAgICAgICAqICAgICByZXF1ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtEYXRhc2V0fSBjYWxsYmFjay5kYXRhc2V0IFRoZSBkYXRhc2V0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrLmFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldERhdGFzZXRSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnaW5zdGl0dXRpb25zJyk7XG4gICAgICAgICAgICAgKiBkYXRhc2V0LmdldCgoZXJyLCBkYXRhc2V0LCBhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICogICBpZiAoIWVycikge1xuICAgICAgICAgICAgICogICAgIC8vIGBkYXRhc2V0Lm1ldGFkYXRhYCBoYXMgYmVlbiBwb3B1bGF0ZWQuXG4gICAgICAgICAgICAgKiAgIH1cbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vLVxuICAgICAgICAgICAgICogLy8gSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQsIHdlJ2xsIHJldHVybiBhIFByb21pc2UuXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIGRhdGFzZXQuZ2V0KCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICogICBjb25zdCBkYXRhc2V0ID0gZGF0YVswXTtcbiAgICAgICAgICAgICAqICAgY29uc3QgYXBpUmVzcG9uc2UgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2FsbGJhY2sgR2V0RGF0YXNldE1ldGFkYXRhQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhIFRoZSBkYXRhc2V0IG1ldGFkYXRhLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IEdldERhdGFzZXRNZXRhZGF0YVJlc3BvbnNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gMCBUaGUgZGF0YXNldCBtZXRhZGF0YS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAxIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIG1ldGFkYXRhIGZvciB0aGUgRGF0YXNldC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS92Mi9kYXRhc2V0cy9nZXR8IERhdGFzZXRzOiBnZXQgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBEYXRhc2V0I2dldE1ldGFkYXRhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0dldERhdGFzZXRNZXRhZGF0YUNhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7P2Vycm9yfSBjYWxsYmFjay5lcnIgQW4gZXJyb3IgcmV0dXJuZWQgd2hpbGUgbWFraW5nIHRoaXNcbiAgICAgICAgICAgICAqICAgICByZXF1ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrLm1ldGFkYXRhIFRoZSBkYXRhc2V0J3MgbWV0YWRhdGEuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2suYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8R2V0RGF0YXNldE1ldGFkYXRhUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ2luc3RpdHV0aW9ucycpO1xuICAgICAgICAgICAgICogZGF0YXNldC5nZXRNZXRhZGF0YSgoZXJyLCBtZXRhZGF0YSwgYXBpUmVzcG9uc2UpID0+IHt9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIC8vIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkLCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiBkYXRhc2V0LmdldE1ldGFkYXRhKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICogICBjb25zdCBtZXRhZGF0YSA9IGRhdGFbMF07XG4gICAgICAgICAgICAgKiAgIGNvbnN0IGFwaVJlc3BvbnNlID0gZGF0YVsxXTtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldE1ldGFkYXRhOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2FsbGJhY2sgU2V0RGF0YXNldE1ldGFkYXRhQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IFNldERhdGFzZXRNZXRhZGF0YVJlc3BvbnNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gMCBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0cyB0aGUgbWV0YWRhdGEgb2YgdGhlIERhdGFzZXQgb2JqZWN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvcmVmZXJlbmNlL3YyL2RhdGFzZXRzL3BhdGNofCBEYXRhc2V0czogcGF0Y2ggQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBEYXRhc2V0I3NldE1ldGFkYXRhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEgTWV0YWRhdGEgdG8gc2F2ZSBvbiB0aGUgRGF0YXNldC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7U2V0RGF0YXNldE1ldGFkYXRhQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpc1xuICAgICAgICAgICAgICogICAgIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2suYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2V0RGF0YXNldE1ldGFkYXRhUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ2luc3RpdHV0aW9ucycpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICogICBkZXNjcmlwdGlvbjogJ0luZm8gZm9yIGV2ZXJ5IGluc3RpdHV0aW9uIGluIHRoZSAyMDEzIElQRURTIHVuaXZlcnNlJ1xuICAgICAgICAgICAgICogfTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBkYXRhc2V0LnNldE1ldGFkYXRhKG1ldGFkYXRhLCAoZXJyLCBhcGlSZXNwb25zZSkgPT4ge30pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vLVxuICAgICAgICAgICAgICogLy8gSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQsIHdlJ2xsIHJldHVybiBhIFByb21pc2UuXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIGRhdGFzZXQuc2V0TWV0YWRhdGEobWV0YWRhdGEpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAqICAgY29uc3QgYXBpUmVzcG9uc2UgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0TWV0YWRhdGE6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHBhcmVudDogYmlnUXVlcnksXG4gICAgICAgICAgICBiYXNlVXJsOiAnL2RhdGFzZXRzJyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgICAgIGNyZWF0ZU1ldGhvZDogKGlkLCBvcHRpb25zT3JDYWxsYmFjaywgY2IpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBvcHRpb25zT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9uc09yQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgOiBjYjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGxvY2F0aW9uOiB0aGlzLmxvY2F0aW9uIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBwcm9qZWN0SWQ6IHRoaXMucHJvamVjdElkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmlnUXVlcnkuY3JlYXRlRGF0YXNldChpZCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBvcHRpb25zLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aGlzLnByb2plY3RJZCA9IG9wdGlvbnMucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBiaWdRdWVyeS5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaWdRdWVyeSA9IGJpZ1F1ZXJ5O1xuICAgICAgICAvLyBDYXRjaCBhbGwgZm9yIHJlYWQtbW9kaWZ5LXdyaXRlIGN5Y2xlXG4gICAgICAgIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL2FwaS1wZXJmb3JtYW5jZSNyZWFkLXBhdGNoLXdyaXRlXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzLnB1c2goe1xuICAgICAgICAgICAgcmVxdWVzdDogKHJlcU9wdHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVxT3B0cy5tZXRob2QgPT09ICdQQVRDSCcgJiYgcmVxT3B0cy5qc29uLmV0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxT3B0cy5oZWFkZXJzID0gcmVxT3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXFPcHRzLmhlYWRlcnNbJ0lmLU1hdGNoJ10gPSByZXFPcHRzLmpzb24uZXRhZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIHByb2plY3RJZCBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICByZXFPcHRzLnVyaSA9IHJlcU9wdHMudXJpLnJlcGxhY2UoYC9wcm9qZWN0cy8ke3RoaXMuYmlnUXVlcnkucHJvamVjdElkfS9gLCBgL3Byb2plY3RzLyR7dGhpcy5wcm9qZWN0SWR9L2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxT3B0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgb3Igc29tZSBvZiB0aGUge0BsaW5rIE1vZGVsfSBvYmplY3RzIGluIHlvdXIgcHJvamVjdFxuICAgICAgICAgKiBhcyBhIHJlYWRhYmxlIG9iamVjdCBzdHJlYW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgRGF0YXNldCNnZXRNb2RlbHNTdHJlYW1cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9iamVjdC4gU2VlXG4gICAgICAgICAqICAgICB7QGxpbmsgRGF0YXNldCNnZXRNb2RlbHN9IGZvciBhIGNvbXBsZXRlIGxpc3Qgb2Ygb3B0aW9ucy5cbiAgICAgICAgICogQHJldHVybiB7c3RyZWFtfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ2luc3RpdHV0aW9ucycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBkYXRhc2V0LmdldE1vZGVsc1N0cmVhbSgpXG4gICAgICAgICAqICAgLm9uKCdlcnJvcicsIGNvbnNvbGUuZXJyb3IpXG4gICAgICAgICAqICAgLm9uKCdkYXRhJywgKG1vZGVsKSA9PiB7fSlcbiAgICAgICAgICogICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICogICAgIC8vIEFsbCBtb2RlbHMgaGF2ZSBiZWVuIHJldHJpZXZlZFxuICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQGV4YW1wbGUgSWYgeW91IGFudGljaXBhdGUgbWFueSByZXN1bHRzLCB5b3UgY2FuIGVuZCBhIHN0cmVhbSBlYXJseSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHByb2Nlc3NpbmcgYW5kIEFQSSByZXF1ZXN0cy5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGRhdGFzZXQuZ2V0TW9kZWxzU3RyZWFtKClcbiAgICAgICAgICogICAub24oJ2RhdGEnLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgKiAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE1vZGVsc1N0cmVhbSA9IHBhZ2luYXRvcl8xLnBhZ2luYXRvci5zdHJlYW1pZnkoJ2dldE1vZGVscycpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgb3Igc29tZSBvZiB0aGUge0BsaW5rIFJvdXRpbmV9IG9iamVjdHMgaW4geW91ciBwcm9qZWN0IGFzIGFcbiAgICAgICAgICogcmVhZGFibGUgb2JqZWN0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBEYXRhc2V0I2dldFJvdXRpbmVzU3RyZWFtXG4gICAgICAgICAqIEBwYXJhbSB7R2V0Um91dGluZXNPcHRpb25zfSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJlYW19XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnaW5zdGl0dXRpb25zJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGRhdGFzZXQuZ2V0Um91dGluZXNTdHJlYW0oKVxuICAgICAgICAgKiAgIC5vbignZXJyb3InLCBjb25zb2xlLmVycm9yKVxuICAgICAgICAgKiAgIC5vbignZGF0YScsIChyb3V0aW5lKSA9PiB7fSlcbiAgICAgICAgICogICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICogICAgIC8vIEFsbCByb3V0aW5lcyBoYXZlIGJlZW4gcmV0cmlldmVkXG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAZXhhbXBsZSBJZiB5b3UgYW50aWNpcGF0ZSBtYW55IHJlc3VsdHMsIHlvdSBjYW4gZW5kIGEgc3RyZWFtIGVhcmx5IHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcHJvY2Vzc2luZyBhbmQgQVBJIHJlcXVlc3RzLlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogZGF0YXNldC5nZXRSb3V0aW5lc1N0cmVhbSgpXG4gICAgICAgICAqICAgLm9uKCdkYXRhJywgZnVuY3Rpb24ocm91dGluZSkge1xuICAgICAgICAgKiAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFJvdXRpbmVzU3RyZWFtID0gcGFnaW5hdG9yXzEucGFnaW5hdG9yLnN0cmVhbWlmeSgnZ2V0Um91dGluZXMnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIG9yIHNvbWUgb2YgdGhlIHtAbGluayBUYWJsZX0gb2JqZWN0cyBpbiB5b3VyIHByb2plY3RcbiAgICAgICAgICogYXMgYSByZWFkYWJsZSBvYmplY3Qgc3RyZWFtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIERhdGFzZXQjZ2V0VGFibGVzU3RyZWFtXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvYmplY3QuIFNlZVxuICAgICAgICAgKiAgICAge0BsaW5rIERhdGFzZXQjZ2V0VGFibGVzfSBmb3IgYSBjb21wbGV0ZSBsaXN0IG9mIG9wdGlvbnMuXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmVhbX1cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdpbnN0aXR1dGlvbnMnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZGF0YXNldC5nZXRUYWJsZXNTdHJlYW0oKVxuICAgICAgICAgKiAgIC5vbignZXJyb3InLCBjb25zb2xlLmVycm9yKVxuICAgICAgICAgKiAgIC5vbignZGF0YScsICh0YWJsZSkgPT4ge30pXG4gICAgICAgICAqICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAqICAgICAvLyBBbGwgdGFibGVzIGhhdmUgYmVlbiByZXRyaWV2ZWRcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8tXG4gICAgICAgICAqIC8vIElmIHlvdSBhbnRpY2lwYXRlIG1hbnkgcmVzdWx0cywgeW91IGNhbiBlbmQgYSBzdHJlYW0gZWFybHkgdG8gcHJldmVudFxuICAgICAgICAgKiAvLyB1bm5lY2Vzc2FyeSBwcm9jZXNzaW5nIGFuZCBBUEkgcmVxdWVzdHMuXG4gICAgICAgICAqIC8vLVxuICAgICAgICAgKiBkYXRhc2V0LmdldFRhYmxlc1N0cmVhbSgpXG4gICAgICAgICAqICAgLm9uKCdkYXRhJywgZnVuY3Rpb24odGFibGUpIHtcbiAgICAgICAgICogICAgIHRoaXMuZW5kKCk7XG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRUYWJsZXNTdHJlYW0gPSBwYWdpbmF0b3JfMS5wYWdpbmF0b3Iuc3RyZWFtaWZ5KCdnZXRUYWJsZXMnKTtcbiAgICB9XG4gICAgY3JlYXRlUXVlcnlKb2Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogb3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgZGVmYXVsdERhdGFzZXQ6IHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5iaWdRdWVyeS5jcmVhdGVRdWVyeUpvYihvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBhIHF1ZXJ5IHNjb3BlZCB0byB5b3VyIGRhdGFzZXQgYXMgYSByZWFkYWJsZSBvYmplY3Qgc3RyZWFtLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBCaWdRdWVyeSNjcmVhdGVRdWVyeVN0cmVhbX0gZm9yIGZ1bGwgZG9jdW1lbnRhdGlvbiBvZiB0aGlzXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgU2VlIHtAbGluayBCaWdRdWVyeSNjcmVhdGVRdWVyeVN0cmVhbX0gZm9yIGZ1bGxcbiAgICAgKiAgICAgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyZWFtfVxuICAgICAqL1xuICAgIGNyZWF0ZVF1ZXJ5U3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogb3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgZGVmYXVsdERhdGFzZXQ6IHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5iaWdRdWVyeS5jcmVhdGVRdWVyeVN0cmVhbShvcHRpb25zKTtcbiAgICB9XG4gICAgY3JlYXRlUm91dGluZShpZCwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBqc29uID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICAgICAgICByb3V0aW5lUmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgICAgcm91dGluZUlkOiBpZCxcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgcHJvamVjdElkOiB0aGlzLnByb2plY3RJZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmk6ICcvcm91dGluZXMnLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSwgKGVyciwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGluZSA9IHRoaXMucm91dGluZShyZXNwLnJvdXRpbmVSZWZlcmVuY2Uucm91dGluZUlkKTtcbiAgICAgICAgICAgIHJvdXRpbmUubWV0YWRhdGEgPSByZXNwO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcm91dGluZSwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVUYWJsZShpZCwgb3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zT3JDYWxsYmFjayA6IGNiO1xuICAgICAgICBjb25zdCBib2R5ID0gdGFibGVfMS5UYWJsZS5mb3JtYXRNZXRhZGF0YV8ob3B0aW9ucyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGJvZHkudGFibGVSZWZlcmVuY2UgPSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMucHJvamVjdElkLFxuICAgICAgICAgICAgdGFibGVJZDogaWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVyaTogJy90YWJsZXMnLFxuICAgICAgICAgICAganNvbjogYm9keSxcbiAgICAgICAgfSwgKGVyciwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSB0aGlzLnRhYmxlKHJlc3AudGFibGVSZWZlcmVuY2UudGFibGVJZCwge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiByZXNwLmxvY2F0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YWJsZS5tZXRhZGF0YSA9IHJlc3A7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0YWJsZSwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUob3B0aW9uc09yQ2FsbGJhY2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY2FsbGJhY2sgPVxuICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc09yQ2FsbGJhY2sgOiBjYWxsYmFjaztcbiAgICAgICAgY29uc3QgcXVlcnkgPSB7XG4gICAgICAgICAgICBkZWxldGVDb250ZW50czogISFvcHRpb25zLmZvcmNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIHVyaTogJycsXG4gICAgICAgICAgICBxczogcXVlcnksXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZ2V0TW9kZWxzKG9wdHNPckNiLCBjYikge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdHNPckNiID09PSAnb2JqZWN0JyA/IG9wdHNPckNiIDoge307XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIG9wdHNPckNiID09PSAnZnVuY3Rpb24nID8gb3B0c09yQ2IgOiBjYjtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHVyaTogJy9tb2RlbHMnLFxuICAgICAgICAgICAgcXM6IG9wdGlvbnMsXG4gICAgICAgIH0sIChlcnIsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlc3AubmV4dFBhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIG5leHRRdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRva2VuOiByZXNwLm5leHRQYWdlVG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSAocmVzcC5tb2RlbHMgfHwgW10pLm1hcChtb2RlbE9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsKG1vZGVsT2JqZWN0Lm1vZGVsUmVmZXJlbmNlLm1vZGVsSWQpO1xuICAgICAgICAgICAgICAgIG1vZGVsLm1ldGFkYXRhID0gbW9kZWxPYmplY3Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtb2RlbHMsIG5leHRRdWVyeSwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSb3V0aW5lcyhvcHRzT3JDYiwgY2IpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRzT3JDYiA9PT0gJ29iamVjdCcgPyBvcHRzT3JDYiA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBvcHRzT3JDYiA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHNPckNiIDogY2I7XG4gICAgICAgIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmk6ICcvcm91dGluZXMnLFxuICAgICAgICAgICAgcXM6IG9wdGlvbnMsXG4gICAgICAgIH0sIChlcnIsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlc3AubmV4dFBhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIG5leHRRdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRva2VuOiByZXNwLm5leHRQYWdlVG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0aW5lcyA9IChyZXNwLnJvdXRpbmVzIHx8IFtdKS5tYXAobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRpbmUgPSB0aGlzLnJvdXRpbmUobWV0YWRhdGEucm91dGluZVJlZmVyZW5jZS5yb3V0aW5lSWQpO1xuICAgICAgICAgICAgICAgIHJvdXRpbmUubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGluZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcm91dGluZXMsIG5leHRRdWVyeSwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUYWJsZXMob3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zT3JDYWxsYmFjayA6IGNiO1xuICAgICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJpOiAnL3RhYmxlcycsXG4gICAgICAgICAgICBxczogb3B0aW9ucyxcbiAgICAgICAgfSwgKGVyciwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCwgbnVsbCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHRRdWVyeSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzcC5uZXh0UGFnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgbmV4dFF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBwYWdlVG9rZW46IHJlc3AubmV4dFBhZ2VUb2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCB0YWJsZXMgPSAocmVzcC50YWJsZXMgfHwgW10pLm1hcCgodGFibGVPYmplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMudGFibGUodGFibGVPYmplY3QudGFibGVSZWZlcmVuY2UudGFibGVJZCwge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogdGFibGVPYmplY3QubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGFibGUubWV0YWRhdGEgPSB0YWJsZU9iamVjdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRhYmxlcywgbmV4dFF1ZXJ5LCByZXNwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBNb2RlbH0gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBtb2RlbCBJRCBpcyBtaXNzaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiB7TW9kZWx9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnaW5zdGl0dXRpb25zJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCBtb2RlbCA9IGRhdGFzZXQubW9kZWwoJ215LW1vZGVsJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbW9kZWwoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgbW9kZWwgSUQgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBtb2RlbF8xLk1vZGVsKHRoaXMsIGlkKTtcbiAgICB9XG4gICAgcXVlcnkob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogb3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgZGVmYXVsdERhdGFzZXQ6IHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5iaWdRdWVyeS5xdWVyeShvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBSb3V0aW5lfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHJvdXRpbmUgSUQgaXMgbWlzc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHJvdXRpbmUuXG4gICAgICogQHJldHVybnMge1JvdXRpbmV9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnaW5zdGl0dXRpb25zJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCByb3V0aW5lID0gZGF0YXNldC5yb3V0aW5lKCdteV9yb3V0aW5lJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcm91dGluZShpZCkge1xuICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSByb3V0aW5lIElEIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgcm91dGluZV8xLlJvdXRpbmUodGhpcywgaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgVGFibGV9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgdGFibGUgSUQgaXMgbWlzc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHRhYmxlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGFibGUgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYXRpb25dIFRoZSBnZW9ncmFwaGljIGxvY2F0aW9uIG9mIHRoZSB0YWJsZSwgYnlcbiAgICAgKiAgICAgIGRlZmF1bHQgdGhpcyB2YWx1ZSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgZGF0YXNldC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuICAgICAqICAgICAgY29uZmlndXJlIHRoZSBsb2NhdGlvbiBvZiBhbGwgam9icyBjcmVhdGVkIHRocm91Z2ggYSB0YWJsZSBpbnN0YW5jZS5cbiAgICAgKiBJdCBjYW5ub3QgYmUgdXNlZCB0byBzZXQgdGhlIGFjdHVhbCBsb2NhdGlvbiBvZiB0aGUgdGFibGUuIFRoaXMgdmFsdWUgd2lsbFxuICAgICAqICAgICAgYmUgc3VwZXJzZWRlZCBieSBhbnkgQVBJIHJlc3BvbnNlcyBjb250YWluaW5nIGxvY2F0aW9uIGRhdGEgZm9yIHRoZVxuICAgICAqICAgICAgdGFibGUuXG4gICAgICogQHJldHVybiB7VGFibGV9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnaW5zdGl0dXRpb25zJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbnN0aXR1dGlvbnMgPSBkYXRhc2V0LnRhYmxlKCdpbnN0aXR1dGlvbl9kYXRhJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGFibGUoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgdGFibGUgSUQgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7XG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5wcm9qZWN0SWQsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlXzEuVGFibGUodGhpcywgaWQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YXNldCA9IERhdGFzZXQ7XG4vKiEgRGV2ZWxvcGVyIERvY3VtZW50YXRpb25cbiAqXG4gKiBUaGVzZSBtZXRob2RzIGNhbiBiZSBhdXRvLXBhZ2luYXRlZC5cbiAqL1xucGFnaW5hdG9yXzEucGFnaW5hdG9yLmV4dGVuZChEYXRhc2V0LCBbJ2dldE1vZGVscycsICdnZXRSb3V0aW5lcycsICdnZXRUYWJsZXMnXSk7XG4vKiEgRGV2ZWxvcGVyIERvY3VtZW50YXRpb25cbiAqXG4gKiBBbGwgYXN5bmMgbWV0aG9kcyAoZXhjZXB0IGZvciBzdHJlYW1zKSB3aWxsIHJldHVybiBhIFByb21pc2UgaW4gdGhlIGV2ZW50XG4gKiB0aGF0IGEgY2FsbGJhY2sgaXMgb21pdHRlZC5cbiAqL1xuKDAsIHByb21pc2lmeV8xLnByb21pc2lmeUFsbCkoRGF0YXNldCwge1xuICAgIGV4Y2x1ZGU6IFsnbW9kZWwnLCAncm91dGluZScsICd0YWJsZSddLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhc2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/dataset.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Table = exports.RowQueue = exports.RowBatch = exports.Routine = exports.Model = exports.Job = exports.Dataset = exports.PROTOCOL_REGEX = exports.Geography = exports.common = exports.BigQueryTimestamp = exports.BigQueryTime = exports.BigQueryInt = exports.BigQueryDatetime = exports.BigQueryDate = exports.BigQuery = void 0;\nvar bigquery_1 = __webpack_require__(/*! ./bigquery */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/bigquery.js\");\nObject.defineProperty(exports, \"BigQuery\", ({ enumerable: true, get: function () { return bigquery_1.BigQuery; } }));\nObject.defineProperty(exports, \"BigQueryDate\", ({ enumerable: true, get: function () { return bigquery_1.BigQueryDate; } }));\nObject.defineProperty(exports, \"BigQueryDatetime\", ({ enumerable: true, get: function () { return bigquery_1.BigQueryDatetime; } }));\nObject.defineProperty(exports, \"BigQueryInt\", ({ enumerable: true, get: function () { return bigquery_1.BigQueryInt; } }));\nObject.defineProperty(exports, \"BigQueryTime\", ({ enumerable: true, get: function () { return bigquery_1.BigQueryTime; } }));\nObject.defineProperty(exports, \"BigQueryTimestamp\", ({ enumerable: true, get: function () { return bigquery_1.BigQueryTimestamp; } }));\nObject.defineProperty(exports, \"common\", ({ enumerable: true, get: function () { return bigquery_1.common; } }));\nObject.defineProperty(exports, \"Geography\", ({ enumerable: true, get: function () { return bigquery_1.Geography; } }));\nObject.defineProperty(exports, \"PROTOCOL_REGEX\", ({ enumerable: true, get: function () { return bigquery_1.PROTOCOL_REGEX; } }));\nvar dataset_1 = __webpack_require__(/*! ./dataset */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/dataset.js\");\nObject.defineProperty(exports, \"Dataset\", ({ enumerable: true, get: function () { return dataset_1.Dataset; } }));\nvar job_1 = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/job.js\");\nObject.defineProperty(exports, \"Job\", ({ enumerable: true, get: function () { return job_1.Job; } }));\nvar model_1 = __webpack_require__(/*! ./model */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/model.js\");\nObject.defineProperty(exports, \"Model\", ({ enumerable: true, get: function () { return model_1.Model; } }));\nvar routine_1 = __webpack_require__(/*! ./routine */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/routine.js\");\nObject.defineProperty(exports, \"Routine\", ({ enumerable: true, get: function () { return routine_1.Routine; } }));\nvar rowBatch_1 = __webpack_require__(/*! ./rowBatch */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowBatch.js\");\nObject.defineProperty(exports, \"RowBatch\", ({ enumerable: true, get: function () { return rowBatch_1.RowBatch; } }));\nvar rowQueue_1 = __webpack_require__(/*! ./rowQueue */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowQueue.js\");\nObject.defineProperty(exports, \"RowQueue\", ({ enumerable: true, get: function () { return rowQueue_1.RowQueue; } }));\nvar table_1 = __webpack_require__(/*! ./table */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/table.js\");\nObject.defineProperty(exports, \"Table\", ({ enumerable: true, get: function () { return table_1.Table; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsZ0JBQWdCO0FBQ2pVLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3JDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsb0RBQW1ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2xJLCtDQUE4QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN4SCxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgscURBQW9ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3BJLDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5Ryw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILGdCQUFnQixtQkFBTyxDQUFDLG1GQUFXO0FBQ25DLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRyxZQUFZLG1CQUFPLENBQUMsMkVBQU87QUFDM0IsdUNBQXNDLEVBQUUscUNBQXFDLHFCQUFxQixFQUFDO0FBQ25HLGNBQWMsbUJBQU8sQ0FBQywrRUFBUztBQUMvQix5Q0FBd0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDekcsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVc7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3JDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBWTtBQUNyQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsY0FBYyxtQkFBTyxDQUFDLCtFQUFTO0FBQy9CLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyIsInNvdXJjZXMiOlsiL1VzZXJzL2thaXNlaS9EZXNrdG9wL20tdHJhY2VyLWFpL25vZGVfbW9kdWxlcy9AZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5L2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhYmxlID0gZXhwb3J0cy5Sb3dRdWV1ZSA9IGV4cG9ydHMuUm93QmF0Y2ggPSBleHBvcnRzLlJvdXRpbmUgPSBleHBvcnRzLk1vZGVsID0gZXhwb3J0cy5Kb2IgPSBleHBvcnRzLkRhdGFzZXQgPSBleHBvcnRzLlBST1RPQ09MX1JFR0VYID0gZXhwb3J0cy5HZW9ncmFwaHkgPSBleHBvcnRzLmNvbW1vbiA9IGV4cG9ydHMuQmlnUXVlcnlUaW1lc3RhbXAgPSBleHBvcnRzLkJpZ1F1ZXJ5VGltZSA9IGV4cG9ydHMuQmlnUXVlcnlJbnQgPSBleHBvcnRzLkJpZ1F1ZXJ5RGF0ZXRpbWUgPSBleHBvcnRzLkJpZ1F1ZXJ5RGF0ZSA9IGV4cG9ydHMuQmlnUXVlcnkgPSB2b2lkIDA7XG52YXIgYmlncXVlcnlfMSA9IHJlcXVpcmUoXCIuL2JpZ3F1ZXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnUXVlcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ3F1ZXJ5XzEuQmlnUXVlcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaWdRdWVyeURhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ3F1ZXJ5XzEuQmlnUXVlcnlEYXRlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnUXVlcnlEYXRldGltZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlncXVlcnlfMS5CaWdRdWVyeURhdGV0aW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnUXVlcnlJbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ3F1ZXJ5XzEuQmlnUXVlcnlJbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaWdRdWVyeVRpbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ3F1ZXJ5XzEuQmlnUXVlcnlUaW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnUXVlcnlUaW1lc3RhbXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ3F1ZXJ5XzEuQmlnUXVlcnlUaW1lc3RhbXA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21tb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ3F1ZXJ5XzEuY29tbW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2VvZ3JhcGh5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdxdWVyeV8xLkdlb2dyYXBoeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBST1RPQ09MX1JFR0VYXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdxdWVyeV8xLlBST1RPQ09MX1JFR0VYOyB9IH0pO1xudmFyIGRhdGFzZXRfMSA9IHJlcXVpcmUoXCIuL2RhdGFzZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhc2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhc2V0XzEuRGF0YXNldDsgfSB9KTtcbnZhciBqb2JfMSA9IHJlcXVpcmUoXCIuL2pvYlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpvYlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gam9iXzEuSm9iOyB9IH0pO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1vZGVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbF8xLk1vZGVsOyB9IH0pO1xudmFyIHJvdXRpbmVfMSA9IHJlcXVpcmUoXCIuL3JvdXRpbmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3V0aW5lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0aW5lXzEuUm91dGluZTsgfSB9KTtcbnZhciByb3dCYXRjaF8xID0gcmVxdWlyZShcIi4vcm93QmF0Y2hcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3dCYXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm93QmF0Y2hfMS5Sb3dCYXRjaDsgfSB9KTtcbnZhciByb3dRdWV1ZV8xID0gcmVxdWlyZShcIi4vcm93UXVldWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3dRdWV1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm93UXVldWVfMS5Sb3dRdWV1ZTsgfSB9KTtcbnZhciB0YWJsZV8xID0gcmVxdWlyZShcIi4vdGFibGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFibGVfMS5UYWJsZTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/job.js":
/*!**************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/job.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Job = void 0;\n/*!\n * @module bigquery/job\n */\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nconst paginator_1 = __webpack_require__(/*! @google-cloud/paginator */ \"(rsc)/./node_modules/@google-cloud/paginator/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst bigquery_1 = __webpack_require__(/*! ./bigquery */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/bigquery.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/logger.js\");\n/**\n * @callback QueryResultsCallback\n * @param {?Error} err An error returned while making this request.\n * @param {array} rows The results of the job.\n */\n/**\n * @callback ManualQueryResultsCallback\n * @param {?Error} err An error returned while making this request.\n * @param {array} rows The results of the job.\n * @param {?object} nextQuery A pre-made configuration object for your next\n *     request. This will be `null` if no additional results are available.\n *     If the query is not yet complete, you may get empty `rows` and\n *     non-`null` `nextQuery` that you should use for your next request.\n * @param {object} apiResponse The full API response.\n */\n/**\n * Job objects are returned from various places in the BigQuery API:\n *\n * - {@link BigQuery#getJobs}\n * - {@link BigQuery#job}\n * - {@link BigQuery#query}\n * - {@link BigQuery#createJob}\n * - {@link Table#copy}\n * - {@link Table#createWriteStream}\n * - {@link Table#extract}\n * - {@link Table#load}\n *\n * They can be used to check the status of a running job or fetching the results\n * of a previously-executed one.\n *\n * @class\n * @param {BigQuery} bigQuery {@link BigQuery} instance.\n * @param {string} id The ID of the job.\n * @param {object} [options] Configuration object.\n * @param {string} [options.location] The geographic location of the job.\n *      Required except for US and EU.\n *\n * @example\n * ```\n * const {BigQuery} = require('@google-cloud/bigquery');\n * const bigquery = new BigQuery();\n *\n * const job = bigquery.job('job-id');\n *\n * //-\n * // All jobs are event emitters. The status of each job is polled\n * // continuously, starting only after you register a \"complete\" listener.\n * //-\n * job.on('complete', (metadata) => {\n *   // The job is complete.\n * });\n *\n * //-\n * // Be sure to register an error handler as well to catch any issues which\n * // impeded the job.\n * //-\n * job.on('error', (err) => {\n *   // An error occurred during the job.\n * });\n *\n * //-\n * // To force the Job object to stop polling for updates, simply remove any\n * // \"complete\" listeners you've registered.\n * //\n * // The easiest way to do this is with `removeAllListeners()`.\n * //-\n * job.removeAllListeners();\n * ```\n */\nclass Job extends common_1.Operation {\n    getQueryResultsStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    constructor(bigQuery, id, options) {\n        let location;\n        const methods = {\n            /**\n             * @callback DeleteJobCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} DeleteJobResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * Delete the job.\n             *\n             * @see [Jobs: delete API Documentation]{@link https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/delete}\n             *\n             * @method Job#delete\n             * @param {DeleteJobCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<DeleteJobResponse>}\n             *\n             * @example\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             *\n             * const job = bigquery.job(jobId);\n             * job.delete((err, apiResponse) => {\n             *   if (!err) {\n             *     // The job was deleted successfully.\n             *   }\n             * });\n             *\n             * @example If the callback is omitted a Promise will be returned\n             * const [apiResponse] = await job.delete();\n             */\n            delete: {\n                reqOpts: {\n                    method: 'DELETE',\n                    uri: '/delete',\n                    qs: {\n                        get location() {\n                            return location;\n                        },\n                    },\n                },\n            },\n            /**\n             * @callback JobExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Indicates if the job exists.\n             */\n            /**\n             * @typedef {array} JobExistsResponse\n             * @property {boolean} 0 Indicates if the job exists.\n             */\n            /**\n             * Check if the job exists.\n             *\n             * @method Job#exists\n             * @param {JobExistsCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {boolean} callback.exists Whether the job exists or not.\n             * @returns {Promise<JobExistsResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             *\n             * const job = bigquery.job('job-id');\n             *\n             * job.exists((err, exists) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * job.exists().then((data) => {\n             *   const exists = data[0];\n             * });\n             * ```\n             */\n            exists: true,\n            /**\n             * @callback GetJobCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Model} model The job.\n             * @param {object} apiResponse The full API response body.\n             */\n            /**\n             * @typedef {array} GetJobResponse\n             * @property {Model} 0 The job.\n             * @property {object} 1 The full API response body.\n             */\n            /**\n             * Get a job if it exists.\n             *\n             * @method Job#get\n             * @param {object} [options] Configuration object.\n             * @param {string} [options.location] The geographic location of the job.\n             *     Required except for US and EU.\n             * @param {GetJobCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {Job} callback.job The job.\n             * @returns {Promise<GetJobResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             *\n             * const job = bigquery.job('job-id');\n             *\n             * job.get((err, job, apiResponse) => {\n             *   if (!err) {\n             *     // `job.metadata` has been populated.\n             *   }\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * job.get().then((data) => {\n             *   const job = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            get: true,\n            /**\n             * @callback GetJobMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The job metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} GetJobMetadataResponse\n             * @property {object} 0 The job metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * Get the metadata of the job. This will mostly be useful for checking\n             * the status of a previously-run job.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/get| Jobs: get API Documentation}\n             *\n             * @method Job#getMetadata\n             * @param {GetJobMetadataCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.metadata The metadata of the job.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<GetJobMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             *\n             * const job = bigquery.job('id');\n             * job.getMetadata((err, metadata, apiResponse) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * job.getMetadata().then((data) => {\n             *   const metadata = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            getMetadata: {\n                reqOpts: {\n                    qs: {\n                        get location() {\n                            return location;\n                        },\n                    },\n                },\n            },\n        };\n        super({\n            parent: bigQuery,\n            baseUrl: '/jobs',\n            id,\n            methods,\n        });\n        Object.defineProperty(this, 'location', {\n            get() {\n                return location;\n            },\n            set(_location) {\n                location = _location;\n            },\n        });\n        this.bigQuery = bigQuery;\n        if (options && options.location) {\n            this.location = options.location;\n        }\n        if (options === null || options === void 0 ? void 0 : options.projectId) {\n            this.projectId = options.projectId;\n        }\n        /**\n         * Get the results of a job as a readable object stream.\n         *\n         * @param {object} options Configuration object. See\n         *     {@link Job#getQueryResults} for a complete list of options.\n         * @return {stream}\n         *\n         * @example\n         * ```\n         * const through2 = require('through2');\n         * const fs = require('fs');\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         *\n         * const job = bigquery.job('job-id');\n         *\n         * job.getQueryResultsStream()\n         *   .pipe(through2.obj(function (row, enc, next) {\n         *     this.push(JSON.stringify(row) + '\\n');\n         *     next();\n         *   }))\n         *   .pipe(fs.createWriteStream('./test/testdata/testfile.json'));\n         * ```\n         */\n        this.getQueryResultsStream = paginator_1.paginator.streamify('getQueryResultsAsStream_');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    trace_(msg, ...otherArgs) {\n        (0, logger_1.logger)(`[job][${this.id}]`, msg, ...otherArgs);\n    }\n    cancel(callback) {\n        let qs;\n        if (this.location) {\n            qs = { location: this.location };\n        }\n        this.request({\n            method: 'POST',\n            uri: '/cancel',\n            qs,\n        }, callback);\n    }\n    getQueryResults(optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        const qs = extend({\n            location: this.location,\n            'formatOptions.useInt64Timestamp': true,\n        }, options);\n        this.trace_('[getQueryResults]', this.id, options.pageToken, options.startIndex);\n        const wrapIntegers = qs.wrapIntegers ? qs.wrapIntegers : false;\n        delete qs.wrapIntegers;\n        const parseJSON = qs.parseJSON ? qs.parseJSON : false;\n        delete qs.parseJSON;\n        delete qs.job;\n        const timeoutOverride = typeof qs.timeoutMs === 'number' ? qs.timeoutMs : false;\n        const cachedRows = options._cachedRows;\n        const cachedResponse = options._cachedResponse;\n        delete options._cachedRows;\n        delete options._cachedResponse;\n        if (cachedRows) {\n            let nextQuery = null;\n            if (options.pageToken) {\n                nextQuery = Object.assign({}, options, {\n                    pageToken: options.pageToken,\n                });\n            }\n            cachedResponse === null || cachedResponse === void 0 ? true : delete cachedResponse.rows;\n            callback(null, cachedRows, nextQuery, cachedResponse);\n            return;\n        }\n        this.bigQuery.request({\n            uri: '/queries/' + this.id,\n            qs,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let rows = [];\n            if (resp.schema && resp.rows) {\n                rows = bigquery_1.BigQuery.mergeSchemaWithRows_(resp.schema, resp.rows, {\n                    wrapIntegers,\n                    parseJSON,\n                });\n            }\n            let nextQuery = null;\n            if (resp.jobComplete === false) {\n                // Query is still running.\n                nextQuery = Object.assign({}, options);\n                // If timeout override was provided, return error.\n                if (timeoutOverride) {\n                    const err = new Error(`The query did not complete before ${timeoutOverride}ms`);\n                    callback(err, null, nextQuery, resp);\n                    return;\n                }\n            }\n            else if (resp.pageToken) {\n                this.trace_('[getQueryResults] has more pages', resp.pageToken);\n                // More results exist.\n                nextQuery = Object.assign({}, options, {\n                    pageToken: resp.pageToken,\n                });\n                delete nextQuery.startIndex;\n            }\n            delete resp.rows;\n            callback(null, rows, nextQuery, resp);\n        });\n    }\n    /**\n     * This method will be called by `getQueryResultsStream()`. It is required to\n     * properly set the `autoPaginate` option value.\n     *\n     * @private\n     */\n    getQueryResultsAsStream_(options, callback) {\n        options = extend({ autoPaginate: false }, options);\n        this.getQueryResults(options, callback);\n    }\n    /**\n     * Poll for a status update. Execute the callback:\n     *\n     *   - callback(err): Job failed\n     *   - callback(): Job incomplete\n     *   - callback(null, metadata): Job complete\n     *\n     * @private\n     *\n     * @param {function} callback\n     */\n    poll_(callback) {\n        this.getMetadata((err, metadata) => {\n            if (!err && metadata.status && metadata.status.errorResult) {\n                err = new common_1.util.ApiError(metadata.status);\n            }\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (metadata.status.state !== 'DONE') {\n                callback(null);\n                return;\n            }\n            callback(null, metadata);\n        });\n    }\n}\nexports.Job = Job;\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\npaginator_1.paginator.extend(Job, ['getQueryResults']);\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n(0, promisify_1.promisifyAll)(Job);\n//# sourceMappingURL=job.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvam9iLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwRkFBc0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsZ0dBQXlCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMscUZBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVU7QUFDbkM7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTixNQUFNO0FBQ04sTUFBTTtBQUNOLE1BQU07QUFDTixNQUFNO0FBQ04sTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVLFVBQVUsZ0JBQWdCO0FBQy9DLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvam9iLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgMjAxNCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSm9iID0gdm9pZCAwO1xuLyohXG4gKiBAbW9kdWxlIGJpZ3F1ZXJ5L2pvYlxuICovXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCJAZ29vZ2xlLWNsb3VkL2NvbW1vblwiKTtcbmNvbnN0IHBhZ2luYXRvcl8xID0gcmVxdWlyZShcIkBnb29nbGUtY2xvdWQvcGFnaW5hdG9yXCIpO1xuY29uc3QgcHJvbWlzaWZ5XzEgPSByZXF1aXJlKFwiQGdvb2dsZS1jbG91ZC9wcm9taXNpZnlcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuY29uc3QgYmlncXVlcnlfMSA9IHJlcXVpcmUoXCIuL2JpZ3F1ZXJ5XCIpO1xuY29uc3QgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG4vKipcbiAqIEBjYWxsYmFjayBRdWVyeVJlc3VsdHNDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpcyByZXF1ZXN0LlxuICogQHBhcmFtIHthcnJheX0gcm93cyBUaGUgcmVzdWx0cyBvZiB0aGUgam9iLlxuICovXG4vKipcbiAqIEBjYWxsYmFjayBNYW51YWxRdWVyeVJlc3VsdHNDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpcyByZXF1ZXN0LlxuICogQHBhcmFtIHthcnJheX0gcm93cyBUaGUgcmVzdWx0cyBvZiB0aGUgam9iLlxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0UXVlcnkgQSBwcmUtbWFkZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgeW91ciBuZXh0XG4gKiAgICAgcmVxdWVzdC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpZiBubyBhZGRpdGlvbmFsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZS5cbiAqICAgICBJZiB0aGUgcXVlcnkgaXMgbm90IHlldCBjb21wbGV0ZSwgeW91IG1heSBnZXQgZW1wdHkgYHJvd3NgIGFuZFxuICogICAgIG5vbi1gbnVsbGAgYG5leHRRdWVyeWAgdGhhdCB5b3Ugc2hvdWxkIHVzZSBmb3IgeW91ciBuZXh0IHJlcXVlc3QuXG4gKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICovXG4vKipcbiAqIEpvYiBvYmplY3RzIGFyZSByZXR1cm5lZCBmcm9tIHZhcmlvdXMgcGxhY2VzIGluIHRoZSBCaWdRdWVyeSBBUEk6XG4gKlxuICogLSB7QGxpbmsgQmlnUXVlcnkjZ2V0Sm9ic31cbiAqIC0ge0BsaW5rIEJpZ1F1ZXJ5I2pvYn1cbiAqIC0ge0BsaW5rIEJpZ1F1ZXJ5I3F1ZXJ5fVxuICogLSB7QGxpbmsgQmlnUXVlcnkjY3JlYXRlSm9ifVxuICogLSB7QGxpbmsgVGFibGUjY29weX1cbiAqIC0ge0BsaW5rIFRhYmxlI2NyZWF0ZVdyaXRlU3RyZWFtfVxuICogLSB7QGxpbmsgVGFibGUjZXh0cmFjdH1cbiAqIC0ge0BsaW5rIFRhYmxlI2xvYWR9XG4gKlxuICogVGhleSBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIGEgcnVubmluZyBqb2Igb3IgZmV0Y2hpbmcgdGhlIHJlc3VsdHNcbiAqIG9mIGEgcHJldmlvdXNseS1leGVjdXRlZCBvbmUuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0JpZ1F1ZXJ5fSBiaWdRdWVyeSB7QGxpbmsgQmlnUXVlcnl9IGluc3RhbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgam9iLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhdGlvbl0gVGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb2YgdGhlIGpvYi5cbiAqICAgICAgUmVxdWlyZWQgZXhjZXB0IGZvciBVUyBhbmQgRVUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gKlxuICogY29uc3Qgam9iID0gYmlncXVlcnkuam9iKCdqb2ItaWQnKTtcbiAqXG4gKiAvLy1cbiAqIC8vIEFsbCBqb2JzIGFyZSBldmVudCBlbWl0dGVycy4gVGhlIHN0YXR1cyBvZiBlYWNoIGpvYiBpcyBwb2xsZWRcbiAqIC8vIGNvbnRpbnVvdXNseSwgc3RhcnRpbmcgb25seSBhZnRlciB5b3UgcmVnaXN0ZXIgYSBcImNvbXBsZXRlXCIgbGlzdGVuZXIuXG4gKiAvLy1cbiAqIGpvYi5vbignY29tcGxldGUnLCAobWV0YWRhdGEpID0+IHtcbiAqICAgLy8gVGhlIGpvYiBpcyBjb21wbGV0ZS5cbiAqIH0pO1xuICpcbiAqIC8vLVxuICogLy8gQmUgc3VyZSB0byByZWdpc3RlciBhbiBlcnJvciBoYW5kbGVyIGFzIHdlbGwgdG8gY2F0Y2ggYW55IGlzc3VlcyB3aGljaFxuICogLy8gaW1wZWRlZCB0aGUgam9iLlxuICogLy8tXG4gKiBqb2Iub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICogICAvLyBBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGpvYi5cbiAqIH0pO1xuICpcbiAqIC8vLVxuICogLy8gVG8gZm9yY2UgdGhlIEpvYiBvYmplY3QgdG8gc3RvcCBwb2xsaW5nIGZvciB1cGRhdGVzLCBzaW1wbHkgcmVtb3ZlIGFueVxuICogLy8gXCJjb21wbGV0ZVwiIGxpc3RlbmVycyB5b3UndmUgcmVnaXN0ZXJlZC5cbiAqIC8vXG4gKiAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gZG8gdGhpcyBpcyB3aXRoIGByZW1vdmVBbGxMaXN0ZW5lcnMoKWAuXG4gKiAvLy1cbiAqIGpvYi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAqIGBgYFxuICovXG5jbGFzcyBKb2IgZXh0ZW5kcyBjb21tb25fMS5PcGVyYXRpb24ge1xuICAgIGdldFF1ZXJ5UmVzdWx0c1N0cmVhbShvcHRpb25zKSB7XG4gICAgICAgIC8vIHBsYWNlaG9sZGVyIGJvZHksIG92ZXJ3cml0dGVuIGluIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgcGFnaW5hdG9yXzEuUmVzb3VyY2VTdHJlYW0oe30sICgpID0+IHsgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJpZ1F1ZXJ5LCBpZCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgbG9jYXRpb247XG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBEZWxldGVKb2JDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHthcnJheX0gRGVsZXRlSm9iUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAwIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgdGhlIGpvYi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAc2VlIFtKb2JzOiBkZWxldGUgQVBJIERvY3VtZW50YXRpb25de0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YyL2pvYnMvZGVsZXRlfVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgSm9iI2RlbGV0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtEZWxldGVKb2JDYWxsYmFja30gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9lcnJvcn0gY2FsbGJhY2suZXJyIEFuIGVycm9yIHJldHVybmVkIHdoaWxlIG1ha2luZyB0aGlzXG4gICAgICAgICAgICAgKiAgICAgcmVxdWVzdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFjay5hcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZWxldGVKb2JSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IGpvYiA9IGJpZ3F1ZXJ5LmpvYihqb2JJZCk7XG4gICAgICAgICAgICAgKiBqb2IuZGVsZXRlKChlcnIsIGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgKiAgICAgLy8gVGhlIGpvYiB3YXMgZGVsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAgICAgKiAgIH1cbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIGEgUHJvbWlzZSB3aWxsIGJlIHJldHVybmVkXG4gICAgICAgICAgICAgKiBjb25zdCBbYXBpUmVzcG9uc2VdID0gYXdhaXQgam9iLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWxldGU6IHtcbiAgICAgICAgICAgICAgICByZXFPcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgICAgIHVyaTogJy9kZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBKb2JFeGlzdHNDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4aXN0cyBJbmRpY2F0ZXMgaWYgdGhlIGpvYiBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBKb2JFeGlzdHNSZXNwb25zZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSAwIEluZGljYXRlcyBpZiB0aGUgam9iIGV4aXN0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiB0aGUgam9iIGV4aXN0cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIEpvYiNleGlzdHNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Sm9iRXhpc3RzQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpc1xuICAgICAgICAgICAgICogICAgIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbGxiYWNrLmV4aXN0cyBXaGV0aGVyIHRoZSBqb2IgZXhpc3RzIG9yIG5vdC5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEpvYkV4aXN0c1Jlc3BvbnNlPn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBjb25zdCBqb2IgPSBiaWdxdWVyeS5qb2IoJ2pvYi1pZCcpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGpvYi5leGlzdHMoKGVyciwgZXhpc3RzKSA9PiB7fSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiAvLyBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCwgd2UnbGwgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICAgICAgICAgICAqIC8vLVxuICAgICAgICAgICAgICogam9iLmV4aXN0cygpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAqICAgY29uc3QgZXhpc3RzID0gZGF0YVswXTtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNhbGxiYWNrIEdldEpvYkNhbGxiYWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9FcnJvcn0gZXJyIFJlcXVlc3QgZXJyb3IsIGlmIGFueS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsIFRoZSBqb2IuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlIGJvZHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBHZXRKb2JSZXNwb25zZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtNb2RlbH0gMCBUaGUgam9iLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDEgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlIGJvZHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGEgam9iIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIEpvYiNnZXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYXRpb25dIFRoZSBnZW9ncmFwaGljIGxvY2F0aW9uIG9mIHRoZSBqb2IuXG4gICAgICAgICAgICAgKiAgICAgUmVxdWlyZWQgZXhjZXB0IGZvciBVUyBhbmQgRVUuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0dldEpvYkNhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7P2Vycm9yfSBjYWxsYmFjay5lcnIgQW4gZXJyb3IgcmV0dXJuZWQgd2hpbGUgbWFraW5nIHRoaXNcbiAgICAgICAgICAgICAqICAgICByZXF1ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtKb2J9IGNhbGxiYWNrLmpvYiBUaGUgam9iLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Sm9iUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IGpvYiA9IGJpZ3F1ZXJ5LmpvYignam9iLWlkJyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogam9iLmdldCgoZXJyLCBqb2IsIGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgKiAgICAgLy8gYGpvYi5tZXRhZGF0YWAgaGFzIGJlZW4gcG9wdWxhdGVkLlxuICAgICAgICAgICAgICogICB9XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIC8vIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkLCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiBqb2IuZ2V0KCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICogICBjb25zdCBqb2IgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICogICBjb25zdCBhcGlSZXNwb25zZSA9IGRhdGFbMV07XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBHZXRKb2JNZXRhZGF0YUNhbGxiYWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9FcnJvcn0gZXJyIFJlcXVlc3QgZXJyb3IsIGlmIGFueS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YSBUaGUgam9iIG1ldGFkYXRhLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IEdldEpvYk1ldGFkYXRhUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAwIFRoZSBqb2IgbWV0YWRhdGEuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gMSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBtZXRhZGF0YSBvZiB0aGUgam9iLiBUaGlzIHdpbGwgbW9zdGx5IGJlIHVzZWZ1bCBmb3IgY2hlY2tpbmdcbiAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgb2YgYSBwcmV2aW91c2x5LXJ1biBqb2IuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvdjIvam9icy9nZXR8IEpvYnM6IGdldCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIEpvYiNnZXRNZXRhZGF0YVxuICAgICAgICAgICAgICogQHBhcmFtIHtHZXRKb2JNZXRhZGF0YUNhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7P2Vycm9yfSBjYWxsYmFjay5lcnIgQW4gZXJyb3IgcmV0dXJuZWQgd2hpbGUgbWFraW5nIHRoaXNcbiAgICAgICAgICAgICAqICAgICByZXF1ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrLm1ldGFkYXRhIFRoZSBtZXRhZGF0YSBvZiB0aGUgam9iLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrLmFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEpvYk1ldGFkYXRhUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IGpvYiA9IGJpZ3F1ZXJ5LmpvYignaWQnKTtcbiAgICAgICAgICAgICAqIGpvYi5nZXRNZXRhZGF0YSgoZXJyLCBtZXRhZGF0YSwgYXBpUmVzcG9uc2UpID0+IHt9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIC8vIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkLCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiBqb2IuZ2V0TWV0YWRhdGEoKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnN0IG1ldGFkYXRhID0gZGF0YVswXTtcbiAgICAgICAgICAgICAqICAgY29uc3QgYXBpUmVzcG9uc2UgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICByZXFPcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcGFyZW50OiBiaWdRdWVyeSxcbiAgICAgICAgICAgIGJhc2VVcmw6ICcvam9icycsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG1ldGhvZHMsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xvY2F0aW9uJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoX2xvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBfbG9jYXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iaWdRdWVyeSA9IGJpZ1F1ZXJ5O1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBvcHRpb25zLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZXN1bHRzIG9mIGEgam9iIGFzIGEgcmVhZGFibGUgb2JqZWN0IHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvYmplY3QuIFNlZVxuICAgICAgICAgKiAgICAge0BsaW5rIEpvYiNnZXRRdWVyeVJlc3VsdHN9IGZvciBhIGNvbXBsZXRlIGxpc3Qgb2Ygb3B0aW9ucy5cbiAgICAgICAgICogQHJldHVybiB7c3RyZWFtfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogY29uc3QgdGhyb3VnaDIgPSByZXF1aXJlKCd0aHJvdWdoMicpO1xuICAgICAgICAgKiBjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IGpvYiA9IGJpZ3F1ZXJ5LmpvYignam9iLWlkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGpvYi5nZXRRdWVyeVJlc3VsdHNTdHJlYW0oKVxuICAgICAgICAgKiAgIC5waXBlKHRocm91Z2gyLm9iaihmdW5jdGlvbiAocm93LCBlbmMsIG5leHQpIHtcbiAgICAgICAgICogICAgIHRoaXMucHVzaChKU09OLnN0cmluZ2lmeShyb3cpICsgJ1xcbicpO1xuICAgICAgICAgKiAgICAgbmV4dCgpO1xuICAgICAgICAgKiAgIH0pKVxuICAgICAgICAgKiAgIC5waXBlKGZzLmNyZWF0ZVdyaXRlU3RyZWFtKCcuL3Rlc3QvdGVzdGRhdGEvdGVzdGZpbGUuanNvbicpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFF1ZXJ5UmVzdWx0c1N0cmVhbSA9IHBhZ2luYXRvcl8xLnBhZ2luYXRvci5zdHJlYW1pZnkoJ2dldFF1ZXJ5UmVzdWx0c0FzU3RyZWFtXycpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRyYWNlXyhtc2csIC4uLm90aGVyQXJncykge1xuICAgICAgICAoMCwgbG9nZ2VyXzEubG9nZ2VyKShgW2pvYl1bJHt0aGlzLmlkfV1gLCBtc2csIC4uLm90aGVyQXJncyk7XG4gICAgfVxuICAgIGNhbmNlbChjYWxsYmFjaykge1xuICAgICAgICBsZXQgcXM7XG4gICAgICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICBxcyA9IHsgbG9jYXRpb246IHRoaXMubG9jYXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmk6ICcvY2FuY2VsJyxcbiAgICAgICAgICAgIHFzLFxuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldFF1ZXJ5UmVzdWx0cyhvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBvcHRpb25zT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNPckNhbGxiYWNrIDogY2I7XG4gICAgICAgIGNvbnN0IHFzID0gZXh0ZW5kKHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLmxvY2F0aW9uLFxuICAgICAgICAgICAgJ2Zvcm1hdE9wdGlvbnMudXNlSW50NjRUaW1lc3RhbXAnOiB0cnVlLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50cmFjZV8oJ1tnZXRRdWVyeVJlc3VsdHNdJywgdGhpcy5pZCwgb3B0aW9ucy5wYWdlVG9rZW4sIG9wdGlvbnMuc3RhcnRJbmRleCk7XG4gICAgICAgIGNvbnN0IHdyYXBJbnRlZ2VycyA9IHFzLndyYXBJbnRlZ2VycyA/IHFzLndyYXBJbnRlZ2VycyA6IGZhbHNlO1xuICAgICAgICBkZWxldGUgcXMud3JhcEludGVnZXJzO1xuICAgICAgICBjb25zdCBwYXJzZUpTT04gPSBxcy5wYXJzZUpTT04gPyBxcy5wYXJzZUpTT04gOiBmYWxzZTtcbiAgICAgICAgZGVsZXRlIHFzLnBhcnNlSlNPTjtcbiAgICAgICAgZGVsZXRlIHFzLmpvYjtcbiAgICAgICAgY29uc3QgdGltZW91dE92ZXJyaWRlID0gdHlwZW9mIHFzLnRpbWVvdXRNcyA9PT0gJ251bWJlcicgPyBxcy50aW1lb3V0TXMgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FjaGVkUm93cyA9IG9wdGlvbnMuX2NhY2hlZFJvd3M7XG4gICAgICAgIGNvbnN0IGNhY2hlZFJlc3BvbnNlID0gb3B0aW9ucy5fY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLl9jYWNoZWRSb3dzO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5fY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgIGlmIChjYWNoZWRSb3dzKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIG5leHRRdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRva2VuOiBvcHRpb25zLnBhZ2VUb2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID09PSBudWxsIHx8IGNhY2hlZFJlc3BvbnNlID09PSB2b2lkIDAgPyB0cnVlIDogZGVsZXRlIGNhY2hlZFJlc3BvbnNlLnJvd3M7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjYWNoZWRSb3dzLCBuZXh0UXVlcnksIGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpZ1F1ZXJ5LnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJpOiAnL3F1ZXJpZXMvJyArIHRoaXMuaWQsXG4gICAgICAgICAgICBxcyxcbiAgICAgICAgfSwgKGVyciwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCwgbnVsbCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCByb3dzID0gW107XG4gICAgICAgICAgICBpZiAocmVzcC5zY2hlbWEgJiYgcmVzcC5yb3dzKSB7XG4gICAgICAgICAgICAgICAgcm93cyA9IGJpZ3F1ZXJ5XzEuQmlnUXVlcnkubWVyZ2VTY2hlbWFXaXRoUm93c18ocmVzcC5zY2hlbWEsIHJlc3Aucm93cywge1xuICAgICAgICAgICAgICAgICAgICB3cmFwSW50ZWdlcnMsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlc3Auam9iQ29tcGxldGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gUXVlcnkgaXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgICAgICAgICBuZXh0UXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aW1lb3V0IG92ZXJyaWRlIHdhcyBwcm92aWRlZCwgcmV0dXJuIGVycm9yLlxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0T3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBUaGUgcXVlcnkgZGlkIG5vdCBjb21wbGV0ZSBiZWZvcmUgJHt0aW1lb3V0T3ZlcnJpZGV9bXNgKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsLCBuZXh0UXVlcnksIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcC5wYWdlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlXygnW2dldFF1ZXJ5UmVzdWx0c10gaGFzIG1vcmUgcGFnZXMnLCByZXNwLnBhZ2VUb2tlbik7XG4gICAgICAgICAgICAgICAgLy8gTW9yZSByZXN1bHRzIGV4aXN0LlxuICAgICAgICAgICAgICAgIG5leHRRdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRva2VuOiByZXNwLnBhZ2VUb2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV4dFF1ZXJ5LnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgcmVzcC5yb3dzO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcm93cywgbmV4dFF1ZXJ5LCByZXNwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGJ5IGBnZXRRdWVyeVJlc3VsdHNTdHJlYW0oKWAuIEl0IGlzIHJlcXVpcmVkIHRvXG4gICAgICogcHJvcGVybHkgc2V0IHRoZSBgYXV0b1BhZ2luYXRlYCBvcHRpb24gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFF1ZXJ5UmVzdWx0c0FzU3RyZWFtXyhvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHsgYXV0b1BhZ2luYXRlOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5nZXRRdWVyeVJlc3VsdHMob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2xsIGZvciBhIHN0YXR1cyB1cGRhdGUuIEV4ZWN1dGUgdGhlIGNhbGxiYWNrOlxuICAgICAqXG4gICAgICogICAtIGNhbGxiYWNrKGVycik6IEpvYiBmYWlsZWRcbiAgICAgKiAgIC0gY2FsbGJhY2soKTogSm9iIGluY29tcGxldGVcbiAgICAgKiAgIC0gY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpOiBKb2IgY29tcGxldGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHBvbGxfKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2V0TWV0YWRhdGEoKGVyciwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyICYmIG1ldGFkYXRhLnN0YXR1cyAmJiBtZXRhZGF0YS5zdGF0dXMuZXJyb3JSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgY29tbW9uXzEudXRpbC5BcGlFcnJvcihtZXRhZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhLnN0YXR1cy5zdGF0ZSAhPT0gJ0RPTkUnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkpvYiA9IEpvYjtcbi8qISBEZXZlbG9wZXIgRG9jdW1lbnRhdGlvblxuICpcbiAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIGF1dG8tcGFnaW5hdGVkLlxuICovXG5wYWdpbmF0b3JfMS5wYWdpbmF0b3IuZXh0ZW5kKEpvYiwgWydnZXRRdWVyeVJlc3VsdHMnXSk7XG4vKiEgRGV2ZWxvcGVyIERvY3VtZW50YXRpb25cbiAqXG4gKiBBbGwgYXN5bmMgbWV0aG9kcyAoZXhjZXB0IGZvciBzdHJlYW1zKSB3aWxsIHJldHVybiBhIFByb21pc2UgaW4gdGhlIGV2ZW50XG4gKiB0aGF0IGEgY2FsbGJhY2sgaXMgb21pdHRlZC5cbiAqL1xuKDAsIHByb21pc2lmeV8xLnByb21pc2lmeUFsbCkoSm9iKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/logger.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/logger.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.logger = logger;\nexports.setLogFunction = setLogFunction;\nconst util = __webpack_require__(/*! util */ \"util\");\n/*! The external function used to emit logs. */\nlet logFunction = null;\n/**\n * Log function to use for debug output. By default, we don't perform any\n * logging.\n *\n * @private\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction logger(source, msg, ...otherArgs) {\n    if (logFunction) {\n        const time = new Date().toISOString();\n        const formattedMsg = util.format(`D ${time} | ${source} | ${msg} |`, ...otherArgs);\n        logFunction(formattedMsg);\n    }\n}\n/**\n * Sets or disables the log function for all active BigQuery instances.\n *\n * @param logger A log function that takes a message (such as `console.log`) or\n * `null` to turn off logging.\n */\nfunction setLogFunction(logger) {\n    logFunction = logger;\n}\n//# sourceMappingURL=logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLHNCQUFzQjtBQUN0QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxJQUFJLFFBQVEsSUFBSSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMva2Fpc2VpL0Rlc2t0b3AvbS10cmFjZXItYWkvbm9kZV9tb2R1bGVzL0Bnb29nbGUtY2xvdWQvYmlncXVlcnkvYnVpbGQvc3JjL2xvZ2dlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXI7XG5leHBvcnRzLnNldExvZ0Z1bmN0aW9uID0gc2V0TG9nRnVuY3Rpb247XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG4vKiEgVGhlIGV4dGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gZW1pdCBsb2dzLiAqL1xubGV0IGxvZ0Z1bmN0aW9uID0gbnVsbDtcbi8qKlxuICogTG9nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgZGVidWcgb3V0cHV0LiBCeSBkZWZhdWx0LCB3ZSBkb24ndCBwZXJmb3JtIGFueVxuICogbG9nZ2luZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBsb2dnZXIoc291cmNlLCBtc2csIC4uLm90aGVyQXJncykge1xuICAgIGlmIChsb2dGdW5jdGlvbikge1xuICAgICAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRNc2cgPSB1dGlsLmZvcm1hdChgRCAke3RpbWV9IHwgJHtzb3VyY2V9IHwgJHttc2d9IHxgLCAuLi5vdGhlckFyZ3MpO1xuICAgICAgICBsb2dGdW5jdGlvbihmb3JtYXR0ZWRNc2cpO1xuICAgIH1cbn1cbi8qKlxuICogU2V0cyBvciBkaXNhYmxlcyB0aGUgbG9nIGZ1bmN0aW9uIGZvciBhbGwgYWN0aXZlIEJpZ1F1ZXJ5IGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbG9nZ2VyIEEgbG9nIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBtZXNzYWdlIChzdWNoIGFzIGBjb25zb2xlLmxvZ2ApIG9yXG4gKiBgbnVsbGAgdG8gdHVybiBvZmYgbG9nZ2luZy5cbiAqL1xuZnVuY3Rpb24gc2V0TG9nRnVuY3Rpb24obG9nZ2VyKSB7XG4gICAgbG9nRnVuY3Rpb24gPSBsb2dnZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/model.js":
/*!****************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/model.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Model = void 0;\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\");\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\n/**\n * The model export formats accepted by BigQuery.\n *\n * @type {array}\n * @private\n */\nconst FORMATS = ['ML_TF_SAVED_MODEL', 'ML_XGBOOST_BOOSTER'];\n/**\n * Model objects are returned by methods such as {@link Dataset#model} and\n * {@link Dataset#getModels}.\n *\n * @class\n * @param {Dataset} dataset {@link Dataset} instance.\n * @param {string} id The ID of the model.\n *\n * @example\n * ```\n * const {BigQuery} = require('@google-cloud/bigquery');\n * const bigquery = new BigQuery();\n * const dataset = bigquery.dataset('my-dataset');\n *\n * const model = dataset.model('my-model');\n * ```\n */\nclass Model extends common_1.ServiceObject {\n    constructor(dataset, id) {\n        const methods = {\n            /**\n             * @callback DeleteModelCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * Delete the model.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/models/delete| Models: delete API Documentation}\n             *\n             * @method Model#delete\n             * @param {DeleteModelCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const model = dataset.model('my-model');\n             *\n             * model.delete((err, apiResponse) => {});\n             *\n             * ```\n             * @example If the callback is omitted we'll return a Promise.\n             * ```\n             * const [apiResponse] = await model.delete();\n             * ```\n             * @example If successful, the response body is empty.\n             * ```\n             * ```\n             */\n            delete: true,\n            /**\n             * @callback ModelExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Indicates if the model exists.\n             */\n            /**\n             * @typedef {array} ModelExistsResponse\n             * @property {boolean} 0 Indicates if the model exists.\n             */\n            /**\n             * Check if the model exists.\n             *\n             * @method Model#exists\n             * @param {ModelExistsCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {boolean} callback.exists Whether the model exists or not.\n             * @returns {Promise<ModelExistsResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const model = dataset.model('my-model');\n             *\n             * model.exists((err, exists) => {});\n             *\n             * ```\n             * @example If the callback is omitted we'll return a Promise.\n             * ```\n             * const [exists] = await model.exists();\n             * ```\n             */\n            exists: true,\n            /**\n             * @callback GetModelCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Model} model The model.\n             * @param {object} apiResponse The full API response body.\n             */\n            /**\n             * @typedef {array} GetModelResponse\n             * @property {Model} 0 The model.\n             * @property {object} 1 The full API response body.\n             */\n            /**\n             * Get a model if it exists.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/models/get| Models: get API Documentation}\n             *\n             * @method Model#get:\n             * @param {GetModelCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {Model} callback.model The {@link Model}.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<GetModelResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const model = dataset.model('my-model');\n             *\n             * model.get(err => {\n             *   if (!err) {\n             *     // `model.metadata` has been populated.\n             *   }\n             * });\n             *\n             * ```\n             * @example If the callback is omitted we'll return a Promise.\n             * ```\n             * await model.get();\n             * ```\n             */\n            get: true,\n            /**\n             * @callback GetModelMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The model metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} GetModelMetadataResponse\n             * @property {object} 0 The model metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * Return the metadata associated with the model.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/models/get| Models: get API Documentation}\n             *\n             * @method Model#getMetadata\n             * @param {GetModelMetadataCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.metadata The metadata of the model.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<GetModelMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const model = dataset.model('my-model');\n             *\n             * model.getMetadata((err, metadata, apiResponse) => {});\n             *\n             * ```\n             * @example If the callback is omitted we'll return a Promise.\n             * ```\n             * const [metadata, apiResponse] = await model.getMetadata();\n             * ```\n             */\n            getMetadata: true,\n            /**\n             * @callback SetModelMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The model metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} SetModelMetadataResponse\n             * @property {object} 0 The model metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/models/patch| Models: patch API Documentation}\n             *\n             * @method Model#setMetadata\n             * @param {object} metadata The metadata key/value object to set.\n             * @param {SetModelMetadataCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.metadata The updated metadata of the model.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<SetModelMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const model = dataset.model('my-model');\n             *\n             * const metadata = {\n             *   friendlyName: 'TheBestModelEver'\n             * };\n             *\n             * model.setMetadata(metadata, (err, metadata, apiResponse) => {});\n             *\n             * ```\n             * @example If the callback is omitted we'll return a Promise.\n             * ```\n             * const [metadata, apiResponse] = await model.setMetadata(metadata);\n             * ```\n             */\n            setMetadata: true,\n        };\n        super({\n            parent: dataset,\n            baseUrl: '/models',\n            id,\n            methods,\n        });\n        this.dataset = dataset;\n        this.bigQuery = dataset.bigQuery;\n    }\n    createExtractJob(destination, optionsOrCallback, cb) {\n        let options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        options = extend(true, options, {\n            destinationUris: arrify(destination).map(dest => {\n                if (common_1.util.isCustomType(dest, 'storage/file')) {\n                    return ('gs://' + dest.bucket.name + '/' + dest.name);\n                }\n                if (typeof dest === 'string') {\n                    return dest;\n                }\n                throw new Error('Destination must be a string or a File object.');\n            }),\n        });\n        if (options.format) {\n            options.format = options.format.toUpperCase();\n            if (FORMATS.includes(options.format)) {\n                options.destinationFormat = options.format;\n                delete options.format;\n            }\n            else {\n                throw new Error('Destination format not recognized: ' + options.format);\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const body = {\n            configuration: {\n                extract: extend(true, options, {\n                    sourceModel: {\n                        datasetId: this.dataset.id,\n                        projectId: this.dataset.projectId,\n                        modelId: this.id,\n                    },\n                }),\n            },\n        };\n        if (options.jobPrefix) {\n            body.jobPrefix = options.jobPrefix;\n            delete options.jobPrefix;\n        }\n        if (options.jobId) {\n            body.jobId = options.jobId;\n            delete options.jobId;\n        }\n        this.bigQuery.createJob(body, callback);\n    }\n    extract(destination, optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        this.createExtractJob(destination, options, (err, job, resp) => {\n            if (err) {\n                callback(err, resp);\n                return;\n            }\n            job.on('error', callback).on('complete', metadata => {\n                callback(null, metadata);\n            });\n        });\n    }\n}\nexports.Model = Model;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n(0, promisify_1.promisifyAll)(Model);\n//# sourceMappingURL=model.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvbW9kZWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLDBGQUFzQjtBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBeUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLFNBQVMsU0FBUyxlQUFlO0FBQzVDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLHlCQUF5QixPQUFP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Q2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvbW9kZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nb2RlbCA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIkBnb29nbGUtY2xvdWQvY29tbW9uXCIpO1xuY29uc3QgcHJvbWlzaWZ5XzEgPSByZXF1aXJlKFwiQGdvb2dsZS1jbG91ZC9wcm9taXNpZnlcIik7XG5jb25zdCBhcnJpZnkgPSByZXF1aXJlKFwiYXJyaWZ5XCIpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZShcImV4dGVuZFwiKTtcbi8qKlxuICogVGhlIG1vZGVsIGV4cG9ydCBmb3JtYXRzIGFjY2VwdGVkIGJ5IEJpZ1F1ZXJ5LlxuICpcbiAqIEB0eXBlIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IEZPUk1BVFMgPSBbJ01MX1RGX1NBVkVEX01PREVMJywgJ01MX1hHQk9PU1RfQk9PU1RFUiddO1xuLyoqXG4gKiBNb2RlbCBvYmplY3RzIGFyZSByZXR1cm5lZCBieSBtZXRob2RzIHN1Y2ggYXMge0BsaW5rIERhdGFzZXQjbW9kZWx9IGFuZFxuICoge0BsaW5rIERhdGFzZXQjZ2V0TW9kZWxzfS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldCB7QGxpbmsgRGF0YXNldH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBtb2RlbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gKlxuICogY29uc3QgbW9kZWwgPSBkYXRhc2V0Lm1vZGVsKCdteS1tb2RlbCcpO1xuICogYGBgXG4gKi9cbmNsYXNzIE1vZGVsIGV4dGVuZHMgY29tbW9uXzEuU2VydmljZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoZGF0YXNldCwgaWQpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNhbGxiYWNrIERlbGV0ZU1vZGVsQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgdGhlIG1vZGVsLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjIvbW9kZWxzL2RlbGV0ZXwgTW9kZWxzOiBkZWxldGUgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBNb2RlbCNkZWxldGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGVsZXRlTW9kZWxDYWxsYmFja30gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9lcnJvcn0gY2FsbGJhY2suZXJyIEFuIGVycm9yIHJldHVybmVkIHdoaWxlIG1ha2luZyB0aGlzXG4gICAgICAgICAgICAgKiAgICAgcmVxdWVzdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFjay5hcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBtb2RlbCA9IGRhdGFzZXQubW9kZWwoJ215LW1vZGVsJyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogbW9kZWwuZGVsZXRlKChlcnIsIGFwaVJlc3BvbnNlKSA9PiB7fSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBAZXhhbXBsZSBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCBbYXBpUmVzcG9uc2VdID0gYXdhaXQgbW9kZWwuZGVsZXRlKCk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIEBleGFtcGxlIElmIHN1Y2Nlc3NmdWwsIHRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2FsbGJhY2sgTW9kZWxFeGlzdHNDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4aXN0cyBJbmRpY2F0ZXMgaWYgdGhlIG1vZGVsIGV4aXN0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IE1vZGVsRXhpc3RzUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gMCBJbmRpY2F0ZXMgaWYgdGhlIG1vZGVsIGV4aXN0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiB0aGUgbW9kZWwgZXhpc3RzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgTW9kZWwjZXhpc3RzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01vZGVsRXhpc3RzQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpc1xuICAgICAgICAgICAgICogICAgIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbGxiYWNrLmV4aXN0cyBXaGV0aGVyIHRoZSBtb2RlbCBleGlzdHMgb3Igbm90LlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxFeGlzdHNSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnbXktZGF0YXNldCcpO1xuICAgICAgICAgICAgICogY29uc3QgbW9kZWwgPSBkYXRhc2V0Lm1vZGVsKCdteS1tb2RlbCcpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIG1vZGVsLmV4aXN0cygoZXJyLCBleGlzdHMpID0+IHt9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIEBleGFtcGxlIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIHdlJ2xsIHJldHVybiBhIFByb21pc2UuXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IFtleGlzdHNdID0gYXdhaXQgbW9kZWwuZXhpc3RzKCk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXhpc3RzOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2FsbGJhY2sgR2V0TW9kZWxDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01vZGVsfSBtb2RlbCBUaGUgbW9kZWwuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlIGJvZHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBHZXRNb2RlbFJlc3BvbnNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge01vZGVsfSAwIFRoZSBtb2RlbC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAxIFRoZSBmdWxsIEFQSSByZXNwb25zZSBib2R5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIG1vZGVsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YyL21vZGVscy9nZXR8IE1vZGVsczogZ2V0IEFQSSBEb2N1bWVudGF0aW9ufVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgTW9kZWwjZ2V0OlxuICAgICAgICAgICAgICogQHBhcmFtIHtHZXRNb2RlbENhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7P2Vycm9yfSBjYWxsYmFjay5lcnIgQW4gZXJyb3IgcmV0dXJuZWQgd2hpbGUgbWFraW5nIHRoaXNcbiAgICAgICAgICAgICAqICAgICByZXF1ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtNb2RlbH0gY2FsbGJhY2subW9kZWwgVGhlIHtAbGluayBNb2RlbH0uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2suYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8R2V0TW9kZWxSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnbXktZGF0YXNldCcpO1xuICAgICAgICAgICAgICogY29uc3QgbW9kZWwgPSBkYXRhc2V0Lm1vZGVsKCdteS1tb2RlbCcpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIG1vZGVsLmdldChlcnIgPT4ge1xuICAgICAgICAgICAgICogICBpZiAoIWVycikge1xuICAgICAgICAgICAgICogICAgIC8vIGBtb2RlbC5tZXRhZGF0YWAgaGFzIGJlZW4gcG9wdWxhdGVkLlxuICAgICAgICAgICAgICogICB9XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIEBleGFtcGxlIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIHdlJ2xsIHJldHVybiBhIFByb21pc2UuXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGF3YWl0IG1vZGVsLmdldCgpO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNhbGxiYWNrIEdldE1vZGVsTWV0YWRhdGFDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEgVGhlIG1vZGVsIG1ldGFkYXRhLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IEdldE1vZGVsTWV0YWRhdGFSZXNwb25zZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDAgVGhlIG1vZGVsIG1ldGFkYXRhLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDEgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybiB0aGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBtb2RlbC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YyL21vZGVscy9nZXR8IE1vZGVsczogZ2V0IEFQSSBEb2N1bWVudGF0aW9ufVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgTW9kZWwjZ2V0TWV0YWRhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7R2V0TW9kZWxNZXRhZGF0YUNhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7P2Vycm9yfSBjYWxsYmFjay5lcnIgQW4gZXJyb3IgcmV0dXJuZWQgd2hpbGUgbWFraW5nIHRoaXNcbiAgICAgICAgICAgICAqICAgICByZXF1ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrLm1ldGFkYXRhIFRoZSBtZXRhZGF0YSBvZiB0aGUgbW9kZWwuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2suYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8R2V0TW9kZWxNZXRhZGF0YVJlc3BvbnNlPn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBtb2RlbCA9IGRhdGFzZXQubW9kZWwoJ215LW1vZGVsJyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogbW9kZWwuZ2V0TWV0YWRhdGEoKGVyciwgbWV0YWRhdGEsIGFwaVJlc3BvbnNlKSA9PiB7fSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBAZXhhbXBsZSBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCBbbWV0YWRhdGEsIGFwaVJlc3BvbnNlXSA9IGF3YWl0IG1vZGVsLmdldE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TWV0YWRhdGE6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBTZXRNb2RlbE1ldGFkYXRhQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhIFRoZSBtb2RlbCBtZXRhZGF0YS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBTZXRNb2RlbE1ldGFkYXRhUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAwIFRoZSBtb2RlbCBtZXRhZGF0YS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAxIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YyL21vZGVscy9wYXRjaHwgTW9kZWxzOiBwYXRjaCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIE1vZGVsI3NldE1ldGFkYXRhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEgVGhlIG1ldGFkYXRhIGtleS92YWx1ZSBvYmplY3QgdG8gc2V0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtTZXRNb2RlbE1ldGFkYXRhQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpc1xuICAgICAgICAgICAgICogICAgIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2subWV0YWRhdGEgVGhlIHVwZGF0ZWQgbWV0YWRhdGEgb2YgdGhlIG1vZGVsLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrLmFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNldE1vZGVsTWV0YWRhdGFSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnbXktZGF0YXNldCcpO1xuICAgICAgICAgICAgICogY29uc3QgbW9kZWwgPSBkYXRhc2V0Lm1vZGVsKCdteS1tb2RlbCcpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICogICBmcmllbmRseU5hbWU6ICdUaGVCZXN0TW9kZWxFdmVyJ1xuICAgICAgICAgICAgICogfTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBtb2RlbC5zZXRNZXRhZGF0YShtZXRhZGF0YSwgKGVyciwgbWV0YWRhdGEsIGFwaVJlc3BvbnNlKSA9PiB7fSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBAZXhhbXBsZSBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCBbbWV0YWRhdGEsIGFwaVJlc3BvbnNlXSA9IGF3YWl0IG1vZGVsLnNldE1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRNZXRhZGF0YTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcGFyZW50OiBkYXRhc2V0LFxuICAgICAgICAgICAgYmFzZVVybDogJy9tb2RlbHMnLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBtZXRob2RzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgICAgdGhpcy5iaWdRdWVyeSA9IGRhdGFzZXQuYmlnUXVlcnk7XG4gICAgfVxuICAgIGNyZWF0ZUV4dHJhY3RKb2IoZGVzdGluYXRpb24sIG9wdGlvbnNPckNhbGxiYWNrLCBjYikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBvcHRpb25zT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNPckNhbGxiYWNrIDogY2I7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQodHJ1ZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgZGVzdGluYXRpb25VcmlzOiBhcnJpZnkoZGVzdGluYXRpb24pLm1hcChkZXN0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbW9uXzEudXRpbC5pc0N1c3RvbVR5cGUoZGVzdCwgJ3N0b3JhZ2UvZmlsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJ2dzOi8vJyArIGRlc3QuYnVja2V0Lm5hbWUgKyAnLycgKyBkZXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rlc3RpbmF0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBGaWxlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoRk9STUFUUy5pbmNsdWRlcyhvcHRpb25zLmZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRlc3RpbmF0aW9uRm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXN0aW5hdGlvbiBmb3JtYXQgbm90IHJlY29nbml6ZWQ6ICcgKyBvcHRpb25zLmZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICBleHRyYWN0OiBleHRlbmQodHJ1ZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldElkOiB0aGlzLmRhdGFzZXQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuZGF0YXNldC5wcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuam9iUHJlZml4KSB7XG4gICAgICAgICAgICBib2R5LmpvYlByZWZpeCA9IG9wdGlvbnMuam9iUHJlZml4O1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuam9iUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmpvYklkKSB7XG4gICAgICAgICAgICBib2R5LmpvYklkID0gb3B0aW9ucy5qb2JJZDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmpvYklkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmlnUXVlcnkuY3JlYXRlSm9iKGJvZHksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZXh0cmFjdChkZXN0aW5hdGlvbiwgb3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zT3JDYWxsYmFjayA6IGNiO1xuICAgICAgICB0aGlzLmNyZWF0ZUV4dHJhY3RKb2IoZGVzdGluYXRpb24sIG9wdGlvbnMsIChlcnIsIGpvYiwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgam9iLm9uKCdlcnJvcicsIGNhbGxiYWNrKS5vbignY29tcGxldGUnLCBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcbi8qISBEZXZlbG9wZXIgRG9jdW1lbnRhdGlvblxuICpcbiAqIEFsbCBhc3luYyBtZXRob2RzIChleGNlcHQgZm9yIHN0cmVhbXMpIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSBpbiB0aGUgZXZlbnRcbiAqIHRoYXQgYSBjYWxsYmFjayBpcyBvbWl0dGVkLlxuICovXG4oMCwgcHJvbWlzaWZ5XzEucHJvbWlzaWZ5QWxsKShNb2RlbCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/model.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/routine.js":
/*!******************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/routine.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Routine = void 0;\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\n/**\n * Routine objects are returned by methods such as\n * {@link Dataset#routine}, {@link Dataset#createRoutine}, and\n * {@link Dataset#getRoutines}.\n *\n * @class\n * @param {Dataset} dataset {@link Dataset} instance.\n * @param {string} id The ID of the routine.\n *\n * @example\n * ```\n * const {BigQuery} = require('@google-cloud/bigquery');\n * const bigquery = new BigQuery();\n * const dataset = bigquery.dataset('my-dataset');\n *\n * const routine = dataset.routine('my_routine');\n * ```\n */\nclass Routine extends common_1.ServiceObject {\n    constructor(dataset, id) {\n        const methods = {\n            /**\n             * Create a routine.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/insert| Routines: insert API Documentation}\n             *\n             * @method Routine#create\n             * @param {object} config A [routine resource]{@link https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Routine}.\n             * @param {CreateRoutineCallback} [callback] The callback function.\n             * @returns {Promise<CreateRoutineResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const routine = dataset.routine('my_routine');\n             *\n             * const config = {\n             *   arguments: [{\n             *     name: 'x',\n             *     dataType: {\n             *       typeKind: 'INT64'\n             *     }\n             *   }],\n             *   definitionBody: 'x * 3',\n             *   routineType: 'SCALAR_FUNCTION',\n             *   returnType: {\n             *     typeKind: 'INT64'\n             *   }\n             * };\n             *\n             * routine.create(config, (err, routine, apiResponse) => {\n             *   if (!err) {\n             *     // The routine was created successfully.\n             *   }\n             * });\n             *\n             * ```\n             * @example If the callback is omitted a Promise will be returned\n             * ```\n             * const [routine, apiResponse] = await routine.create(config);\n             * ```\n             */\n            create: true,\n            /**\n             * @callback DeleteRoutineCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} DeleteRoutineResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * Deletes a routine.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/delete| Routines: delete API Documentation}\n             *\n             * @method Routine#delete\n             * @param {DeleteRoutineCallback} [callback] The callback function.\n             * @returns {Promise<DeleteRoutineResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const routine = dataset.routine('my_routine');\n             *\n             * routine.delete((err, apiResponse) => {\n             *   if (!err) {\n             *     // The routine was deleted successfully.\n             *   }\n             * });\n             *\n             * ```\n             * @example If the callback is omitted a Promise will be returned\n             * ```\n             * const [apiResponse] = await routine.delete();\n             * ```\n             */\n            delete: true,\n            /**\n             * @callback RoutineExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Indicates if the routine exists.\n             */\n            /**\n             * @typedef {array} RoutineExistsResponse\n             * @property {boolean} 0 Indicates if the routine exists.\n             */\n            /**\n             * Check if the routine exists.\n             *\n             * @method Routine#exists\n             * @param {RoutineExistsCallback} [callback] The callback function.\n             * @returns {Promise<RoutineExistsResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const routine = dataset.routine('my_routine');\n             *\n             * routine.exists((err, exists) => {});\n             *\n             * ```\n             * @example If the callback is omitted a Promise will be returned\n             * ```\n             * const [exists] = await routine.exists();\n             * ```\n             */\n            exists: true,\n            /**\n             * @callback GetRoutineCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Routine} routine The routine.\n             * @param {object} apiResponse The full API response body.\n             */\n            /**\n             * @typedef {array} GetRoutineResponse\n             * @property {Routine} 0 The routine.\n             * @property {object} 1 The full API response body.\n             */\n            /**\n             * Get a routine if it exists.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/get| Routines: get API Documentation}\n             *\n             * @method Routine#get\n             * @param {GetRoutineCallback} [callback] The callback function.\n             * @returns {Promise<GetRoutineResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const routine = dataset.routine('my_routine');\n             *\n             * routine.get((err, routine) => {});\n             *\n             * ```\n             * @example If the callback is omitted a Promise will be returned\n             * ```\n             * const [routine2] = await routine.get();\n             * ```\n             */\n            get: true,\n            /**\n             * @callback GetRoutineMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The routine metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} GetRoutineMetadataResponse\n             * @property {object} 0 The routine metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * Get the metadata associated with a routine.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/get| Routines: get API Documentation}\n             *\n             * @method Routine#getMetadata\n             * @param {GetRoutineMetadataCallback} [callback] The callback function.\n             * @returns {Promise<GetRoutineMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const routine = dataset.routine('my_routine');\n             *\n             * routine.getMetadata((err, metadata, apiResponse) => {});\n             *\n             * ```\n             * @example If the callback is omitted a Promise will be returned\n             * ```\n             * const [metadata, apiResponse] = await routine.getMetadata();\n             * ```\n             */\n            getMetadata: true,\n            /**\n             * @callback SetRoutineMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The routine metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} SetRoutineMetadataResponse\n             * @property {object} 0 The routine metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * Update a routine.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/update| Routines: update API Documentation}\n             *\n             * @method Routine#setMetadata\n             * @param {object} metadata A [routine resource object]{@link https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Routine}.\n             * @param {SetRoutineMetadataCallback} [callback] The callback function.\n             * @returns {Promise<SetRoutineMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             * const routine = dataset.routine('my_routine');\n             *\n             * const updates = {\n             *   description: 'The perfect description!'\n             * };\n             *\n             * routine.setMetadata(updates, (err, metadata, apiResponse) => {});\n             *\n             * ```\n             * @example If the callback is omitted a Promise will be returned\n             * ```\n             * const [metadata, apiResponse] = await routine.setMetadata(updates);\n             * ```\n             */\n            setMetadata: {\n                reqOpts: {\n                    method: 'PUT',\n                },\n            },\n        };\n        super({\n            parent: dataset,\n            baseUrl: '/routines',\n            id,\n            methods,\n            createMethod: dataset.createRoutine.bind(dataset),\n        });\n    }\n    setMetadata(metadata, callback) {\n        // per the python client, it would appear that in order to update a routine\n        // you need to send the routine in its entirety, not just the updated fields\n        this.getMetadata((err, fullMetadata) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            const updatedMetadata = extend(true, {}, fullMetadata, metadata);\n            super.setMetadata(updatedMetadata, callback);\n        });\n    }\n}\nexports.Routine = Routine;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n(0, promisify_1.promisifyAll)(Routine);\n//# sourceMappingURL=routine.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvcm91dGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEZBQXNCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0I7QUFDQTtBQUNBLElBQUksc0JBQXNCLEdBQUcsNEJBQTRCO0FBQ3pELElBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQSxXQUFXLFNBQVMsU0FBUyxlQUFlO0FBQzVDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSw0QkFBNEIsZ0ZBQWdGO0FBQzNJLHVCQUF1Qix1QkFBdUI7QUFDOUMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEMsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLDBCQUEwQixTQUFTO0FBQ25DLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CLHVCQUF1QixRQUFRO0FBQy9CLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQywwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsMEJBQTBCLFFBQVE7QUFDbEMsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVCQUF1QixRQUFRLHFDQUFxQyxnRkFBZ0Y7QUFDcEosdUJBQXVCLDRCQUE0QjtBQUNuRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvcm91dGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm91dGluZSA9IHZvaWQgMDtcbi8qIVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIkBnb29nbGUtY2xvdWQvY29tbW9uXCIpO1xuY29uc3QgcHJvbWlzaWZ5XzEgPSByZXF1aXJlKFwiQGdvb2dsZS1jbG91ZC9wcm9taXNpZnlcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuLyoqXG4gKiBSb3V0aW5lIG9iamVjdHMgYXJlIHJldHVybmVkIGJ5IG1ldGhvZHMgc3VjaCBhc1xuICoge0BsaW5rIERhdGFzZXQjcm91dGluZX0sIHtAbGluayBEYXRhc2V0I2NyZWF0ZVJvdXRpbmV9LCBhbmRcbiAqIHtAbGluayBEYXRhc2V0I2dldFJvdXRpbmVzfS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldCB7QGxpbmsgRGF0YXNldH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSByb3V0aW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ215LWRhdGFzZXQnKTtcbiAqXG4gKiBjb25zdCByb3V0aW5lID0gZGF0YXNldC5yb3V0aW5lKCdteV9yb3V0aW5lJyk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgUm91dGluZSBleHRlbmRzIGNvbW1vbl8xLlNlcnZpY2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFzZXQsIGlkKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZSBhIHJvdXRpbmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvcmVzdC92Mi9yb3V0aW5lcy9pbnNlcnR8IFJvdXRpbmVzOiBpbnNlcnQgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBSb3V0aW5lI2NyZWF0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBBIFtyb3V0aW5lIHJlc291cmNlXXtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvcmVzdC92Mi9yb3V0aW5lcyNSb3V0aW5lfS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlUm91dGluZUNhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENyZWF0ZVJvdXRpbmVSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnbXktZGF0YXNldCcpO1xuICAgICAgICAgICAgICogY29uc3Qgcm91dGluZSA9IGRhdGFzZXQucm91dGluZSgnbXlfcm91dGluZScpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAqICAgYXJndW1lbnRzOiBbe1xuICAgICAgICAgICAgICogICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAqICAgICBkYXRhVHlwZToge1xuICAgICAgICAgICAgICogICAgICAgdHlwZUtpbmQ6ICdJTlQ2NCdcbiAgICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICAgKiAgIH1dLFxuICAgICAgICAgICAgICogICBkZWZpbml0aW9uQm9keTogJ3ggKiAzJyxcbiAgICAgICAgICAgICAqICAgcm91dGluZVR5cGU6ICdTQ0FMQVJfRlVOQ1RJT04nLFxuICAgICAgICAgICAgICogICByZXR1cm5UeXBlOiB7XG4gICAgICAgICAgICAgKiAgICAgdHlwZUtpbmQ6ICdJTlQ2NCdcbiAgICAgICAgICAgICAqICAgfVxuICAgICAgICAgICAgICogfTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiByb3V0aW5lLmNyZWF0ZShjb25maWcsIChlcnIsIHJvdXRpbmUsIGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgKiAgICAgLy8gVGhlIHJvdXRpbmUgd2FzIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICogICB9XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIEBleGFtcGxlIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIGEgUHJvbWlzZSB3aWxsIGJlIHJldHVybmVkXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IFtyb3V0aW5lLCBhcGlSZXNwb25zZV0gPSBhd2FpdCByb3V0aW5lLmNyZWF0ZShjb25maWcpO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNhbGxiYWNrIERlbGV0ZVJvdXRpbmVDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHthcnJheX0gRGVsZXRlUm91dGluZVJlc3BvbnNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gMCBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVsZXRlcyBhIHJvdXRpbmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvcmVzdC92Mi9yb3V0aW5lcy9kZWxldGV8IFJvdXRpbmVzOiBkZWxldGUgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBSb3V0aW5lI2RlbGV0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtEZWxldGVSb3V0aW5lQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGVsZXRlUm91dGluZVJlc3BvbnNlPn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCByb3V0aW5lID0gZGF0YXNldC5yb3V0aW5lKCdteV9yb3V0aW5lJyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogcm91dGluZS5kZWxldGUoKGVyciwgYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAqICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAqICAgICAvLyBUaGUgcm91dGluZSB3YXMgZGVsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAgICAgKiAgIH1cbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogQGV4YW1wbGUgSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgYSBQcm9taXNlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3QgW2FwaVJlc3BvbnNlXSA9IGF3YWl0IHJvdXRpbmUuZGVsZXRlKCk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2FsbGJhY2sgUm91dGluZUV4aXN0c0NhbGxiYWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9FcnJvcn0gZXJyIFJlcXVlc3QgZXJyb3IsIGlmIGFueS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhpc3RzIEluZGljYXRlcyBpZiB0aGUgcm91dGluZSBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBSb3V0aW5lRXhpc3RzUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gMCBJbmRpY2F0ZXMgaWYgdGhlIHJvdXRpbmUgZXhpc3RzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIGlmIHRoZSByb3V0aW5lIGV4aXN0cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIFJvdXRpbmUjZXhpc3RzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1JvdXRpbmVFeGlzdHNDYWxsYmFja30gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSb3V0aW5lRXhpc3RzUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ215LWRhdGFzZXQnKTtcbiAgICAgICAgICAgICAqIGNvbnN0IHJvdXRpbmUgPSBkYXRhc2V0LnJvdXRpbmUoJ215X3JvdXRpbmUnKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiByb3V0aW5lLmV4aXN0cygoZXJyLCBleGlzdHMpID0+IHt9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIEBleGFtcGxlIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIGEgUHJvbWlzZSB3aWxsIGJlIHJldHVybmVkXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IFtleGlzdHNdID0gYXdhaXQgcm91dGluZS5leGlzdHMoKTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleGlzdHM6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBHZXRSb3V0aW5lQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtSb3V0aW5lfSByb3V0aW5lIFRoZSByb3V0aW5lLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZSBib2R5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHthcnJheX0gR2V0Um91dGluZVJlc3BvbnNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1JvdXRpbmV9IDAgVGhlIHJvdXRpbmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gMSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UgYm9keS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSByb3V0aW5lIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YyL3JvdXRpbmVzL2dldHwgUm91dGluZXM6IGdldCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIFJvdXRpbmUjZ2V0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0dldFJvdXRpbmVDYWxsYmFja30gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRSb3V0aW5lUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ215LWRhdGFzZXQnKTtcbiAgICAgICAgICAgICAqIGNvbnN0IHJvdXRpbmUgPSBkYXRhc2V0LnJvdXRpbmUoJ215X3JvdXRpbmUnKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiByb3V0aW5lLmdldCgoZXJyLCByb3V0aW5lKSA9PiB7fSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBAZXhhbXBsZSBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCBhIFByb21pc2Ugd2lsbCBiZSByZXR1cm5lZFxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCBbcm91dGluZTJdID0gYXdhaXQgcm91dGluZS5nZXQoKTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBHZXRSb3V0aW5lTWV0YWRhdGFDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEgVGhlIHJvdXRpbmUgbWV0YWRhdGEuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHthcnJheX0gR2V0Um91dGluZU1ldGFkYXRhUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAwIFRoZSByb3V0aW5lIG1ldGFkYXRhLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDEgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgcm91dGluZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YyL3JvdXRpbmVzL2dldHwgUm91dGluZXM6IGdldCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIFJvdXRpbmUjZ2V0TWV0YWRhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7R2V0Um91dGluZU1ldGFkYXRhQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Um91dGluZU1ldGFkYXRhUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ215LWRhdGFzZXQnKTtcbiAgICAgICAgICAgICAqIGNvbnN0IHJvdXRpbmUgPSBkYXRhc2V0LnJvdXRpbmUoJ215X3JvdXRpbmUnKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiByb3V0aW5lLmdldE1ldGFkYXRhKChlcnIsIG1ldGFkYXRhLCBhcGlSZXNwb25zZSkgPT4ge30pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogQGV4YW1wbGUgSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgYSBQcm9taXNlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3QgW21ldGFkYXRhLCBhcGlSZXNwb25zZV0gPSBhd2FpdCByb3V0aW5lLmdldE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TWV0YWRhdGE6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBTZXRSb3V0aW5lTWV0YWRhdGFDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEgVGhlIHJvdXRpbmUgbWV0YWRhdGEuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHthcnJheX0gU2V0Um91dGluZU1ldGFkYXRhUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAwIFRoZSByb3V0aW5lIG1ldGFkYXRhLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDEgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSBhIHJvdXRpbmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvcmVzdC92Mi9yb3V0aW5lcy91cGRhdGV8IFJvdXRpbmVzOiB1cGRhdGUgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBSb3V0aW5lI3NldE1ldGFkYXRhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEgQSBbcm91dGluZSByZXNvdXJjZSBvYmplY3Rde0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YyL3JvdXRpbmVzI1JvdXRpbmV9LlxuICAgICAgICAgICAgICogQHBhcmFtIHtTZXRSb3V0aW5lTWV0YWRhdGFDYWxsYmFja30gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXRSb3V0aW5lTWV0YWRhdGFSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnbXktZGF0YXNldCcpO1xuICAgICAgICAgICAgICogY29uc3Qgcm91dGluZSA9IGRhdGFzZXQucm91dGluZSgnbXlfcm91dGluZScpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICAgICAgICAgKiAgIGRlc2NyaXB0aW9uOiAnVGhlIHBlcmZlY3QgZGVzY3JpcHRpb24hJ1xuICAgICAgICAgICAgICogfTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiByb3V0aW5lLnNldE1ldGFkYXRhKHVwZGF0ZXMsIChlcnIsIG1ldGFkYXRhLCBhcGlSZXNwb25zZSkgPT4ge30pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogQGV4YW1wbGUgSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgYSBQcm9taXNlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3QgW21ldGFkYXRhLCBhcGlSZXNwb25zZV0gPSBhd2FpdCByb3V0aW5lLnNldE1ldGFkYXRhKHVwZGF0ZXMpO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldE1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVxT3B0czoge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBwYXJlbnQ6IGRhdGFzZXQsXG4gICAgICAgICAgICBiYXNlVXJsOiAnL3JvdXRpbmVzJyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgICAgIGNyZWF0ZU1ldGhvZDogZGF0YXNldC5jcmVhdGVSb3V0aW5lLmJpbmQoZGF0YXNldCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRNZXRhZGF0YShtZXRhZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcGVyIHRoZSBweXRob24gY2xpZW50LCBpdCB3b3VsZCBhcHBlYXIgdGhhdCBpbiBvcmRlciB0byB1cGRhdGUgYSByb3V0aW5lXG4gICAgICAgIC8vIHlvdSBuZWVkIHRvIHNlbmQgdGhlIHJvdXRpbmUgaW4gaXRzIGVudGlyZXR5LCBub3QganVzdCB0aGUgdXBkYXRlZCBmaWVsZHNcbiAgICAgICAgdGhpcy5nZXRNZXRhZGF0YSgoZXJyLCBmdWxsTWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNZXRhZGF0YSA9IGV4dGVuZCh0cnVlLCB7fSwgZnVsbE1ldGFkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICBzdXBlci5zZXRNZXRhZGF0YSh1cGRhdGVkTWV0YWRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Sb3V0aW5lID0gUm91dGluZTtcbi8qISBEZXZlbG9wZXIgRG9jdW1lbnRhdGlvblxuICpcbiAqIEFsbCBhc3luYyBtZXRob2RzIChleGNlcHQgZm9yIHN0cmVhbXMpIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSBpbiB0aGUgZXZlbnRcbiAqIHRoYXQgYSBjYWxsYmFjayBpcyBvbWl0dGVkLlxuICovXG4oMCwgcHJvbWlzaWZ5XzEucHJvbWlzaWZ5QWxsKShSb3V0aW5lKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRpbmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/routine.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowBatch.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/rowBatch.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*!\n * Copyright 2022 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RowBatch = exports.BATCH_LIMITS = void 0;\nexports.BATCH_LIMITS = {\n    maxBytes: 9 * 1024 * 1024,\n    maxRows: 50000,\n};\n/**\n * Call used to help batch rows.\n *\n * @private\n *\n * @param {BatchInsertOptions} options The batching options.\n */\nclass RowBatch {\n    constructor(options) {\n        this.batchOptions = options;\n        this.rows = [];\n        this.callbacks = [];\n        this.created = Date.now();\n        this.bytes = 0;\n    }\n    /**\n     * Adds a row to the current batch.\n     *\n     * @param {object} row The row to insert.\n     * @param {InsertRowsCallback} callback The callback function.\n     */\n    add(row, callback) {\n        this.rows.push(row);\n        this.callbacks.push(callback);\n        this.bytes += Buffer.byteLength(JSON.stringify(row));\n    }\n    /**\n     * Indicates if a given row can fit in the batch.\n     *\n     * @param {object} row The row in question.\n     * @returns {boolean}\n     */\n    canFit(row) {\n        const { maxRows, maxBytes } = this.batchOptions;\n        return (this.rows.length < maxRows &&\n            this.bytes + Buffer.byteLength(JSON.stringify(row)) <= maxBytes);\n    }\n    /**\n     * Checks to see if this batch is at the maximum allowed payload size.\n     *\n     * @returns {boolean}\n     */\n    isAtMax() {\n        const { maxRows, maxBytes } = exports.BATCH_LIMITS;\n        return this.rows.length >= maxRows || this.bytes >= maxBytes;\n    }\n    /**\n     * Indicates if the batch is at capacity.\n     *\n     * @returns {boolean}\n     */\n    isFull() {\n        const { maxRows, maxBytes } = this.batchOptions;\n        return this.rows.length >= maxRows || this.bytes >= maxBytes;\n    }\n}\nexports.RowBatch = RowBatch;\n//# sourceMappingURL=rowBatch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvcm93QmF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsb0JBQW9CO0FBQ3ZDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMva2Fpc2VpL0Rlc2t0b3AvbS10cmFjZXItYWkvbm9kZV9tb2R1bGVzL0Bnb29nbGUtY2xvdWQvYmlncXVlcnkvYnVpbGQvc3JjL3Jvd0JhdGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm93QmF0Y2ggPSBleHBvcnRzLkJBVENIX0xJTUlUUyA9IHZvaWQgMDtcbmV4cG9ydHMuQkFUQ0hfTElNSVRTID0ge1xuICAgIG1heEJ5dGVzOiA5ICogMTAyNCAqIDEwMjQsXG4gICAgbWF4Um93czogNTAwMDAsXG59O1xuLyoqXG4gKiBDYWxsIHVzZWQgdG8gaGVscCBiYXRjaCByb3dzLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtCYXRjaEluc2VydE9wdGlvbnN9IG9wdGlvbnMgVGhlIGJhdGNoaW5nIG9wdGlvbnMuXG4gKi9cbmNsYXNzIFJvd0JhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmF0Y2hPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm93IHRvIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJvdyBUaGUgcm93IHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0ge0luc2VydFJvd3NDYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFkZChyb3csIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucm93cy5wdXNoKHJvdyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmJ5dGVzICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KHJvdykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiByb3cgY2FuIGZpdCBpbiB0aGUgYmF0Y2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcm93IFRoZSByb3cgaW4gcXVlc3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuRml0KHJvdykge1xuICAgICAgICBjb25zdCB7IG1heFJvd3MsIG1heEJ5dGVzIH0gPSB0aGlzLmJhdGNoT3B0aW9ucztcbiAgICAgICAgcmV0dXJuICh0aGlzLnJvd3MubGVuZ3RoIDwgbWF4Um93cyAmJlxuICAgICAgICAgICAgdGhpcy5ieXRlcyArIEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KHJvdykpIDw9IG1heEJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGlzIGJhdGNoIGlzIGF0IHRoZSBtYXhpbXVtIGFsbG93ZWQgcGF5bG9hZCBzaXplLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBdE1heCgpIHtcbiAgICAgICAgY29uc3QgeyBtYXhSb3dzLCBtYXhCeXRlcyB9ID0gZXhwb3J0cy5CQVRDSF9MSU1JVFM7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3MubGVuZ3RoID49IG1heFJvd3MgfHwgdGhpcy5ieXRlcyA+PSBtYXhCeXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBiYXRjaCBpcyBhdCBjYXBhY2l0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRnVsbCgpIHtcbiAgICAgICAgY29uc3QgeyBtYXhSb3dzLCBtYXhCeXRlcyB9ID0gdGhpcy5iYXRjaE9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3MubGVuZ3RoID49IG1heFJvd3MgfHwgdGhpcy5ieXRlcyA+PSBtYXhCeXRlcztcbiAgICB9XG59XG5leHBvcnRzLlJvd0JhdGNoID0gUm93QmF0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3dCYXRjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowBatch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowQueue.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/rowQueue.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2022 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RowQueue = exports.defaultOptions = void 0;\nconst common = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst _1 = __webpack_require__(/*! . */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/index.js\");\nconst rowBatch_1 = __webpack_require__(/*! ./rowBatch */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowBatch.js\");\nexports.defaultOptions = {\n    // The maximum number of rows we'll batch up for insert().\n    maxOutstandingRows: 300,\n    // The maximum size of the total batched up rows for insert().\n    maxOutstandingBytes: 9 * 1024 * 1024,\n    // The maximum time we'll wait to send batched rows, in milliseconds.\n    maxDelayMillis: 10000,\n};\n/**\n * Standard row queue used for inserting rows.\n *\n *\n * @param {Table} table The table.\n * @param {Duplex} dup Row stream.\n * @param {InsertStreamOptions} options Insert and batch options.\n */\nclass RowQueue {\n    constructor(table, dup, options) {\n        this.insertRowsOptions = {};\n        this.table = table;\n        this.stream = dup;\n        this.inFlight = false;\n        const opts = typeof options === 'object' ? options : {};\n        if (opts.insertRowsOptions) {\n            this.insertRowsOptions = opts.insertRowsOptions;\n        }\n        else {\n            this.insertRowsOptions = {};\n        }\n        if (opts.batchOptions) {\n            this.setOptions(opts.batchOptions);\n        }\n        else {\n            this.setOptions();\n        }\n        this.batch = new rowBatch_1.RowBatch(this.batchOptions);\n    }\n    /**\n     * Adds a row to the queue.\n     *\n     * @param {RowMetadata} row The row to insert.\n     * @param {InsertRowsCallback} callback The insert callback.\n     */\n    add(row, callback) {\n        if (!this.insertRowsOptions.raw) {\n            row = {\n                json: _1.Table.encodeValue_(row),\n            };\n            if (this.insertRowsOptions.createInsertId !== false) {\n                row.insertId = uuid.v4();\n            }\n        }\n        if (!this.batch.canFit(row)) {\n            this.insert();\n        }\n        this.batch.add(row, callback);\n        if (this.batch.isFull()) {\n            this.insert();\n        }\n        else if (!this.pending) {\n            const { maxMilliseconds } = this.batchOptions;\n            this.pending = setTimeout(() => {\n                this.insert();\n            }, maxMilliseconds);\n        }\n    }\n    /**\n     * Cancels any pending inserts and calls _insert immediately.\n     */\n    insert(callback) {\n        const { rows, callbacks } = this.batch;\n        this.batch = new rowBatch_1.RowBatch(this.batchOptions);\n        if (this.pending) {\n            clearTimeout(this.pending);\n            delete this.pending;\n        }\n        if (rows.length > 0) {\n            this._insert(rows, callbacks, callback);\n        }\n    }\n    /**\n     * Accepts a batch of rows and inserts them into table.\n     *\n     * @param {object[]} rows The rows to insert.\n     * @param {InsertCallback[]} callbacks The corresponding callback functions.\n     * @param {function} [callback] Callback to be fired when insert is done.\n     */\n    _insert(rows, callbacks, cb) {\n        const json = extend(true, {}, this.insertRowsOptions, { rows });\n        delete json.createInsertId;\n        delete json.partialRetries;\n        delete json.raw;\n        this.table.request({\n            method: 'POST',\n            uri: '/insertAll',\n            json,\n        }, (err, resp) => {\n            const partialFailures = ((resp === null || resp === void 0 ? void 0 : resp.insertErrors) || []).map((insertError) => {\n                return {\n                    errors: insertError.errors.map(error => {\n                        return {\n                            message: error.message,\n                            reason: error.reason,\n                        };\n                    }),\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    row: rows[insertError.index],\n                };\n            });\n            if (partialFailures.length > 0) {\n                err = new common.util.PartialFailureError({\n                    errors: partialFailures,\n                    response: resp,\n                });\n                callbacks.forEach(callback => callback(err, resp));\n                this.stream.emit('error', err);\n            }\n            else {\n                callbacks.forEach(callback => callback(err, resp));\n                this.stream.emit('response', resp);\n                cb === null || cb === void 0 ? void 0 : cb(err, resp);\n            }\n            cb === null || cb === void 0 ? void 0 : cb(err, resp);\n        });\n    }\n    /**\n     * Sets the batching options.\n     *\n     *\n     * @param {RowBatchOptions} [options] The batching options.\n     */\n    setOptions(options = {}) {\n        const defaults = this.getOptionDefaults();\n        const { maxBytes, maxRows, maxMilliseconds } = extend(true, defaults, options);\n        this.batchOptions = {\n            maxBytes: Math.min(maxBytes, rowBatch_1.BATCH_LIMITS.maxBytes),\n            maxRows: Math.min(maxRows, rowBatch_1.BATCH_LIMITS.maxRows),\n            maxMilliseconds: maxMilliseconds,\n        };\n    }\n    getOptionDefaults() {\n        // Return a unique copy to avoid shenanigans.\n        const defaults = {\n            maxBytes: exports.defaultOptions.maxOutstandingBytes,\n            maxRows: exports.defaultOptions.maxOutstandingRows,\n            maxMilliseconds: exports.defaultOptions.maxDelayMillis,\n        };\n        return defaults;\n    }\n}\nexports.RowQueue = RowQueue;\n//# sourceMappingURL=rowQueue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvcm93UXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsc0JBQXNCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywwRkFBc0I7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw4REFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMseUVBQUc7QUFDdEIsbUJBQW1CLG1CQUFPLENBQUMscUZBQVk7QUFDdkMsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEIsTUFBTTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvcm93UXVldWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Sb3dRdWV1ZSA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKFwiQGdvb2dsZS1jbG91ZC9jb21tb25cIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuY29uc3QgdXVpZCA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgXzEgPSByZXF1aXJlKFwiLlwiKTtcbmNvbnN0IHJvd0JhdGNoXzEgPSByZXF1aXJlKFwiLi9yb3dCYXRjaFwiKTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3Mgd2UnbGwgYmF0Y2ggdXAgZm9yIGluc2VydCgpLlxuICAgIG1heE91dHN0YW5kaW5nUm93czogMzAwLFxuICAgIC8vIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHRvdGFsIGJhdGNoZWQgdXAgcm93cyBmb3IgaW5zZXJ0KCkuXG4gICAgbWF4T3V0c3RhbmRpbmdCeXRlczogOSAqIDEwMjQgKiAxMDI0LFxuICAgIC8vIFRoZSBtYXhpbXVtIHRpbWUgd2UnbGwgd2FpdCB0byBzZW5kIGJhdGNoZWQgcm93cywgaW4gbWlsbGlzZWNvbmRzLlxuICAgIG1heERlbGF5TWlsbGlzOiAxMDAwMCxcbn07XG4vKipcbiAqIFN0YW5kYXJkIHJvdyBxdWV1ZSB1c2VkIGZvciBpbnNlcnRpbmcgcm93cy5cbiAqXG4gKlxuICogQHBhcmFtIHtUYWJsZX0gdGFibGUgVGhlIHRhYmxlLlxuICogQHBhcmFtIHtEdXBsZXh9IGR1cCBSb3cgc3RyZWFtLlxuICogQHBhcmFtIHtJbnNlcnRTdHJlYW1PcHRpb25zfSBvcHRpb25zIEluc2VydCBhbmQgYmF0Y2ggb3B0aW9ucy5cbiAqL1xuY2xhc3MgUm93UXVldWUge1xuICAgIGNvbnN0cnVjdG9yKHRhYmxlLCBkdXAsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRSb3dzT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnRhYmxlID0gdGFibGU7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gZHVwO1xuICAgICAgICB0aGlzLmluRmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgPyBvcHRpb25zIDoge307XG4gICAgICAgIGlmIChvcHRzLmluc2VydFJvd3NPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydFJvd3NPcHRpb25zID0gb3B0cy5pbnNlcnRSb3dzT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0Um93c09wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5iYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRzLmJhdGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhdGNoID0gbmV3IHJvd0JhdGNoXzEuUm93QmF0Y2godGhpcy5iYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm93IHRvIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Um93TWV0YWRhdGF9IHJvdyBUaGUgcm93IHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0ge0luc2VydFJvd3NDYWxsYmFja30gY2FsbGJhY2sgVGhlIGluc2VydCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBhZGQocm93LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuaW5zZXJ0Um93c09wdGlvbnMucmF3KSB7XG4gICAgICAgICAgICByb3cgPSB7XG4gICAgICAgICAgICAgICAganNvbjogXzEuVGFibGUuZW5jb2RlVmFsdWVfKHJvdyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5zZXJ0Um93c09wdGlvbnMuY3JlYXRlSW5zZXJ0SWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcm93Lmluc2VydElkID0gdXVpZC52NCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5iYXRjaC5jYW5GaXQocm93KSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhdGNoLmFkZChyb3csIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2guaXNGdWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgY29uc3QgeyBtYXhNaWxsaXNlY29uZHMgfSA9IHRoaXMuYmF0Y2hPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoKTtcbiAgICAgICAgICAgIH0sIG1heE1pbGxpc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbnkgcGVuZGluZyBpbnNlcnRzIGFuZCBjYWxscyBfaW5zZXJ0IGltbWVkaWF0ZWx5LlxuICAgICAqL1xuICAgIGluc2VydChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IHJvd3MsIGNhbGxiYWNrcyB9ID0gdGhpcy5iYXRjaDtcbiAgICAgICAgdGhpcy5iYXRjaCA9IG5ldyByb3dCYXRjaF8xLlJvd0JhdGNoKHRoaXMuYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChyb3dzLCBjYWxsYmFja3MsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgYmF0Y2ggb2Ygcm93cyBhbmQgaW5zZXJ0cyB0aGVtIGludG8gdGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSByb3dzIFRoZSByb3dzIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0ge0luc2VydENhbGxiYWNrW119IGNhbGxiYWNrcyBUaGUgY29ycmVzcG9uZGluZyBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBiZSBmaXJlZCB3aGVuIGluc2VydCBpcyBkb25lLlxuICAgICAqL1xuICAgIF9pbnNlcnQocm93cywgY2FsbGJhY2tzLCBjYikge1xuICAgICAgICBjb25zdCBqc29uID0gZXh0ZW5kKHRydWUsIHt9LCB0aGlzLmluc2VydFJvd3NPcHRpb25zLCB7IHJvd3MgfSk7XG4gICAgICAgIGRlbGV0ZSBqc29uLmNyZWF0ZUluc2VydElkO1xuICAgICAgICBkZWxldGUganNvbi5wYXJ0aWFsUmV0cmllcztcbiAgICAgICAgZGVsZXRlIGpzb24ucmF3O1xuICAgICAgICB0aGlzLnRhYmxlLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmk6ICcvaW5zZXJ0QWxsJyxcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgIH0sIChlcnIsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxGYWlsdXJlcyA9ICgocmVzcCA9PT0gbnVsbCB8fCByZXNwID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwLmluc2VydEVycm9ycykgfHwgW10pLm1hcCgoaW5zZXJ0RXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGluc2VydEVycm9yLmVycm9ycy5tYXAoZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93c1tpbnNlcnRFcnJvci5pbmRleF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBhcnRpYWxGYWlsdXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IGNvbW1vbi51dGlsLlBhcnRpYWxGYWlsdXJlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHBhcnRpYWxGYWlsdXJlcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZXJyLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZXJyLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uZW1pdCgncmVzcG9uc2UnLCByZXNwKTtcbiAgICAgICAgICAgICAgICBjYiA9PT0gbnVsbCB8fCBjYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2IoZXJyLCByZXNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiID09PSBudWxsIHx8IGNiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYihlcnIsIHJlc3ApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYmF0Y2hpbmcgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSb3dCYXRjaE9wdGlvbnN9IFtvcHRpb25zXSBUaGUgYmF0Y2hpbmcgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHRoaXMuZ2V0T3B0aW9uRGVmYXVsdHMoKTtcbiAgICAgICAgY29uc3QgeyBtYXhCeXRlcywgbWF4Um93cywgbWF4TWlsbGlzZWNvbmRzIH0gPSBleHRlbmQodHJ1ZSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhdGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1heEJ5dGVzOiBNYXRoLm1pbihtYXhCeXRlcywgcm93QmF0Y2hfMS5CQVRDSF9MSU1JVFMubWF4Qnl0ZXMpLFxuICAgICAgICAgICAgbWF4Um93czogTWF0aC5taW4obWF4Um93cywgcm93QmF0Y2hfMS5CQVRDSF9MSU1JVFMubWF4Um93cyksXG4gICAgICAgICAgICBtYXhNaWxsaXNlY29uZHM6IG1heE1pbGxpc2Vjb25kcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0T3B0aW9uRGVmYXVsdHMoKSB7XG4gICAgICAgIC8vIFJldHVybiBhIHVuaXF1ZSBjb3B5IHRvIGF2b2lkIHNoZW5hbmlnYW5zLlxuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIG1heEJ5dGVzOiBleHBvcnRzLmRlZmF1bHRPcHRpb25zLm1heE91dHN0YW5kaW5nQnl0ZXMsXG4gICAgICAgICAgICBtYXhSb3dzOiBleHBvcnRzLmRlZmF1bHRPcHRpb25zLm1heE91dHN0YW5kaW5nUm93cyxcbiAgICAgICAgICAgIG1heE1pbGxpc2Vjb25kczogZXhwb3J0cy5kZWZhdWx0T3B0aW9ucy5tYXhEZWxheU1pbGxpcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cbn1cbmV4cG9ydHMuUm93UXVldWUgPSBSb3dRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvd1F1ZXVlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowQueue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/build/src/table.js":
/*!****************************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/build/src/table.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Table = void 0;\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"(rsc)/./node_modules/@google-cloud/common/build/src/index.js\");\nconst paginator_1 = __webpack_require__(/*! @google-cloud/paginator */ \"(rsc)/./node_modules/@google-cloud/paginator/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\");\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst Big = __webpack_require__(/*! big.js */ \"(rsc)/./node_modules/big.js/big.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst is = __webpack_require__(/*! is */ \"(rsc)/./node_modules/is/index.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst streamEvents = __webpack_require__(/*! stream-events */ \"(rsc)/./node_modules/stream-events/index.js\");\nconst uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst _1 = __webpack_require__(/*! . */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/index.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst rowQueue_1 = __webpack_require__(/*! ./rowQueue */ \"(rsc)/./node_modules/@google-cloud/bigquery/build/src/rowQueue.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = __webpack_require__(/*! duplexify */ \"(rsc)/./node_modules/duplexify/index.js\");\n/**\n * The file formats accepted by BigQuery.\n *\n * @type {object}\n * @private\n */\nconst FORMATS = {\n    avro: 'AVRO',\n    csv: 'CSV',\n    export_metadata: 'DATASTORE_BACKUP',\n    json: 'NEWLINE_DELIMITED_JSON',\n    orc: 'ORC',\n    parquet: 'PARQUET',\n};\n/**\n * Table objects are returned by methods such as\n * {@link Dataset#table}, {@link Dataset#createTable}, and\n * {@link Dataset#getTables}.\n *\n * @class\n * @param {Dataset} dataset {@link Dataset} instance.\n * @param {string} id The ID of the table.\n * @param {object} [options] Table options.\n * @param {string} [options.location] The geographic location of the table, by\n *      default this value is inherited from the dataset. This can be used to\n *      configure the location of all jobs created through a table instance. It\n *      cannot be used to set the actual location of the table. This value will\n *      be superseded by any API responses containing location data for the\n *      table.\n *\n * @example\n * ```\n * const {BigQuery} = require('@google-cloud/bigquery');\n * const bigquery = new BigQuery();\n * const dataset = bigquery.dataset('my-dataset');\n *\n * const table = dataset.table('my-table');\n * ```\n */\nclass Table extends common_1.ServiceObject {\n    createReadStream(options) {\n        // placeholder body, overwritten in constructor\n        return new paginator_1.ResourceStream({}, () => { });\n    }\n    constructor(dataset, id, options) {\n        const methods = {\n            /**\n             * @callback CreateTableCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Table} table The table.\n             * @param {object} apiResponse The full API response body.\n             */\n            /**\n             * @typedef {array} CreateTableResponse\n             * @property {Table} 0 The table.\n             * @property {object} 1 The full API response body.\n             */\n            /**\n             * Create a table.\n             *\n             * @method Table#create\n             * @param {object} [options] See {@link Dataset#createTable}.\n             * @param {CreateTableCallback} [callback]\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {Table} callback.table The new {@link Table}.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<CreateTableResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             *\n             * const table = dataset.table('my-table');\n             *\n             * table.create((err, table, apiResponse) => {\n             *   if (!err) {\n             *     // The table was created successfully.\n             *   }\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * table.create().then((data) => {\n             *   const table = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            create: true,\n            /**\n             * @callback DeleteTableCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} DeleteTableResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * Delete a table and all its data.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/v2/tables/delete| Tables: delete API Documentation}\n             *\n             * @method Table#delete\n             * @param {DeleteTableCallback} [callback]\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<DeleteTableResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             *\n             * const table = dataset.table('my-table');\n             *\n             * table.delete((err, apiResponse) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * table.delete().then((data) => {\n             *   const apiResponse = data[0];\n             * });\n             * ```\n             */\n            delete: true,\n            /**\n             * @callback TableExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Indicates if the table exists.\n             */\n            /**\n             * @typedef {array} TableExistsCallback\n             * @property {boolean} 0 Indicates if the table exists.\n             */\n            /**\n             * Check if the table exists.\n             *\n             * @method Table#exists\n             * @param {TableExistsCallback} [callback]\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {boolean} callback.exists Whether the table exists or not.\n             * @returns {Promise<TableExistsCallback>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             *\n             * const table = dataset.table('my-table');\n             *\n             * table.exists((err, exists) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * table.exists().then((data) => {\n             *   const exists = data[0];\n             * });\n             * ```\n             */\n            exists: true,\n            /**\n             * @callback GetTableCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Table} table The table.\n             * @param {object} apiResponse The full API response body.\n             */\n            /**\n             * @typedef {array} GetTableResponse\n             * @property {Table} 0 The table.\n             * @property {object} 1 The full API response body.\n             */\n            /**\n             * Get a table if it exists.\n             *\n             * You may optionally use this to \"get or create\" an object by providing\n             * an object with `autoCreate` set to `true`. Any extra configuration that\n             * is normally required for the `create` method must be contained within\n             * this object as well.\n             *\n             * If you wish to get a selection of metadata instead of the full table metadata\n             * (retrieved by both Table#get by default and by Table#getMetadata), use\n             * the `options` parameter to set the `view` and/or `selectedFields` query parameters.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get#TableMetadataView| Tables.get and TableMetadataView }\n             *\n             * @method Table#get\n             * @param {options} [options] Configuration object.\n             * @param {boolean} [options.autoCreate=false] Automatically create the\n             *     object if it does not exist.\n             * @param {function} [callback]\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {Table} callback.table The {@link Table}.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<GetTableResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             *\n             * const table = dataset.table('my-table');\n             *\n             * const options = {\n             *   view: \"BASIC\"\n             * }\n             *\n             * table.get((err, table, apiResponse) => {\n             *   // `table.metadata` has been populated.\n             * });\n             *\n             * table.get(options, (err, table, apiResponse) => {\n             *   // A selection of `table.metadata` has been populated\n             * })\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * table.get().then((data) => {\n             *   const table = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            get: true,\n            /**\n             * @callback GetTableMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The table metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} GetTableMetadataResponse\n             * @property {object} 0 The table metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * Return the metadata associated with the Table.\n             *\n             * See {@link https://cloud.google.com/bigquery/docs/reference/v2/tables/get| Tables: get API Documentation}\n             *\n             * @method Table#getMetadata\n             * @param {GetTableMetadataCallback} [callback] The callback function.\n             * @param {?error} callback.err An error returned while making this\n             *     request.\n             * @param {object} callback.metadata The metadata of the Table.\n             * @param {object} callback.apiResponse The full API response.\n             * @returns {Promise<GetTableMetadataResponse>}\n             *\n             * @example\n             * ```\n             * const {BigQuery} = require('@google-cloud/bigquery');\n             * const bigquery = new BigQuery();\n             * const dataset = bigquery.dataset('my-dataset');\n             *\n             * const table = dataset.table('my-table');\n             *\n             * table.getMetadata((err, metadata, apiResponse) => {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * table.getMetadata().then((data) => {\n             *   const metadata = data[0];\n             *   const apiResponse = data[1];\n             * });\n             * ```\n             */\n            getMetadata: true,\n        };\n        super({\n            parent: dataset,\n            baseUrl: '/tables',\n            id,\n            createMethod: dataset.createTable.bind(dataset),\n            methods,\n        });\n        if (options && options.location) {\n            this.location = options.location;\n        }\n        this.bigQuery = dataset.bigQuery;\n        this.dataset = dataset;\n        // Catch all for read-modify-write cycle\n        // https://cloud.google.com/bigquery/docs/api-performance#read-patch-write\n        this.interceptors.push({\n            request: (reqOpts) => {\n                if (reqOpts.method === 'PATCH' && reqOpts.json.etag) {\n                    reqOpts.headers = reqOpts.headers || {};\n                    reqOpts.headers['If-Match'] = reqOpts.json.etag;\n                }\n                return reqOpts;\n            },\n        });\n        /**\n         * Create a readable stream of the rows of data in your table. This method\n         * is simply a wrapper around {@link Table#getRows}.\n         *\n         * See {@link https://cloud.google.com/bigquery/docs/reference/v2/tabledata/list| Tabledata: list API Documentation}\n         *\n         * @returns {ReadableStream}\n         *\n         * @example\n         * ```\n         * const {BigQuery} = require('@google-cloud/bigquery');\n         * const bigquery = new BigQuery();\n         * const dataset = bigquery.dataset('my-dataset');\n         * const table = dataset.table('my-table');\n         *\n         * table.createReadStream(options)\n         *   .on('error', console.error)\n         *   .on('data', row => {})\n         *   .on('end', function() {\n         *     // All rows have been retrieved.\n         *   });\n         *\n         * //-\n         * // If you anticipate many results, you can end a stream early to prevent\n         * // unnecessary processing and API requests.\n         * //-\n         * table.createReadStream()\n         *   .on('data', function(row) {\n         *     this.end();\n         *   });\n         * ```\n         */\n        this.createReadStream = paginator_1.paginator.streamify('getRows');\n    }\n    /**\n     * Convert a comma-separated name:type string to a table schema object.\n     *\n     * @static\n     * @private\n     *\n     * @param {string} str Comma-separated schema string.\n     * @returns {object} Table schema in the format the API expects.\n     */\n    static createSchemaFromString_(str) {\n        return str.split(/\\s*,\\s*/).reduce((acc, pair) => {\n            acc.fields.push({\n                name: pair.split(':')[0].trim(),\n                type: (pair.split(':')[1] || 'STRING').toUpperCase().trim(),\n            });\n            return acc;\n        }, {\n            fields: [],\n        });\n    }\n    /**\n     * Convert a row entry from native types to their encoded types that the API\n     * expects.\n     *\n     * @static\n     * @private\n     *\n     * @param {*} value The value to be converted.\n     * @returns {*} The converted value.\n     */\n    static encodeValue_(value) {\n        var _a;\n        if (typeof value === 'undefined' || value === null) {\n            return null;\n        }\n        if (value instanceof Buffer) {\n            return value.toString('base64');\n        }\n        if (value instanceof Big) {\n            return value.toFixed();\n        }\n        const customTypeConstructorNames = [\n            'BigQueryDate',\n            'BigQueryDatetime',\n            'BigQueryInt',\n            'BigQueryTime',\n            'BigQueryTimestamp',\n            'BigQueryRange',\n            'Geography',\n        ];\n        const constructorName = (_a = value.constructor) === null || _a === void 0 ? void 0 : _a.name;\n        const isCustomType = customTypeConstructorNames.indexOf(constructorName) > -1;\n        if (isCustomType) {\n            return value.value;\n        }\n        if (is.date(value)) {\n            return value.toJSON();\n        }\n        if (is.array(value)) {\n            return value.map(Table.encodeValue_);\n        }\n        if (typeof value === 'object') {\n            return Object.keys(value).reduce((acc, key) => {\n                acc[key] = Table.encodeValue_(value[key]);\n                return acc;\n            }, {});\n        }\n        return value;\n    }\n    /**\n     * @private\n     */\n    static formatMetadata_(options) {\n        const body = extend(true, {}, options);\n        if (options.name) {\n            body.friendlyName = options.name;\n            delete body.name;\n        }\n        if (is.string(options.schema)) {\n            body.schema = Table.createSchemaFromString_(options.schema);\n        }\n        if (is.array(options.schema)) {\n            body.schema = {\n                fields: options.schema,\n            };\n        }\n        if (body.schema && body.schema.fields) {\n            body.schema.fields = body.schema.fields.map(field => {\n                if (field.fields) {\n                    field.type = 'RECORD';\n                }\n                return field;\n            });\n        }\n        if (is.string(options.partitioning)) {\n            body.timePartitioning = {\n                type: options.partitioning.toUpperCase(),\n            };\n            delete body.partitioning;\n        }\n        if (is.string(options.view)) {\n            body.view = {\n                query: options.view,\n                useLegacySql: false,\n            };\n        }\n        return body;\n    }\n    copy(destination, metadataOrCallback, cb) {\n        const metadata = typeof metadataOrCallback === 'object' ? metadataOrCallback : {};\n        const callback = typeof metadataOrCallback === 'function' ? metadataOrCallback : cb;\n        this.createCopyJob(destination, metadata, (err, job, resp) => {\n            if (err) {\n                callback(err, resp);\n                return;\n            }\n            job.on('error', callback).on('complete', (metadata) => {\n                callback(null, metadata);\n            });\n        });\n    }\n    copyFrom(sourceTables, metadataOrCallback, cb) {\n        const metadata = typeof metadataOrCallback === 'object' ? metadataOrCallback : {};\n        const callback = typeof metadataOrCallback === 'function' ? metadataOrCallback : cb;\n        this.createCopyFromJob(sourceTables, metadata, (err, job, resp) => {\n            if (err) {\n                callback(err, resp);\n                return;\n            }\n            job.on('error', callback).on('complete', metadata => {\n                callback(null, metadata);\n            });\n        });\n    }\n    createCopyJob(destination, metadataOrCallback, cb) {\n        if (!(destination instanceof Table)) {\n            throw new Error('Destination must be a Table object.');\n        }\n        const metadata = typeof metadataOrCallback === 'object'\n            ? metadataOrCallback\n            : {};\n        const callback = typeof metadataOrCallback === 'function' ? metadataOrCallback : cb;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const body = {\n            configuration: {\n                copy: extend(true, metadata, {\n                    destinationTable: {\n                        datasetId: destination.dataset.id,\n                        projectId: destination.dataset.projectId,\n                        tableId: destination.id,\n                    },\n                    sourceTable: {\n                        datasetId: this.dataset.id,\n                        projectId: this.dataset.projectId,\n                        tableId: this.id,\n                    },\n                }),\n            },\n        };\n        if (metadata.jobPrefix) {\n            body.jobPrefix = metadata.jobPrefix;\n            delete metadata.jobPrefix;\n        }\n        if (this.location) {\n            body.location = this.location;\n        }\n        if (metadata.jobId) {\n            body.jobId = metadata.jobId;\n            delete metadata.jobId;\n        }\n        this.bigQuery.createJob(body, callback);\n    }\n    createCopyFromJob(source, metadataOrCallback, cb) {\n        const sourceTables = arrify(source);\n        sourceTables.forEach(sourceTable => {\n            if (!(sourceTable instanceof Table)) {\n                throw new Error('Source must be a Table object.');\n            }\n        });\n        const metadata = typeof metadataOrCallback === 'object' ? metadataOrCallback : {};\n        const callback = typeof metadataOrCallback === 'function' ? metadataOrCallback : cb;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const body = {\n            configuration: {\n                copy: extend(true, metadata, {\n                    destinationTable: {\n                        datasetId: this.dataset.id,\n                        projectId: this.dataset.projectId,\n                        tableId: this.id,\n                    },\n                    sourceTables: sourceTables.map(sourceTable => {\n                        return {\n                            datasetId: sourceTable.dataset.id,\n                            projectId: sourceTable.dataset.projectId,\n                            tableId: sourceTable.id,\n                        };\n                    }),\n                }),\n            },\n        };\n        if (metadata.jobPrefix) {\n            body.jobPrefix = metadata.jobPrefix;\n            delete metadata.jobPrefix;\n        }\n        if (this.location) {\n            body.location = this.location;\n        }\n        if (metadata.jobId) {\n            body.jobId = metadata.jobId;\n            delete metadata.jobId;\n        }\n        this.bigQuery.createJob(body, callback);\n    }\n    createExtractJob(destination, optionsOrCallback, cb) {\n        let options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        options = extend(true, options, {\n            destinationUris: arrify(destination).map(dest => {\n                if (!common_1.util.isCustomType(dest, 'storage/file')) {\n                    throw new Error('Destination must be a File object.');\n                }\n                // If no explicit format was provided, attempt to find a match from the\n                // file's extension. If no match, don't set, and default upstream to\n                // CSV.\n                const format = path.extname(dest.name).substr(1).toLowerCase();\n                if (!options.destinationFormat && !options.format && FORMATS[format]) {\n                    options.destinationFormat = FORMATS[format];\n                }\n                return 'gs://' + dest.bucket.name + '/' + dest.name;\n            }),\n        });\n        if (options.format) {\n            options.format = options.format.toLowerCase();\n            if (FORMATS[options.format]) {\n                options.destinationFormat = FORMATS[options.format];\n                delete options.format;\n            }\n            else {\n                throw new Error('Destination format not recognized: ' + options.format);\n            }\n        }\n        if (options.gzip) {\n            options.compression = 'GZIP';\n            delete options.gzip;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const body = {\n            configuration: {\n                extract: extend(true, options, {\n                    sourceTable: {\n                        datasetId: this.dataset.id,\n                        projectId: this.dataset.projectId,\n                        tableId: this.id,\n                    },\n                }),\n            },\n        };\n        if (options.jobPrefix) {\n            body.jobPrefix = options.jobPrefix;\n            delete options.jobPrefix;\n        }\n        if (this.location) {\n            body.location = this.location;\n        }\n        if (options.jobId) {\n            body.jobId = options.jobId;\n            delete options.jobId;\n        }\n        this.bigQuery.createJob(body, callback);\n    }\n    createLoadJob(source, metadataOrCallback, cb) {\n        const metadata = typeof metadataOrCallback === 'object' ? metadataOrCallback : {};\n        const callback = typeof metadataOrCallback === 'function' ? metadataOrCallback : cb;\n        this._createLoadJob(source, metadata).then(([resp]) => callback(null, resp, resp.metadata), err => callback(err));\n    }\n    /**\n     * @param {string | File | File[]} source\n     * @param {JobLoadMetadata} metadata\n     * @returns {Promise<JobResponse>}\n     * @private\n     */\n    async _createLoadJob(source, metadata) {\n        if (metadata.format) {\n            metadata.sourceFormat = FORMATS[metadata.format.toLowerCase()];\n            delete metadata.format;\n        }\n        if (this.location) {\n            metadata.location = this.location;\n        }\n        if (typeof source === 'string') {\n            // A path to a file was given. If a sourceFormat wasn't specified, try to\n            // find a match from the file's extension.\n            const detectedFormat = FORMATS[path.extname(source).substr(1).toLowerCase()];\n            if (!metadata.sourceFormat && detectedFormat) {\n                metadata.sourceFormat = detectedFormat;\n            }\n            // Read the file into a new write stream.\n            const jobWritable = fs\n                .createReadStream(source)\n                .pipe(this.createWriteStream_(metadata));\n            const [jobResponse] = (await (0, events_1.once)(jobWritable, 'job'));\n            return [jobResponse, jobResponse.metadata];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const body = {\n            configuration: {\n                load: {\n                    destinationTable: {\n                        projectId: this.dataset.projectId,\n                        datasetId: this.dataset.id,\n                        tableId: this.id,\n                    },\n                },\n            },\n        };\n        if (metadata.jobPrefix) {\n            body.jobPrefix = metadata.jobPrefix;\n            delete metadata.jobPrefix;\n        }\n        if (metadata.location) {\n            body.location = metadata.location;\n            delete metadata.location;\n        }\n        if (metadata.jobId) {\n            body.jobId = metadata.jobId;\n            delete metadata.jobId;\n        }\n        extend(true, body.configuration.load, metadata, {\n            sourceUris: arrify(source).map(src => {\n                if (!common_1.util.isCustomType(src, 'storage/file')) {\n                    throw new Error('Source must be a File object.');\n                }\n                // If no explicit format was provided, attempt to find a match from\n                // the file's extension. If no match, don't set, and default upstream\n                // to CSV.\n                const format = FORMATS[path.extname(src.name).substr(1).toLowerCase()];\n                if (!metadata.sourceFormat && format) {\n                    body.configuration.load.sourceFormat = format;\n                }\n                return 'gs://' + src.bucket.name + '/' + src.name;\n            }),\n        });\n        return this.bigQuery.createJob(body);\n    }\n    createQueryJob(options, callback) {\n        return this.dataset.createQueryJob(options, callback);\n    }\n    /**\n     * Run a query scoped to your dataset as a readable object stream.\n     *\n     * See {@link BigQuery#createQueryStream} for full documentation of this\n     * method.\n     *\n     * @param {object} query See {@link BigQuery#createQueryStream} for full\n     *     documentation of this method.\n     * @returns {stream} See {@link BigQuery#createQueryStream} for full\n     *     documentation of this method.\n     */\n    createQueryStream(query) {\n        return this.dataset.createQueryStream(query);\n    }\n    /**\n     * Creates a write stream. Unlike the public version, this will not\n     * automatically poll the underlying job.\n     *\n     * @private\n     *\n     * @param {string|object} [metadata] Metadata to set with the load operation.\n     *     The metadata object should be in the format of the\n     *     {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/Job#JobConfigurationLoad| `configuration.load`}\n     * property of a Jobs resource. If a string is given, it will be used\n     * as the filetype.\n     * @param {string} [metadata.jobId] Custom job id.\n     * @param {string} [metadata.jobPrefix] Prefix to apply to the job id.\n     * @returns {WritableStream}\n     */\n    createWriteStream_(metadata) {\n        metadata = metadata || {};\n        if (typeof metadata === 'string') {\n            metadata = {\n                sourceFormat: FORMATS[metadata.toLowerCase()],\n            };\n        }\n        if (typeof metadata.schema === 'string') {\n            metadata.schema = Table.createSchemaFromString_(metadata.schema);\n        }\n        metadata = extend(true, {\n            destinationTable: {\n                projectId: this.dataset.projectId,\n                datasetId: this.dataset.id,\n                tableId: this.id,\n            },\n        }, metadata);\n        let jobId = metadata.jobId || uuid.v4();\n        if (metadata.jobId) {\n            delete metadata.jobId;\n        }\n        if (metadata.jobPrefix) {\n            jobId = metadata.jobPrefix + jobId;\n            delete metadata.jobPrefix;\n        }\n        const dup = streamEvents(duplexify());\n        dup.once('writing', () => {\n            common_1.util.makeWritableStream(dup, {\n                makeAuthenticatedRequest: this.bigQuery.makeAuthenticatedRequest,\n                metadata: {\n                    configuration: {\n                        load: metadata,\n                    },\n                    jobReference: {\n                        jobId,\n                        projectId: this.dataset.projectId,\n                        location: this.location,\n                    },\n                },\n                request: {\n                    uri: `${this.bigQuery.apiEndpoint}/upload/bigquery/v2/projects/${this.dataset.projectId}/jobs`,\n                },\n            }, \n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (data) => {\n                const job = this.bigQuery.job(data.jobReference.jobId, {\n                    location: data.jobReference.location,\n                    projectId: data.jobReference.projectId,\n                });\n                job.metadata = data;\n                dup.emit('job', job);\n            });\n        });\n        return dup;\n    }\n    /**\n     * Load data into your table from a readable stream of AVRO, CSV, JSON, ORC,\n     * or PARQUET data.\n     *\n     * See {@link https://cloud.google.com/bigquery/docs/reference/v2/jobs/insert| Jobs: insert API Documentation}\n     *\n     * @param {string|object} [metadata] Metadata to set with the load operation.\n     *     The metadata object should be in the format of the\n     *     {@link https://cloud.google.com/bigquery/docs/reference/rest/v2/Job#JobConfigurationLoad| `configuration.load`}\n     * property of a Jobs resource. If a string is given,\n     * it will be used as the filetype.\n     * @param {string} [metadata.jobId] Custom job id.\n     * @param {string} [metadata.jobPrefix] Prefix to apply to the job id.\n     * @returns {WritableStream}\n     *\n     * @throws {Error} If source format isn't recognized.\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const dataset = bigquery.dataset('my-dataset');\n     * const table = dataset.table('my-table');\n     *\n     * //-\n     * // Load data from a CSV file.\n     * //-\n     * const request = require('request');\n     *\n     * const csvUrl = 'http://goo.gl/kSE7z6';\n     *\n     * const metadata = {\n     *   allowJaggedRows: true,\n     *   skipLeadingRows: 1\n     * };\n     *\n     * request.get(csvUrl)\n     *   .pipe(table.createWriteStream(metadata))\n     *   .on('job', (job) => {\n     *     // `job` is a Job object that can be used to check the status of the\n     *     // request.\n     *   })\n     *   .on('complete', (job) => {\n     *     // The job has completed successfully.\n     *   });\n     *\n     * //-\n     * // Load data from a JSON file.\n     * //-\n     * const fs = require('fs');\n     *\n     * fs.createReadStream('./test/testdata/testfile.json')\n     *   .pipe(table.createWriteStream('json'))\n     *   .on('job', (job) => {\n     *     // `job` is a Job object that can be used to check the status of the\n     *     // request.\n     *   })\n     *   .on('complete', (job) => {\n     *     // The job has completed successfully.\n     *   });\n     * ```\n     */\n    createWriteStream(metadata) {\n        const stream = this.createWriteStream_(metadata);\n        stream.on('prefinish', () => {\n            stream.cork();\n        });\n        stream.on('job', (job) => {\n            job\n                .on('error', err => {\n                stream.destroy(err);\n            })\n                .on('complete', () => {\n                stream.emit('complete', job);\n                stream.uncork();\n            });\n        });\n        return stream;\n    }\n    extract(destination, optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        this.createExtractJob(destination, options, (err, job, resp) => {\n            if (err) {\n                callback(err, resp);\n                return;\n            }\n            job.on('error', callback).on('complete', metadata => {\n                callback(null, metadata);\n            });\n        });\n    }\n    /**\n     * Retrieves table data from a specified set of rows. The rows are returned to\n     * your callback as an array of objects matching your table's schema.\n     *\n     * See {@link https://cloud.google.com/bigquery/docs/reference/v2/tabledata/list| Tabledata: list API Documentation}\n     *\n     * @param {object} [options] The configuration object.\n     * @param {boolean} [options.autoPaginate=true] Have pagination handled\n     *     automatically.\n     * @param {number} [options.maxApiCalls] Maximum number of API calls to make.\n     * @param {number} [options.maxResults] Maximum number of results to return.\n     * @param {boolean|IntegerTypeCastOptions} [options.wrapIntegers=false] Wrap values\n     *     of 'INT64' type in {@link BigQueryInt} objects.\n     *     If a `boolean`, this will wrap values in {@link BigQueryInt} objects.\n     *     If an `object`, this will return a value returned by\n     *     `wrapIntegers.integerTypeCastFunction`.\n     * @param {RowsCallback} [callback] The callback function. If `autoPaginate`\n     *     is set to false a {@link ManualQueryResultsCallback} should be used.\n     * @param {?error} callback.err An error returned while making this request\n     * @param {array} callback.rows The table data from specified set of rows.\n     * @returns {Promise<RowsResponse>}\n     *\n     * @example\n     * ```\n     * const {BigQuery} = require('@google-cloud/bigquery');\n     * const bigquery = new BigQuery();\n     * const dataset = bigquery.dataset('my-dataset');\n     * const table = dataset.table('my-table');\n     *\n     * table.getRows((err, rows) => {\n     *   if (!err) {\n     *     // rows is an array of results.\n     *   }\n     * });\n     *\n     * //-\n     * // To control how many API requests are made and page through the results\n     * // manually, set `autoPaginate` to `false`.\n     * //-\n     * function manualPaginationCallback(err, rows, nextQuery, apiResponse) {\n     *   if (nextQuery) {\n     *     // More results exist.\n     *     table.getRows(nextQuery, manualPaginationCallback);\n     *   }\n     * }\n     *\n     * table.getRows({\n     *   autoPaginate: false\n     * }, manualPaginationCallback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * table.getRows().then((data) => {\n     *   const rows = data[0];\n     *   });\n     * ```\n     */\n    getRows(optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        const wrapIntegers = options.wrapIntegers ? options.wrapIntegers : false;\n        delete options.wrapIntegers;\n        const parseJSON = options.parseJSON ? options.parseJSON : false;\n        delete options.parseJSON;\n        const selectedFields = options.selectedFields\n            ? options.selectedFields.split(',')\n            : [];\n        const onComplete = (err, rows, nextQuery, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            rows = _1.BigQuery.mergeSchemaWithRows_(this.metadata.schema, rows || [], {\n                wrapIntegers,\n                selectedFields,\n                parseJSON,\n            });\n            callback(null, rows, nextQuery, resp);\n        };\n        const qs = extend({\n            'formatOptions.useInt64Timestamp': true,\n        }, options);\n        this.request({\n            uri: '/data',\n            qs,\n        }, (err, resp) => {\n            if (err) {\n                onComplete(err, null, null, resp);\n                return;\n            }\n            let nextQuery = null;\n            if (resp.pageToken) {\n                nextQuery = Object.assign({}, qs, {\n                    pageToken: resp.pageToken,\n                });\n            }\n            if (resp.rows && resp.rows.length > 0 && !this.metadata.schema) {\n                // We don't know the schema for this table yet. Do a quick stat.\n                this.getMetadata((err, metadata, apiResponse) => {\n                    if (err) {\n                        onComplete(err, null, null, apiResponse);\n                        return;\n                    }\n                    onComplete(null, resp.rows, nextQuery, resp);\n                });\n                return;\n            }\n            onComplete(null, resp.rows, nextQuery, resp);\n        });\n    }\n    insert(rows, optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object'\n            ? optionsOrCallback\n            : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        const promise = this._insertAndCreateTable(rows, options);\n        if (callback) {\n            promise.then(resp => callback(null, resp), err => callback(err, null));\n        }\n        else {\n            return promise.then(r => [r]);\n        }\n    }\n    /**\n     * Insert rows with retries, but will create the table if not exists.\n     *\n     * @param {RowMetadata | RowMetadata[]} rows\n     * @param {InsertRowsOptions} options\n     * @returns {Promise<bigquery.ITableDataInsertAllResponse | bigquery.ITable>}\n     * @private\n     */\n    async _insertAndCreateTable(rows, options) {\n        const { schema } = options;\n        const delay = 60000;\n        try {\n            return await this._insertWithRetry(rows, options);\n        }\n        catch (err) {\n            if (err.code !== 404 || !schema) {\n                throw err;\n            }\n        }\n        try {\n            await this.create({ schema });\n        }\n        catch (err) {\n            if (err.code !== 409) {\n                throw err;\n            }\n        }\n        // table creation after failed access is subject to failure caching and\n        // eventual consistency, see:\n        // https://github.com/googleapis/google-cloud-python/issues/4553#issuecomment-350110292\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this._insertAndCreateTable(rows, options);\n    }\n    /**\n     * This method will attempt to insert rows while retrying any partial failures\n     * that occur along the way. Because partial insert failures are returned\n     * differently, we can't depend on our usual retry strategy.\n     *\n     * @private\n     *\n     * @param {RowMetadata|RowMetadata[]} rows The rows to insert.\n     * @param {InsertRowsOptions} options Insert options.\n     * @returns {Promise<bigquery.ITableDataInsertAllResponse>}\n     */\n    async _insertWithRetry(rows, options) {\n        const { partialRetries = 3 } = options;\n        let error;\n        const maxAttempts = Math.max(partialRetries, 0) + 1;\n        for (let attempts = 0; attempts < maxAttempts; attempts++) {\n            try {\n                return await this._insert(rows, options);\n            }\n            catch (e) {\n                error = e;\n                rows = (e.errors || [])\n                    .filter(err => !!err.row)\n                    .map(err => err.row);\n                if (!rows.length) {\n                    break;\n                }\n            }\n        }\n        throw error;\n    }\n    /**\n     * This method does the bulk of the work for processing options and making the\n     * network request.\n     *\n     * @private\n     *\n     * @param {RowMetadata|RowMetadata[]} rows The rows to insert.\n     * @param {InsertRowsOptions} options Insert options.\n     * @returns {Promise<bigquery.ITableDataInsertAllResponse>}\n     */\n    async _insert(rows, options) {\n        rows = arrify(rows);\n        if (!rows.length) {\n            throw new Error('You must provide at least 1 row to be inserted.');\n        }\n        const json = extend(true, {}, options, { rows });\n        if (!options.raw) {\n            json.rows = rows.map((row) => {\n                const encoded = {\n                    json: Table.encodeValue_(row),\n                };\n                if (options.createInsertId !== false) {\n                    encoded.insertId = uuid.v4();\n                }\n                return encoded;\n            });\n        }\n        delete json.createInsertId;\n        delete json.partialRetries;\n        delete json.raw;\n        delete json.schema;\n        const [resp] = await this.request({\n            method: 'POST',\n            uri: '/insertAll',\n            json,\n        });\n        const partialFailures = (resp.insertErrors || []).map((insertError) => {\n            return {\n                errors: insertError.errors.map(error => {\n                    return {\n                        message: error.message,\n                        reason: error.reason,\n                    };\n                }),\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                row: rows[insertError.index],\n            };\n        });\n        if (partialFailures.length > 0) {\n            throw new common_1.util.PartialFailureError({\n                errors: partialFailures,\n                response: resp,\n            });\n        }\n        return resp;\n    }\n    createInsertStream(options) {\n        options = typeof options === 'object' ? options : {};\n        const dup = new stream_1.Duplex({ objectMode: true });\n        dup._write = (chunk, encoding, cb) => {\n            this.rowQueue.add(chunk, () => { });\n            cb();\n        };\n        this.rowQueue = new rowQueue_1.RowQueue(this, dup, options);\n        return dup;\n    }\n    load(source, metadataOrCallback, cb) {\n        const metadata = typeof metadataOrCallback === 'object' ? metadataOrCallback : {};\n        const callback = typeof metadataOrCallback === 'function' ? metadataOrCallback : cb;\n        this.createLoadJob(source, metadata, (err, job, resp) => {\n            if (err) {\n                callback(err, resp);\n                return;\n            }\n            job.on('error', callback).on('complete', metadata => {\n                callback(null, metadata);\n            });\n        });\n    }\n    query(query, callback) {\n        if (typeof query === 'string') {\n            query = {\n                query,\n            };\n        }\n        this.dataset.query(query, callback);\n    }\n    setMetadata(metadata, callback) {\n        const body = Table.formatMetadata_(metadata);\n        super.setMetadata(body, callback);\n    }\n    getIamPolicy(optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        if (typeof options.requestedPolicyVersion === 'number' &&\n            options.requestedPolicyVersion !== 1) {\n            throw new Error('Only IAM policy version 1 is supported.');\n        }\n        const json = extend(true, {}, { options });\n        this.request({\n            method: 'POST',\n            uri: '/:getIamPolicy',\n            json,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            callback(null, resp);\n        });\n    }\n    setIamPolicy(policy, optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        if (policy.version && policy.version !== 1) {\n            throw new Error('Only IAM policy version 1 is supported.');\n        }\n        const json = extend(true, {}, options, { policy });\n        this.request({\n            method: 'POST',\n            uri: '/:setIamPolicy',\n            json,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            callback(null, resp);\n        });\n    }\n    testIamPermissions(permissions, callback) {\n        permissions = arrify(permissions);\n        const json = extend(true, {}, { permissions });\n        this.request({\n            method: 'POST',\n            uri: '/:testIamPermissions',\n            json,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            callback(null, resp);\n        });\n    }\n}\nexports.Table = Table;\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\npaginator_1.paginator.extend(Table, ['getRows']);\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n(0, promisify_1.promisifyAll)(Table);\n//# sourceMappingURL=table.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvdGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLDBGQUFzQjtBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBeUI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsZ0dBQXlCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixZQUFZLG1CQUFPLENBQUMsa0RBQVE7QUFDNUIsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyw0Q0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IscUJBQXFCLG1CQUFPLENBQUMsa0VBQWU7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLDhEQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyx5RUFBRztBQUN0QixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBWTtBQUN2QztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQixHQUFHLDBCQUEwQjtBQUNyRCxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0EsV0FBVyxTQUFTLFNBQVMsZUFBZTtBQUM1QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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b2dsZS1jbG91ZC9iaWdxdWVyeS9idWlsZC9zcmMvdGFibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAyMDE0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWJsZSA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIkBnb29nbGUtY2xvdWQvY29tbW9uXCIpO1xuY29uc3QgcGFnaW5hdG9yXzEgPSByZXF1aXJlKFwiQGdvb2dsZS1jbG91ZC9wYWdpbmF0b3JcIik7XG5jb25zdCBwcm9taXNpZnlfMSA9IHJlcXVpcmUoXCJAZ29vZ2xlLWNsb3VkL3Byb21pc2lmeVwiKTtcbmNvbnN0IGFycmlmeSA9IHJlcXVpcmUoXCJhcnJpZnlcIik7XG5jb25zdCBCaWcgPSByZXF1aXJlKFwiYmlnLmpzXCIpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZShcImV4dGVuZFwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgaXMgPSByZXF1aXJlKFwiaXNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBzdHJlYW1FdmVudHMgPSByZXF1aXJlKFwic3RyZWFtLWV2ZW50c1wiKTtcbmNvbnN0IHV1aWQgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IF8xID0gcmVxdWlyZShcIi5cIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCByb3dRdWV1ZV8xID0gcmVxdWlyZShcIi4vcm93UXVldWVcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5Jyk7XG4vKipcbiAqIFRoZSBmaWxlIGZvcm1hdHMgYWNjZXB0ZWQgYnkgQmlnUXVlcnkuXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IEZPUk1BVFMgPSB7XG4gICAgYXZybzogJ0FWUk8nLFxuICAgIGNzdjogJ0NTVicsXG4gICAgZXhwb3J0X21ldGFkYXRhOiAnREFUQVNUT1JFX0JBQ0tVUCcsXG4gICAganNvbjogJ05FV0xJTkVfREVMSU1JVEVEX0pTT04nLFxuICAgIG9yYzogJ09SQycsXG4gICAgcGFycXVldDogJ1BBUlFVRVQnLFxufTtcbi8qKlxuICogVGFibGUgb2JqZWN0cyBhcmUgcmV0dXJuZWQgYnkgbWV0aG9kcyBzdWNoIGFzXG4gKiB7QGxpbmsgRGF0YXNldCN0YWJsZX0sIHtAbGluayBEYXRhc2V0I2NyZWF0ZVRhYmxlfSwgYW5kXG4gKiB7QGxpbmsgRGF0YXNldCNnZXRUYWJsZXN9LlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0IHtAbGluayBEYXRhc2V0fSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHRhYmxlLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUYWJsZSBvcHRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2F0aW9uXSBUaGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgdGFibGUsIGJ5XG4gKiAgICAgIGRlZmF1bHQgdGhpcyB2YWx1ZSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgZGF0YXNldC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuICogICAgICBjb25maWd1cmUgdGhlIGxvY2F0aW9uIG9mIGFsbCBqb2JzIGNyZWF0ZWQgdGhyb3VnaCBhIHRhYmxlIGluc3RhbmNlLiBJdFxuICogICAgICBjYW5ub3QgYmUgdXNlZCB0byBzZXQgdGhlIGFjdHVhbCBsb2NhdGlvbiBvZiB0aGUgdGFibGUuIFRoaXMgdmFsdWUgd2lsbFxuICogICAgICBiZSBzdXBlcnNlZGVkIGJ5IGFueSBBUEkgcmVzcG9uc2VzIGNvbnRhaW5pbmcgbG9jYXRpb24gZGF0YSBmb3IgdGhlXG4gKiAgICAgIHRhYmxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ215LWRhdGFzZXQnKTtcbiAqXG4gKiBjb25zdCB0YWJsZSA9IGRhdGFzZXQudGFibGUoJ215LXRhYmxlJyk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgVGFibGUgZXh0ZW5kcyBjb21tb25fMS5TZXJ2aWNlT2JqZWN0IHtcbiAgICBjcmVhdGVSZWFkU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gcGxhY2Vob2xkZXIgYm9keSwgb3ZlcndyaXR0ZW4gaW4gY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBwYWdpbmF0b3JfMS5SZXNvdXJjZVN0cmVhbSh7fSwgKCkgPT4geyB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGF0YXNldCwgaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNhbGxiYWNrIENyZWF0ZVRhYmxlQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtUYWJsZX0gdGFibGUgVGhlIHRhYmxlLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFwaVJlc3BvbnNlIFRoZSBmdWxsIEFQSSByZXNwb25zZSBib2R5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHthcnJheX0gQ3JlYXRlVGFibGVSZXNwb25zZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtUYWJsZX0gMCBUaGUgdGFibGUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gMSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UgYm9keS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSB0YWJsZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIFRhYmxlI2NyZWF0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIERhdGFzZXQjY3JlYXRlVGFibGV9LlxuICAgICAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUYWJsZUNhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9lcnJvcn0gY2FsbGJhY2suZXJyIEFuIGVycm9yIHJldHVybmVkIHdoaWxlIG1ha2luZyB0aGlzXG4gICAgICAgICAgICAgKiAgICAgcmVxdWVzdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VGFibGV9IGNhbGxiYWNrLnRhYmxlIFRoZSBuZXcge0BsaW5rIFRhYmxlfS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFjay5hcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDcmVhdGVUYWJsZVJlc3BvbnNlPn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogY29uc3QgdGFibGUgPSBkYXRhc2V0LnRhYmxlKCdteS10YWJsZScpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHRhYmxlLmNyZWF0ZSgoZXJyLCB0YWJsZSwgYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAqICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAqICAgICAvLyBUaGUgdGFibGUgd2FzIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICogICB9XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIC8vIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkLCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiB0YWJsZS5jcmVhdGUoKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnN0IHRhYmxlID0gZGF0YVswXTtcbiAgICAgICAgICAgICAqICAgY29uc3QgYXBpUmVzcG9uc2UgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2FsbGJhY2sgRGVsZXRlVGFibGVDYWxsYmFja1xuICAgICAgICAgICAgICogQHBhcmFtIHs/RXJyb3J9IGVyciBSZXF1ZXN0IGVycm9yLCBpZiBhbnkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHthcnJheX0gRGVsZXRlVGFibGVSZXNwb25zZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDAgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlbGV0ZSBhIHRhYmxlIGFuZCBhbGwgaXRzIGRhdGEuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvdjIvdGFibGVzL2RlbGV0ZXwgVGFibGVzOiBkZWxldGUgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBUYWJsZSNkZWxldGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGVsZXRlVGFibGVDYWxsYmFja30gW2NhbGxiYWNrXVxuICAgICAgICAgICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpc1xuICAgICAgICAgICAgICogICAgIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2suYXBpUmVzcG9uc2UgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlLlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGVsZXRlVGFibGVSZXNwb25zZT59XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnbXktZGF0YXNldCcpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IHRhYmxlID0gZGF0YXNldC50YWJsZSgnbXktdGFibGUnKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB0YWJsZS5kZWxldGUoKGVyciwgYXBpUmVzcG9uc2UpID0+IHt9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIC8vIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkLCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiB0YWJsZS5kZWxldGUoKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnN0IGFwaVJlc3BvbnNlID0gZGF0YVswXTtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNhbGxiYWNrIFRhYmxlRXhpc3RzQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBleGlzdHMgSW5kaWNhdGVzIGlmIHRoZSB0YWJsZSBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBUYWJsZUV4aXN0c0NhbGxiYWNrXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IDAgSW5kaWNhdGVzIGlmIHRoZSB0YWJsZSBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIHRhYmxlIGV4aXN0cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIFRhYmxlI2V4aXN0c1xuICAgICAgICAgICAgICogQHBhcmFtIHtUYWJsZUV4aXN0c0NhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9lcnJvcn0gY2FsbGJhY2suZXJyIEFuIGVycm9yIHJldHVybmVkIHdoaWxlIG1ha2luZyB0aGlzXG4gICAgICAgICAgICAgKiAgICAgcmVxdWVzdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FsbGJhY2suZXhpc3RzIFdoZXRoZXIgdGhlIHRhYmxlIGV4aXN0cyBvciBub3QuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYWJsZUV4aXN0c0NhbGxiYWNrPn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogY29uc3QgdGFibGUgPSBkYXRhc2V0LnRhYmxlKCdteS10YWJsZScpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHRhYmxlLmV4aXN0cygoZXJyLCBleGlzdHMpID0+IHt9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIC8vIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkLCB3ZSdsbCByZXR1cm4gYSBQcm9taXNlLlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiB0YWJsZS5leGlzdHMoKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnN0IGV4aXN0cyA9IGRhdGFbMF07XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleGlzdHM6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBHZXRUYWJsZUNhbGxiYWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0gez9FcnJvcn0gZXJyIFJlcXVlc3QgZXJyb3IsIGlmIGFueS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VGFibGV9IHRhYmxlIFRoZSB0YWJsZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UgYm9keS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7YXJyYXl9IEdldFRhYmxlUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VGFibGV9IDAgVGhlIHRhYmxlLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IDEgVGhlIGZ1bGwgQVBJIHJlc3BvbnNlIGJvZHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGEgdGFibGUgaWYgaXQgZXhpc3RzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFlvdSBtYXkgb3B0aW9uYWxseSB1c2UgdGhpcyB0byBcImdldCBvciBjcmVhdGVcIiBhbiBvYmplY3QgYnkgcHJvdmlkaW5nXG4gICAgICAgICAgICAgKiBhbiBvYmplY3Qgd2l0aCBgYXV0b0NyZWF0ZWAgc2V0IHRvIGB0cnVlYC4gQW55IGV4dHJhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgICAgICAgICAgICogaXMgbm9ybWFsbHkgcmVxdWlyZWQgZm9yIHRoZSBgY3JlYXRlYCBtZXRob2QgbXVzdCBiZSBjb250YWluZWQgd2l0aGluXG4gICAgICAgICAgICAgKiB0aGlzIG9iamVjdCBhcyB3ZWxsLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIElmIHlvdSB3aXNoIHRvIGdldCBhIHNlbGVjdGlvbiBvZiBtZXRhZGF0YSBpbnN0ZWFkIG9mIHRoZSBmdWxsIHRhYmxlIG1ldGFkYXRhXG4gICAgICAgICAgICAgKiAocmV0cmlldmVkIGJ5IGJvdGggVGFibGUjZ2V0IGJ5IGRlZmF1bHQgYW5kIGJ5IFRhYmxlI2dldE1ldGFkYXRhKSwgdXNlXG4gICAgICAgICAgICAgKiB0aGUgYG9wdGlvbnNgIHBhcmFtZXRlciB0byBzZXQgdGhlIGB2aWV3YCBhbmQvb3IgYHNlbGVjdGVkRmllbGRzYCBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjIvdGFibGVzL2dldCNUYWJsZU1ldGFkYXRhVmlld3wgVGFibGVzLmdldCBhbmQgVGFibGVNZXRhZGF0YVZpZXcgfVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgVGFibGUjZ2V0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0NyZWF0ZT1mYWxzZV0gQXV0b21hdGljYWxseSBjcmVhdGUgdGhlXG4gICAgICAgICAgICAgKiAgICAgb2JqZWN0IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICAgICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpc1xuICAgICAgICAgICAgICogICAgIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1RhYmxlfSBjYWxsYmFjay50YWJsZSBUaGUge0BsaW5rIFRhYmxlfS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFjay5hcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUYWJsZVJlc3BvbnNlPn1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgICAgICogY29uc3QgYmlncXVlcnkgPSBuZXcgQmlnUXVlcnkoKTtcbiAgICAgICAgICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogY29uc3QgdGFibGUgPSBkYXRhc2V0LnRhYmxlKCdteS10YWJsZScpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgKiAgIHZpZXc6IFwiQkFTSUNcIlxuICAgICAgICAgICAgICogfVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHRhYmxlLmdldCgoZXJyLCB0YWJsZSwgYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAqICAgLy8gYHRhYmxlLm1ldGFkYXRhYCBoYXMgYmVlbiBwb3B1bGF0ZWQuXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB0YWJsZS5nZXQob3B0aW9ucywgKGVyciwgdGFibGUsIGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgKiAgIC8vIEEgc2VsZWN0aW9uIG9mIGB0YWJsZS5tZXRhZGF0YWAgaGFzIGJlZW4gcG9wdWxhdGVkXG4gICAgICAgICAgICAgKiB9KVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vLVxuICAgICAgICAgICAgICogLy8gSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQsIHdlJ2xsIHJldHVybiBhIFByb21pc2UuXG4gICAgICAgICAgICAgKiAvLy1cbiAgICAgICAgICAgICAqIHRhYmxlLmdldCgpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAqICAgY29uc3QgdGFibGUgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICogICBjb25zdCBhcGlSZXNwb25zZSA9IGRhdGFbMV07XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjYWxsYmFjayBHZXRUYWJsZU1ldGFkYXRhQ2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgUmVxdWVzdCBlcnJvciwgaWYgYW55LlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhIFRoZSB0YWJsZSBtZXRhZGF0YS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge2FycmF5fSBHZXRUYWJsZU1ldGFkYXRhUmVzcG9uc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAwIFRoZSB0YWJsZSBtZXRhZGF0YS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAxIFRoZSBmdWxsIEFQSSByZXNwb25zZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gdGhlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgVGFibGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYmlncXVlcnkvZG9jcy9yZWZlcmVuY2UvdjIvdGFibGVzL2dldHwgVGFibGVzOiBnZXQgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBUYWJsZSNnZXRNZXRhZGF0YVxuICAgICAgICAgICAgICogQHBhcmFtIHtHZXRUYWJsZU1ldGFkYXRhQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpc1xuICAgICAgICAgICAgICogICAgIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2subWV0YWRhdGEgVGhlIG1ldGFkYXRhIG9mIHRoZSBUYWJsZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFjay5hcGlSZXNwb25zZSBUaGUgZnVsbCBBUEkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUYWJsZU1ldGFkYXRhUmVzcG9uc2U+fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIGNvbnN0IHtCaWdRdWVyeX0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL2JpZ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ215LWRhdGFzZXQnKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBjb25zdCB0YWJsZSA9IGRhdGFzZXQudGFibGUoJ215LXRhYmxlJyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogdGFibGUuZ2V0TWV0YWRhdGEoKGVyciwgbWV0YWRhdGEsIGFwaVJlc3BvbnNlKSA9PiB7fSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLy8tXG4gICAgICAgICAgICAgKiAvLyBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCwgd2UnbGwgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICAgICAgICAgICAqIC8vLVxuICAgICAgICAgICAgICogdGFibGUuZ2V0TWV0YWRhdGEoKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnN0IG1ldGFkYXRhID0gZGF0YVswXTtcbiAgICAgICAgICAgICAqICAgY29uc3QgYXBpUmVzcG9uc2UgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TWV0YWRhdGE6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHBhcmVudDogZGF0YXNldCxcbiAgICAgICAgICAgIGJhc2VVcmw6ICcvdGFibGVzJyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY3JlYXRlTWV0aG9kOiBkYXRhc2V0LmNyZWF0ZVRhYmxlLmJpbmQoZGF0YXNldCksXG4gICAgICAgICAgICBtZXRob2RzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sb2NhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IG9wdGlvbnMubG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaWdRdWVyeSA9IGRhdGFzZXQuYmlnUXVlcnk7XG4gICAgICAgIHRoaXMuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICAgIC8vIENhdGNoIGFsbCBmb3IgcmVhZC1tb2RpZnktd3JpdGUgY3ljbGVcbiAgICAgICAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvYXBpLXBlcmZvcm1hbmNlI3JlYWQtcGF0Y2gtd3JpdGVcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMucHVzaCh7XG4gICAgICAgICAgICByZXF1ZXN0OiAocmVxT3B0cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXFPcHRzLm1ldGhvZCA9PT0gJ1BBVENIJyAmJiByZXFPcHRzLmpzb24uZXRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXFPcHRzLmhlYWRlcnMgPSByZXFPcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHJlcU9wdHMuaGVhZGVyc1snSWYtTWF0Y2gnXSA9IHJlcU9wdHMuanNvbi5ldGFnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxT3B0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgcmVhZGFibGUgc3RyZWFtIG9mIHRoZSByb3dzIG9mIGRhdGEgaW4geW91ciB0YWJsZS4gVGhpcyBtZXRob2RcbiAgICAgICAgICogaXMgc2ltcGx5IGEgd3JhcHBlciBhcm91bmQge0BsaW5rIFRhYmxlI2dldFJvd3N9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS92Mi90YWJsZWRhdGEvbGlzdHwgVGFibGVkYXRhOiBsaXN0IEFQSSBEb2N1bWVudGF0aW9ufVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW19XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAgICAgKiBjb25zdCBkYXRhc2V0ID0gYmlncXVlcnkuZGF0YXNldCgnbXktZGF0YXNldCcpO1xuICAgICAgICAgKiBjb25zdCB0YWJsZSA9IGRhdGFzZXQudGFibGUoJ215LXRhYmxlJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHRhYmxlLmNyZWF0ZVJlYWRTdHJlYW0ob3B0aW9ucylcbiAgICAgICAgICogICAub24oJ2Vycm9yJywgY29uc29sZS5lcnJvcilcbiAgICAgICAgICogICAub24oJ2RhdGEnLCByb3cgPT4ge30pXG4gICAgICAgICAqICAgLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgIC8vIEFsbCByb3dzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vLVxuICAgICAgICAgKiAvLyBJZiB5b3UgYW50aWNpcGF0ZSBtYW55IHJlc3VsdHMsIHlvdSBjYW4gZW5kIGEgc3RyZWFtIGVhcmx5IHRvIHByZXZlbnRcbiAgICAgICAgICogLy8gdW5uZWNlc3NhcnkgcHJvY2Vzc2luZyBhbmQgQVBJIHJlcXVlc3RzLlxuICAgICAgICAgKiAvLy1cbiAgICAgICAgICogdGFibGUuY3JlYXRlUmVhZFN0cmVhbSgpXG4gICAgICAgICAqICAgLm9uKCdkYXRhJywgZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAqICAgICB0aGlzLmVuZCgpO1xuICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUmVhZFN0cmVhbSA9IHBhZ2luYXRvcl8xLnBhZ2luYXRvci5zdHJlYW1pZnkoJ2dldFJvd3MnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGNvbW1hLXNlcGFyYXRlZCBuYW1lOnR5cGUgc3RyaW5nIHRvIGEgdGFibGUgc2NoZW1hIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBDb21tYS1zZXBhcmF0ZWQgc2NoZW1hIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUYWJsZSBzY2hlbWEgaW4gdGhlIGZvcm1hdCB0aGUgQVBJIGV4cGVjdHMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNjaGVtYUZyb21TdHJpbmdfKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnNwbGl0KC9cXHMqLFxccyovKS5yZWR1Y2UoKGFjYywgcGFpcikgPT4ge1xuICAgICAgICAgICAgYWNjLmZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYWlyLnNwbGl0KCc6JylbMF0udHJpbSgpLFxuICAgICAgICAgICAgICAgIHR5cGU6IChwYWlyLnNwbGl0KCc6JylbMV0gfHwgJ1NUUklORycpLnRvVXBwZXJDYXNlKCkudHJpbSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHJvdyBlbnRyeSBmcm9tIG5hdGl2ZSB0eXBlcyB0byB0aGVpciBlbmNvZGVkIHR5cGVzIHRoYXQgdGhlIEFQSVxuICAgICAqIGV4cGVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIGNvbnZlcnRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jb2RlVmFsdWVfKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VzdG9tVHlwZUNvbnN0cnVjdG9yTmFtZXMgPSBbXG4gICAgICAgICAgICAnQmlnUXVlcnlEYXRlJyxcbiAgICAgICAgICAgICdCaWdRdWVyeURhdGV0aW1lJyxcbiAgICAgICAgICAgICdCaWdRdWVyeUludCcsXG4gICAgICAgICAgICAnQmlnUXVlcnlUaW1lJyxcbiAgICAgICAgICAgICdCaWdRdWVyeVRpbWVzdGFtcCcsXG4gICAgICAgICAgICAnQmlnUXVlcnlSYW5nZScsXG4gICAgICAgICAgICAnR2VvZ3JhcGh5JyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gKF9hID0gdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lO1xuICAgICAgICBjb25zdCBpc0N1c3RvbVR5cGUgPSBjdXN0b21UeXBlQ29uc3RydWN0b3JOYW1lcy5pbmRleE9mKGNvbnN0cnVjdG9yTmFtZSkgPiAtMTtcbiAgICAgICAgaWYgKGlzQ3VzdG9tVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5kYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5hcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoVGFibGUuZW5jb2RlVmFsdWVfKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBUYWJsZS5lbmNvZGVWYWx1ZV8odmFsdWVba2V5XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIGZvcm1hdE1ldGFkYXRhXyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBleHRlbmQodHJ1ZSwge30sIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICBib2R5LmZyaWVuZGx5TmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLnNjaGVtYSkpIHtcbiAgICAgICAgICAgIGJvZHkuc2NoZW1hID0gVGFibGUuY3JlYXRlU2NoZW1hRnJvbVN0cmluZ18ob3B0aW9ucy5zY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5hcnJheShvcHRpb25zLnNjaGVtYSkpIHtcbiAgICAgICAgICAgIGJvZHkuc2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGZpZWxkczogb3B0aW9ucy5zY2hlbWEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5LnNjaGVtYSAmJiBib2R5LnNjaGVtYS5maWVsZHMpIHtcbiAgICAgICAgICAgIGJvZHkuc2NoZW1hLmZpZWxkcyA9IGJvZHkuc2NoZW1hLmZpZWxkcy5tYXAoZmllbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5maWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQudHlwZSA9ICdSRUNPUkQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuc3RyaW5nKG9wdGlvbnMucGFydGl0aW9uaW5nKSkge1xuICAgICAgICAgICAgYm9keS50aW1lUGFydGl0aW9uaW5nID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMucGFydGl0aW9uaW5nLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVsZXRlIGJvZHkucGFydGl0aW9uaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy52aWV3KSkge1xuICAgICAgICAgICAgYm9keS52aWV3ID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBvcHRpb25zLnZpZXcsXG4gICAgICAgICAgICAgICAgdXNlTGVnYWN5U3FsOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICAgIGNvcHkoZGVzdGluYXRpb24sIG1ldGFkYXRhT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0eXBlb2YgbWV0YWRhdGFPckNhbGxiYWNrID09PSAnb2JqZWN0JyA/IG1ldGFkYXRhT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBtZXRhZGF0YU9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBtZXRhZGF0YU9yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgdGhpcy5jcmVhdGVDb3B5Sm9iKGRlc3RpbmF0aW9uLCBtZXRhZGF0YSwgKGVyciwgam9iLCByZXNwKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqb2Iub24oJ2Vycm9yJywgY2FsbGJhY2spLm9uKCdjb21wbGV0ZScsIChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29weUZyb20oc291cmNlVGFibGVzLCBtZXRhZGF0YU9yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdHlwZW9mIG1ldGFkYXRhT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBtZXRhZGF0YU9yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2YgbWV0YWRhdGFPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gbWV0YWRhdGFPckNhbGxiYWNrIDogY2I7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29weUZyb21Kb2Ioc291cmNlVGFibGVzLCBtZXRhZGF0YSwgKGVyciwgam9iLCByZXNwKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqb2Iub24oJ2Vycm9yJywgY2FsbGJhY2spLm9uKCdjb21wbGV0ZScsIG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUNvcHlKb2IoZGVzdGluYXRpb24sIG1ldGFkYXRhT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgaWYgKCEoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBUYWJsZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVzdGluYXRpb24gbXVzdCBiZSBhIFRhYmxlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHR5cGVvZiBtZXRhZGF0YU9yQ2FsbGJhY2sgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IG1ldGFkYXRhT3JDYWxsYmFja1xuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2YgbWV0YWRhdGFPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gbWV0YWRhdGFPckNhbGxiYWNrIDogY2I7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgY29weTogZXh0ZW5kKHRydWUsIG1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogZGVzdGluYXRpb24uZGF0YXNldC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZDogZGVzdGluYXRpb24uZGF0YXNldC5wcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUlkOiBkZXN0aW5hdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogdGhpcy5kYXRhc2V0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdElkOiB0aGlzLmRhdGFzZXQucHJvamVjdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVJZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YS5qb2JQcmVmaXgpIHtcbiAgICAgICAgICAgIGJvZHkuam9iUHJlZml4ID0gbWV0YWRhdGEuam9iUHJlZml4O1xuICAgICAgICAgICAgZGVsZXRlIG1ldGFkYXRhLmpvYlByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgYm9keS5sb2NhdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLmpvYklkKSB7XG4gICAgICAgICAgICBib2R5LmpvYklkID0gbWV0YWRhdGEuam9iSWQ7XG4gICAgICAgICAgICBkZWxldGUgbWV0YWRhdGEuam9iSWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaWdRdWVyeS5jcmVhdGVKb2IoYm9keSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBjcmVhdGVDb3B5RnJvbUpvYihzb3VyY2UsIG1ldGFkYXRhT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3Qgc291cmNlVGFibGVzID0gYXJyaWZ5KHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZVRhYmxlcy5mb3JFYWNoKHNvdXJjZVRhYmxlID0+IHtcbiAgICAgICAgICAgIGlmICghKHNvdXJjZVRhYmxlIGluc3RhbmNlb2YgVGFibGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgbXVzdCBiZSBhIFRhYmxlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdHlwZW9mIG1ldGFkYXRhT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBtZXRhZGF0YU9yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2YgbWV0YWRhdGFPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gbWV0YWRhdGFPckNhbGxiYWNrIDogY2I7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgY29weTogZXh0ZW5kKHRydWUsIG1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogdGhpcy5kYXRhc2V0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdElkOiB0aGlzLmRhdGFzZXQucHJvamVjdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVJZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVGFibGVzOiBzb3VyY2VUYWJsZXMubWFwKHNvdXJjZVRhYmxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldElkOiBzb3VyY2VUYWJsZS5kYXRhc2V0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZDogc291cmNlVGFibGUuZGF0YXNldC5wcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVJZDogc291cmNlVGFibGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YS5qb2JQcmVmaXgpIHtcbiAgICAgICAgICAgIGJvZHkuam9iUHJlZml4ID0gbWV0YWRhdGEuam9iUHJlZml4O1xuICAgICAgICAgICAgZGVsZXRlIG1ldGFkYXRhLmpvYlByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgYm9keS5sb2NhdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLmpvYklkKSB7XG4gICAgICAgICAgICBib2R5LmpvYklkID0gbWV0YWRhdGEuam9iSWQ7XG4gICAgICAgICAgICBkZWxldGUgbWV0YWRhdGEuam9iSWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaWdRdWVyeS5jcmVhdGVKb2IoYm9keSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBjcmVhdGVFeHRyYWN0Sm9iKGRlc3RpbmF0aW9uLCBvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB7fTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zT3JDYWxsYmFjayA6IGNiO1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVXJpczogYXJyaWZ5KGRlc3RpbmF0aW9uKS5tYXAoZGVzdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tb25fMS51dGlsLmlzQ3VzdG9tVHlwZShkZXN0LCAnc3RvcmFnZS9maWxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXN0aW5hdGlvbiBtdXN0IGJlIGEgRmlsZSBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGZvcm1hdCB3YXMgcHJvdmlkZWQsIGF0dGVtcHQgdG8gZmluZCBhIG1hdGNoIGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlsZSdzIGV4dGVuc2lvbi4gSWYgbm8gbWF0Y2gsIGRvbid0IHNldCwgYW5kIGRlZmF1bHQgdXBzdHJlYW0gdG9cbiAgICAgICAgICAgICAgICAvLyBDU1YuXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gcGF0aC5leHRuYW1lKGRlc3QubmFtZSkuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRlc3RpbmF0aW9uRm9ybWF0ICYmICFvcHRpb25zLmZvcm1hdCAmJiBGT1JNQVRTW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbkZvcm1hdCA9IEZPUk1BVFNbZm9ybWF0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdnczovLycgKyBkZXN0LmJ1Y2tldC5uYW1lICsgJy8nICsgZGVzdC5uYW1lO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChGT1JNQVRTW29wdGlvbnMuZm9ybWF0XSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVzdGluYXRpb25Gb3JtYXQgPSBGT1JNQVRTW29wdGlvbnMuZm9ybWF0XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rlc3RpbmF0aW9uIGZvcm1hdCBub3QgcmVjb2duaXplZDogJyArIG9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5nemlwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbXByZXNzaW9uID0gJ0daSVAnO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZ3ppcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIGV4dHJhY3Q6IGV4dGVuZCh0cnVlLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVRhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IHRoaXMuZGF0YXNldC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5kYXRhc2V0LnByb2plY3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5qb2JQcmVmaXgpIHtcbiAgICAgICAgICAgIGJvZHkuam9iUHJlZml4ID0gb3B0aW9ucy5qb2JQcmVmaXg7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5qb2JQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIGJvZHkubG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmpvYklkKSB7XG4gICAgICAgICAgICBib2R5LmpvYklkID0gb3B0aW9ucy5qb2JJZDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmpvYklkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmlnUXVlcnkuY3JlYXRlSm9iKGJvZHksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgY3JlYXRlTG9hZEpvYihzb3VyY2UsIG1ldGFkYXRhT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0eXBlb2YgbWV0YWRhdGFPckNhbGxiYWNrID09PSAnb2JqZWN0JyA/IG1ldGFkYXRhT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBtZXRhZGF0YU9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBtZXRhZGF0YU9yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgdGhpcy5fY3JlYXRlTG9hZEpvYihzb3VyY2UsIG1ldGFkYXRhKS50aGVuKChbcmVzcF0pID0+IGNhbGxiYWNrKG51bGwsIHJlc3AsIHJlc3AubWV0YWRhdGEpLCBlcnIgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgRmlsZSB8IEZpbGVbXX0gc291cmNlXG4gICAgICogQHBhcmFtIHtKb2JMb2FkTWV0YWRhdGF9IG1ldGFkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Sm9iUmVzcG9uc2U+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2NyZWF0ZUxvYWRKb2Ioc291cmNlLCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEuZm9ybWF0KSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5zb3VyY2VGb3JtYXQgPSBGT1JNQVRTW21ldGFkYXRhLmZvcm1hdC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGRlbGV0ZSBtZXRhZGF0YS5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmxvY2F0aW9uID0gdGhpcy5sb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIEEgcGF0aCB0byBhIGZpbGUgd2FzIGdpdmVuLiBJZiBhIHNvdXJjZUZvcm1hdCB3YXNuJ3Qgc3BlY2lmaWVkLCB0cnkgdG9cbiAgICAgICAgICAgIC8vIGZpbmQgYSBtYXRjaCBmcm9tIHRoZSBmaWxlJ3MgZXh0ZW5zaW9uLlxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWRGb3JtYXQgPSBGT1JNQVRTW3BhdGguZXh0bmFtZShzb3VyY2UpLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmICghbWV0YWRhdGEuc291cmNlRm9ybWF0ICYmIGRldGVjdGVkRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuc291cmNlRm9ybWF0ID0gZGV0ZWN0ZWRGb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWFkIHRoZSBmaWxlIGludG8gYSBuZXcgd3JpdGUgc3RyZWFtLlxuICAgICAgICAgICAgY29uc3Qgam9iV3JpdGFibGUgPSBmc1xuICAgICAgICAgICAgICAgIC5jcmVhdGVSZWFkU3RyZWFtKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAucGlwZSh0aGlzLmNyZWF0ZVdyaXRlU3RyZWFtXyhtZXRhZGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgW2pvYlJlc3BvbnNlXSA9IChhd2FpdCAoMCwgZXZlbnRzXzEub25jZSkoam9iV3JpdGFibGUsICdqb2InKSk7XG4gICAgICAgICAgICByZXR1cm4gW2pvYlJlc3BvbnNlLCBqb2JSZXNwb25zZS5tZXRhZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICBsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5kYXRhc2V0LnByb2plY3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogdGhpcy5kYXRhc2V0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVJZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmpvYlByZWZpeCkge1xuICAgICAgICAgICAgYm9keS5qb2JQcmVmaXggPSBtZXRhZGF0YS5qb2JQcmVmaXg7XG4gICAgICAgICAgICBkZWxldGUgbWV0YWRhdGEuam9iUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YS5sb2NhdGlvbikge1xuICAgICAgICAgICAgYm9keS5sb2NhdGlvbiA9IG1ldGFkYXRhLmxvY2F0aW9uO1xuICAgICAgICAgICAgZGVsZXRlIG1ldGFkYXRhLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YS5qb2JJZCkge1xuICAgICAgICAgICAgYm9keS5qb2JJZCA9IG1ldGFkYXRhLmpvYklkO1xuICAgICAgICAgICAgZGVsZXRlIG1ldGFkYXRhLmpvYklkO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuZCh0cnVlLCBib2R5LmNvbmZpZ3VyYXRpb24ubG9hZCwgbWV0YWRhdGEsIHtcbiAgICAgICAgICAgIHNvdXJjZVVyaXM6IGFycmlmeShzb3VyY2UpLm1hcChzcmMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29tbW9uXzEudXRpbC5pc0N1c3RvbVR5cGUoc3JjLCAnc3RvcmFnZS9maWxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgbXVzdCBiZSBhIEZpbGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBubyBleHBsaWNpdCBmb3JtYXQgd2FzIHByb3ZpZGVkLCBhdHRlbXB0IHRvIGZpbmQgYSBtYXRjaCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpbGUncyBleHRlbnNpb24uIElmIG5vIG1hdGNoLCBkb24ndCBzZXQsIGFuZCBkZWZhdWx0IHVwc3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gdG8gQ1NWLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IEZPUk1BVFNbcGF0aC5leHRuYW1lKHNyYy5uYW1lKS5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YS5zb3VyY2VGb3JtYXQgJiYgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuY29uZmlndXJhdGlvbi5sb2FkLnNvdXJjZUZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdnczovLycgKyBzcmMuYnVja2V0Lm5hbWUgKyAnLycgKyBzcmMubmFtZTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlnUXVlcnkuY3JlYXRlSm9iKGJvZHkpO1xuICAgIH1cbiAgICBjcmVhdGVRdWVyeUpvYihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhc2V0LmNyZWF0ZVF1ZXJ5Sm9iKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIGEgcXVlcnkgc2NvcGVkIHRvIHlvdXIgZGF0YXNldCBhcyBhIHJlYWRhYmxlIG9iamVjdCBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIEJpZ1F1ZXJ5I2NyZWF0ZVF1ZXJ5U3RyZWFtfSBmb3IgZnVsbCBkb2N1bWVudGF0aW9uIG9mIHRoaXNcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnkgU2VlIHtAbGluayBCaWdRdWVyeSNjcmVhdGVRdWVyeVN0cmVhbX0gZm9yIGZ1bGxcbiAgICAgKiAgICAgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyZWFtfSBTZWUge0BsaW5rIEJpZ1F1ZXJ5I2NyZWF0ZVF1ZXJ5U3RyZWFtfSBmb3IgZnVsbFxuICAgICAqICAgICBkb2N1bWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuICAgICAqL1xuICAgIGNyZWF0ZVF1ZXJ5U3RyZWFtKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXQuY3JlYXRlUXVlcnlTdHJlYW0ocXVlcnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd3JpdGUgc3RyZWFtLiBVbmxpa2UgdGhlIHB1YmxpYyB2ZXJzaW9uLCB0aGlzIHdpbGwgbm90XG4gICAgICogYXV0b21hdGljYWxseSBwb2xsIHRoZSB1bmRlcmx5aW5nIGpvYi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFttZXRhZGF0YV0gTWV0YWRhdGEgdG8gc2V0IHdpdGggdGhlIGxvYWQgb3BlcmF0aW9uLlxuICAgICAqICAgICBUaGUgbWV0YWRhdGEgb2JqZWN0IHNob3VsZCBiZSBpbiB0aGUgZm9ybWF0IG9mIHRoZVxuICAgICAqICAgICB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjIvSm9iI0pvYkNvbmZpZ3VyYXRpb25Mb2FkfCBgY29uZmlndXJhdGlvbi5sb2FkYH1cbiAgICAgKiBwcm9wZXJ0eSBvZiBhIEpvYnMgcmVzb3VyY2UuIElmIGEgc3RyaW5nIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiBhcyB0aGUgZmlsZXR5cGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRhZGF0YS5qb2JJZF0gQ3VzdG9tIGpvYiBpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGFkYXRhLmpvYlByZWZpeF0gUHJlZml4IHRvIGFwcGx5IHRvIHRoZSBqb2IgaWQuXG4gICAgICogQHJldHVybnMge1dyaXRhYmxlU3RyZWFtfVxuICAgICAqL1xuICAgIGNyZWF0ZVdyaXRlU3RyZWFtXyhtZXRhZGF0YSkge1xuICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgc291cmNlRm9ybWF0OiBGT1JNQVRTW21ldGFkYXRhLnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhLnNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLnNjaGVtYSA9IFRhYmxlLmNyZWF0ZVNjaGVtYUZyb21TdHJpbmdfKG1ldGFkYXRhLnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0YWRhdGEgPSBleHRlbmQodHJ1ZSwge1xuICAgICAgICAgICAgZGVzdGluYXRpb25UYWJsZToge1xuICAgICAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5kYXRhc2V0LnByb2plY3RJZCxcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IHRoaXMuZGF0YXNldC5pZCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgbWV0YWRhdGEpO1xuICAgICAgICBsZXQgam9iSWQgPSBtZXRhZGF0YS5qb2JJZCB8fCB1dWlkLnY0KCk7XG4gICAgICAgIGlmIChtZXRhZGF0YS5qb2JJZCkge1xuICAgICAgICAgICAgZGVsZXRlIG1ldGFkYXRhLmpvYklkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YS5qb2JQcmVmaXgpIHtcbiAgICAgICAgICAgIGpvYklkID0gbWV0YWRhdGEuam9iUHJlZml4ICsgam9iSWQ7XG4gICAgICAgICAgICBkZWxldGUgbWV0YWRhdGEuam9iUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR1cCA9IHN0cmVhbUV2ZW50cyhkdXBsZXhpZnkoKSk7XG4gICAgICAgIGR1cC5vbmNlKCd3cml0aW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgY29tbW9uXzEudXRpbC5tYWtlV3JpdGFibGVTdHJlYW0oZHVwLCB7XG4gICAgICAgICAgICAgICAgbWFrZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0OiB0aGlzLmJpZ1F1ZXJ5Lm1ha2VBdXRoZW50aWNhdGVkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkOiBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgam9iUmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5kYXRhc2V0LnByb2plY3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICB1cmk6IGAke3RoaXMuYmlnUXVlcnkuYXBpRW5kcG9pbnR9L3VwbG9hZC9iaWdxdWVyeS92Mi9wcm9qZWN0cy8ke3RoaXMuZGF0YXNldC5wcm9qZWN0SWR9L2pvYnNgLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvYiA9IHRoaXMuYmlnUXVlcnkuam9iKGRhdGEuam9iUmVmZXJlbmNlLmpvYklkLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBkYXRhLmpvYlJlZmVyZW5jZS5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdElkOiBkYXRhLmpvYlJlZmVyZW5jZS5wcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgam9iLm1ldGFkYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkdXAuZW1pdCgnam9iJywgam9iKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGR1cDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBkYXRhIGludG8geW91ciB0YWJsZSBmcm9tIGEgcmVhZGFibGUgc3RyZWFtIG9mIEFWUk8sIENTViwgSlNPTiwgT1JDLFxuICAgICAqIG9yIFBBUlFVRVQgZGF0YS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvcmVmZXJlbmNlL3YyL2pvYnMvaW5zZXJ0fCBKb2JzOiBpbnNlcnQgQVBJIERvY3VtZW50YXRpb259XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFttZXRhZGF0YV0gTWV0YWRhdGEgdG8gc2V0IHdpdGggdGhlIGxvYWQgb3BlcmF0aW9uLlxuICAgICAqICAgICBUaGUgbWV0YWRhdGEgb2JqZWN0IHNob3VsZCBiZSBpbiB0aGUgZm9ybWF0IG9mIHRoZVxuICAgICAqICAgICB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2JpZ3F1ZXJ5L2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjIvSm9iI0pvYkNvbmZpZ3VyYXRpb25Mb2FkfCBgY29uZmlndXJhdGlvbi5sb2FkYH1cbiAgICAgKiBwcm9wZXJ0eSBvZiBhIEpvYnMgcmVzb3VyY2UuIElmIGEgc3RyaW5nIGlzIGdpdmVuLFxuICAgICAqIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgZmlsZXR5cGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRhZGF0YS5qb2JJZF0gQ3VzdG9tIGpvYiBpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGFkYXRhLmpvYlByZWZpeF0gUHJlZml4IHRvIGFwcGx5IHRvIHRoZSBqb2IgaWQuXG4gICAgICogQHJldHVybnMge1dyaXRhYmxlU3RyZWFtfVxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHNvdXJjZSBmb3JtYXQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogY29uc3Qge0JpZ1F1ZXJ5fSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvYmlncXVlcnknKTtcbiAgICAgKiBjb25zdCBiaWdxdWVyeSA9IG5ldyBCaWdRdWVyeSgpO1xuICAgICAqIGNvbnN0IGRhdGFzZXQgPSBiaWdxdWVyeS5kYXRhc2V0KCdteS1kYXRhc2V0Jyk7XG4gICAgICogY29uc3QgdGFibGUgPSBkYXRhc2V0LnRhYmxlKCdteS10YWJsZScpO1xuICAgICAqXG4gICAgICogLy8tXG4gICAgICogLy8gTG9hZCBkYXRhIGZyb20gYSBDU1YgZmlsZS5cbiAgICAgKiAvLy1cbiAgICAgKiBjb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgncmVxdWVzdCcpO1xuICAgICAqXG4gICAgICogY29uc3QgY3N2VXJsID0gJ2h0dHA6Ly9nb28uZ2wva1NFN3o2JztcbiAgICAgKlxuICAgICAqIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAqICAgYWxsb3dKYWdnZWRSb3dzOiB0cnVlLFxuICAgICAqICAgc2tpcExlYWRpbmdSb3dzOiAxXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHJlcXVlc3QuZ2V0KGNzdlVybClcbiAgICAgKiAgIC5waXBlKHRhYmxlLmNyZWF0ZVdyaXRlU3RyZWFtKG1ldGFkYXRhKSlcbiAgICAgKiAgIC5vbignam9iJywgKGpvYikgPT4ge1xuICAgICAqICAgICAvLyBgam9iYCBpcyBhIEpvYiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZVxuICAgICAqICAgICAvLyByZXF1ZXN0LlxuICAgICAqICAgfSlcbiAgICAgKiAgIC5vbignY29tcGxldGUnLCAoam9iKSA9PiB7XG4gICAgICogICAgIC8vIFRoZSBqb2IgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqIC8vLVxuICAgICAqIC8vIExvYWQgZGF0YSBmcm9tIGEgSlNPTiBmaWxlLlxuICAgICAqIC8vLVxuICAgICAqIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgKlxuICAgICAqIGZzLmNyZWF0ZVJlYWRTdHJlYW0oJy4vdGVzdC90ZXN0ZGF0YS90ZXN0ZmlsZS5qc29uJylcbiAgICAgKiAgIC5waXBlKHRhYmxlLmNyZWF0ZVdyaXRlU3RyZWFtKCdqc29uJykpXG4gICAgICogICAub24oJ2pvYicsIChqb2IpID0+IHtcbiAgICAgKiAgICAgLy8gYGpvYmAgaXMgYSBKb2Igb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGVcbiAgICAgKiAgICAgLy8gcmVxdWVzdC5cbiAgICAgKiAgIH0pXG4gICAgICogICAub24oJ2NvbXBsZXRlJywgKGpvYikgPT4ge1xuICAgICAqICAgICAvLyBUaGUgam9iIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqICAgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlV3JpdGVTdHJlYW0obWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5jcmVhdGVXcml0ZVN0cmVhbV8obWV0YWRhdGEpO1xuICAgICAgICBzdHJlYW0ub24oJ3ByZWZpbmlzaCcsICgpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5jb3JrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2pvYicsIChqb2IpID0+IHtcbiAgICAgICAgICAgIGpvYlxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY29tcGxldGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2NvbXBsZXRlJywgam9iKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0udW5jb3JrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIGV4dHJhY3QoZGVzdGluYXRpb24sIG9wdGlvbnNPckNhbGxiYWNrLCBjYikge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnb2JqZWN0JyA/IG9wdGlvbnNPckNhbGxiYWNrIDoge307XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc09yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgdGhpcy5jcmVhdGVFeHRyYWN0Sm9iKGRlc3RpbmF0aW9uLCBvcHRpb25zLCAoZXJyLCBqb2IsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpvYi5vbignZXJyb3InLCBjYWxsYmFjaykub24oJ2NvbXBsZXRlJywgbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRhYmxlIGRhdGEgZnJvbSBhIHNwZWNpZmllZCBzZXQgb2Ygcm93cy4gVGhlIHJvd3MgYXJlIHJldHVybmVkIHRvXG4gICAgICogeW91ciBjYWxsYmFjayBhcyBhbiBhcnJheSBvZiBvYmplY3RzIG1hdGNoaW5nIHlvdXIgdGFibGUncyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9iaWdxdWVyeS9kb2NzL3JlZmVyZW5jZS92Mi90YWJsZWRhdGEvbGlzdHwgVGFibGVkYXRhOiBsaXN0IEFQSSBEb2N1bWVudGF0aW9ufVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvUGFnaW5hdGU9dHJ1ZV0gSGF2ZSBwYWdpbmF0aW9uIGhhbmRsZWRcbiAgICAgKiAgICAgYXV0b21hdGljYWxseS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4QXBpQ2FsbHNdIE1heGltdW0gbnVtYmVyIG9mIEFQSSBjYWxscyB0byBtYWtlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhSZXN1bHRzXSBNYXhpbXVtIG51bWJlciBvZiByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58SW50ZWdlclR5cGVDYXN0T3B0aW9uc30gW29wdGlvbnMud3JhcEludGVnZXJzPWZhbHNlXSBXcmFwIHZhbHVlc1xuICAgICAqICAgICBvZiAnSU5UNjQnIHR5cGUgaW4ge0BsaW5rIEJpZ1F1ZXJ5SW50fSBvYmplY3RzLlxuICAgICAqICAgICBJZiBhIGBib29sZWFuYCwgdGhpcyB3aWxsIHdyYXAgdmFsdWVzIGluIHtAbGluayBCaWdRdWVyeUludH0gb2JqZWN0cy5cbiAgICAgKiAgICAgSWYgYW4gYG9iamVjdGAsIHRoaXMgd2lsbCByZXR1cm4gYSB2YWx1ZSByZXR1cm5lZCBieVxuICAgICAqICAgICBgd3JhcEludGVnZXJzLmludGVnZXJUeXBlQ2FzdEZ1bmN0aW9uYC5cbiAgICAgKiBAcGFyYW0ge1Jvd3NDYWxsYmFja30gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uIElmIGBhdXRvUGFnaW5hdGVgXG4gICAgICogICAgIGlzIHNldCB0byBmYWxzZSBhIHtAbGluayBNYW51YWxRdWVyeVJlc3VsdHNDYWxsYmFja30gc2hvdWxkIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIHs/ZXJyb3J9IGNhbGxiYWNrLmVyciBBbiBlcnJvciByZXR1cm5lZCB3aGlsZSBtYWtpbmcgdGhpcyByZXF1ZXN0XG4gICAgICogQHBhcmFtIHthcnJheX0gY2FsbGJhY2sucm93cyBUaGUgdGFibGUgZGF0YSBmcm9tIHNwZWNpZmllZCBzZXQgb2Ygcm93cy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSb3dzUmVzcG9uc2U+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCB7QmlnUXVlcnl9ID0gcmVxdWlyZSgnQGdvb2dsZS1jbG91ZC9iaWdxdWVyeScpO1xuICAgICAqIGNvbnN0IGJpZ3F1ZXJ5ID0gbmV3IEJpZ1F1ZXJ5KCk7XG4gICAgICogY29uc3QgZGF0YXNldCA9IGJpZ3F1ZXJ5LmRhdGFzZXQoJ215LWRhdGFzZXQnKTtcbiAgICAgKiBjb25zdCB0YWJsZSA9IGRhdGFzZXQudGFibGUoJ215LXRhYmxlJyk7XG4gICAgICpcbiAgICAgKiB0YWJsZS5nZXRSb3dzKChlcnIsIHJvd3MpID0+IHtcbiAgICAgKiAgIGlmICghZXJyKSB7XG4gICAgICogICAgIC8vIHJvd3MgaXMgYW4gYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vLVxuICAgICAqIC8vIFRvIGNvbnRyb2wgaG93IG1hbnkgQVBJIHJlcXVlc3RzIGFyZSBtYWRlIGFuZCBwYWdlIHRocm91Z2ggdGhlIHJlc3VsdHNcbiAgICAgKiAvLyBtYW51YWxseSwgc2V0IGBhdXRvUGFnaW5hdGVgIHRvIGBmYWxzZWAuXG4gICAgICogLy8tXG4gICAgICogZnVuY3Rpb24gbWFudWFsUGFnaW5hdGlvbkNhbGxiYWNrKGVyciwgcm93cywgbmV4dFF1ZXJ5LCBhcGlSZXNwb25zZSkge1xuICAgICAqICAgaWYgKG5leHRRdWVyeSkge1xuICAgICAqICAgICAvLyBNb3JlIHJlc3VsdHMgZXhpc3QuXG4gICAgICogICAgIHRhYmxlLmdldFJvd3MobmV4dFF1ZXJ5LCBtYW51YWxQYWdpbmF0aW9uQ2FsbGJhY2spO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHRhYmxlLmdldFJvd3Moe1xuICAgICAqICAgYXV0b1BhZ2luYXRlOiBmYWxzZVxuICAgICAqIH0sIG1hbnVhbFBhZ2luYXRpb25DYWxsYmFjayk7XG4gICAgICpcbiAgICAgKiAvLy1cbiAgICAgKiAvLyBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCwgd2UnbGwgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICAgKiAvLy1cbiAgICAgKiB0YWJsZS5nZXRSb3dzKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAqICAgY29uc3Qgcm93cyA9IGRhdGFbMF07XG4gICAgICogICB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRSb3dzKG9wdGlvbnNPckNhbGxiYWNrLCBjYikge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnb2JqZWN0JyA/IG9wdGlvbnNPckNhbGxiYWNrIDoge307XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc09yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgY29uc3Qgd3JhcEludGVnZXJzID0gb3B0aW9ucy53cmFwSW50ZWdlcnMgPyBvcHRpb25zLndyYXBJbnRlZ2VycyA6IGZhbHNlO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy53cmFwSW50ZWdlcnM7XG4gICAgICAgIGNvbnN0IHBhcnNlSlNPTiA9IG9wdGlvbnMucGFyc2VKU09OID8gb3B0aW9ucy5wYXJzZUpTT04gOiBmYWxzZTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyc2VKU09OO1xuICAgICAgICBjb25zdCBzZWxlY3RlZEZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0ZWRGaWVsZHNcbiAgICAgICAgICAgID8gb3B0aW9ucy5zZWxlY3RlZEZpZWxkcy5zcGxpdCgnLCcpXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBvbkNvbXBsZXRlID0gKGVyciwgcm93cywgbmV4dFF1ZXJ5LCByZXNwKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsLCBudWxsLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzID0gXzEuQmlnUXVlcnkubWVyZ2VTY2hlbWFXaXRoUm93c18odGhpcy5tZXRhZGF0YS5zY2hlbWEsIHJvd3MgfHwgW10sIHtcbiAgICAgICAgICAgICAgICB3cmFwSW50ZWdlcnMsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRGaWVsZHMsXG4gICAgICAgICAgICAgICAgcGFyc2VKU09OLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByb3dzLCBuZXh0UXVlcnksIHJlc3ApO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBxcyA9IGV4dGVuZCh7XG4gICAgICAgICAgICAnZm9ybWF0T3B0aW9ucy51c2VJbnQ2NFRpbWVzdGFtcCc6IHRydWUsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJpOiAnL2RhdGEnLFxuICAgICAgICAgICAgcXMsXG4gICAgICAgIH0sIChlcnIsIHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKGVyciwgbnVsbCwgbnVsbCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHRRdWVyeSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzcC5wYWdlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBuZXh0UXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBxcywge1xuICAgICAgICAgICAgICAgICAgICBwYWdlVG9rZW46IHJlc3AucGFnZVRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3Aucm93cyAmJiByZXNwLnJvd3MubGVuZ3RoID4gMCAmJiAhdGhpcy5tZXRhZGF0YS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBzY2hlbWEgZm9yIHRoaXMgdGFibGUgeWV0LiBEbyBhIHF1aWNrIHN0YXQuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRNZXRhZGF0YSgoZXJyLCBtZXRhZGF0YSwgYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShlcnIsIG51bGwsIG51bGwsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG51bGwsIHJlc3Aucm93cywgbmV4dFF1ZXJ5LCByZXNwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkNvbXBsZXRlKG51bGwsIHJlc3Aucm93cywgbmV4dFF1ZXJ5LCByZXNwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluc2VydChyb3dzLCBvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gb3B0aW9uc09yQ2FsbGJhY2tcbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc09yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2luc2VydEFuZENyZWF0ZVRhYmxlKHJvd3MsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNwID0+IGNhbGxiYWNrKG51bGwsIHJlc3ApLCBlcnIgPT4gY2FsbGJhY2soZXJyLCBudWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHIgPT4gW3JdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgcm93cyB3aXRoIHJldHJpZXMsIGJ1dCB3aWxsIGNyZWF0ZSB0aGUgdGFibGUgaWYgbm90IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Um93TWV0YWRhdGEgfCBSb3dNZXRhZGF0YVtdfSByb3dzXG4gICAgICogQHBhcmFtIHtJbnNlcnRSb3dzT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJpZ3F1ZXJ5LklUYWJsZURhdGFJbnNlcnRBbGxSZXNwb25zZSB8IGJpZ3F1ZXJ5LklUYWJsZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfaW5zZXJ0QW5kQ3JlYXRlVGFibGUocm93cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZGVsYXkgPSA2MDAwMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbnNlcnRXaXRoUmV0cnkocm93cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSA0MDQgfHwgIXNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGUoeyBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSA0MDkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGFibGUgY3JlYXRpb24gYWZ0ZXIgZmFpbGVkIGFjY2VzcyBpcyBzdWJqZWN0IHRvIGZhaWx1cmUgY2FjaGluZyBhbmRcbiAgICAgICAgLy8gZXZlbnR1YWwgY29uc2lzdGVuY3ksIHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlLWNsb3VkLXB5dGhvbi9pc3N1ZXMvNDU1MyNpc3N1ZWNvbW1lbnQtMzUwMTEwMjkyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0QW5kQ3JlYXRlVGFibGUocm93cywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYXR0ZW1wdCB0byBpbnNlcnQgcm93cyB3aGlsZSByZXRyeWluZyBhbnkgcGFydGlhbCBmYWlsdXJlc1xuICAgICAqIHRoYXQgb2NjdXIgYWxvbmcgdGhlIHdheS4gQmVjYXVzZSBwYXJ0aWFsIGluc2VydCBmYWlsdXJlcyBhcmUgcmV0dXJuZWRcbiAgICAgKiBkaWZmZXJlbnRseSwgd2UgY2FuJ3QgZGVwZW5kIG9uIG91ciB1c3VhbCByZXRyeSBzdHJhdGVneS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Jvd01ldGFkYXRhfFJvd01ldGFkYXRhW119IHJvd3MgVGhlIHJvd3MgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSB7SW5zZXJ0Um93c09wdGlvbnN9IG9wdGlvbnMgSW5zZXJ0IG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YmlncXVlcnkuSVRhYmxlRGF0YUluc2VydEFsbFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBfaW5zZXJ0V2l0aFJldHJ5KHJvd3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBwYXJ0aWFsUmV0cmllcyA9IDMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSBNYXRoLm1heChwYXJ0aWFsUmV0cmllcywgMCkgKyAxO1xuICAgICAgICBmb3IgKGxldCBhdHRlbXB0cyA9IDA7IGF0dGVtcHRzIDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHRzKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2luc2VydChyb3dzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIHJvd3MgPSAoZS5lcnJvcnMgfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZXJyID0+ICEhZXJyLnJvdylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChlcnIgPT4gZXJyLnJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgdGhlIGJ1bGsgb2YgdGhlIHdvcmsgZm9yIHByb2Nlc3Npbmcgb3B0aW9ucyBhbmQgbWFraW5nIHRoZVxuICAgICAqIG5ldHdvcmsgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Jvd01ldGFkYXRhfFJvd01ldGFkYXRhW119IHJvd3MgVGhlIHJvd3MgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSB7SW5zZXJ0Um93c09wdGlvbnN9IG9wdGlvbnMgSW5zZXJ0IG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YmlncXVlcnkuSVRhYmxlRGF0YUluc2VydEFsbFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBfaW5zZXJ0KHJvd3MsIG9wdGlvbnMpIHtcbiAgICAgICAgcm93cyA9IGFycmlmeShyb3dzKTtcbiAgICAgICAgaWYgKCFyb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IDEgcm93IHRvIGJlIGluc2VydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb24gPSBleHRlbmQodHJ1ZSwge30sIG9wdGlvbnMsIHsgcm93cyB9KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJhdykge1xuICAgICAgICAgICAganNvbi5yb3dzID0gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb246IFRhYmxlLmVuY29kZVZhbHVlXyhyb3cpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY3JlYXRlSW5zZXJ0SWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWQuaW5zZXJ0SWQgPSB1dWlkLnY0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGpzb24uY3JlYXRlSW5zZXJ0SWQ7XG4gICAgICAgIGRlbGV0ZSBqc29uLnBhcnRpYWxSZXRyaWVzO1xuICAgICAgICBkZWxldGUganNvbi5yYXc7XG4gICAgICAgIGRlbGV0ZSBqc29uLnNjaGVtYTtcbiAgICAgICAgY29uc3QgW3Jlc3BdID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJpOiAnL2luc2VydEFsbCcsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFydGlhbEZhaWx1cmVzID0gKHJlc3AuaW5zZXJ0RXJyb3JzIHx8IFtdKS5tYXAoKGluc2VydEVycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycm9yczogaW5zZXJ0RXJyb3IuZXJyb3JzLm1hcChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBlcnJvci5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICByb3c6IHJvd3NbaW5zZXJ0RXJyb3IuaW5kZXhdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJ0aWFsRmFpbHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvbW1vbl8xLnV0aWwuUGFydGlhbEZhaWx1cmVFcnJvcih7XG4gICAgICAgICAgICAgICAgZXJyb3JzOiBwYXJ0aWFsRmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3AsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG4gICAgY3JlYXRlSW5zZXJ0U3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3QgZHVwID0gbmV3IHN0cmVhbV8xLkR1cGxleCh7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIGR1cC5fd3JpdGUgPSAoY2h1bmssIGVuY29kaW5nLCBjYikgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3dRdWV1ZS5hZGQoY2h1bmssICgpID0+IHsgfSk7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJvd1F1ZXVlID0gbmV3IHJvd1F1ZXVlXzEuUm93UXVldWUodGhpcywgZHVwLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGR1cDtcbiAgICB9XG4gICAgbG9hZChzb3VyY2UsIG1ldGFkYXRhT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0eXBlb2YgbWV0YWRhdGFPckNhbGxiYWNrID09PSAnb2JqZWN0JyA/IG1ldGFkYXRhT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBtZXRhZGF0YU9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBtZXRhZGF0YU9yQ2FsbGJhY2sgOiBjYjtcbiAgICAgICAgdGhpcy5jcmVhdGVMb2FkSm9iKHNvdXJjZSwgbWV0YWRhdGEsIChlcnIsIGpvYiwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgam9iLm9uKCdlcnJvcicsIGNhbGxiYWNrKS5vbignY29tcGxldGUnLCBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWVyeShxdWVyeSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXQucXVlcnkocXVlcnksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc2V0TWV0YWRhdGEobWV0YWRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBUYWJsZS5mb3JtYXRNZXRhZGF0YV8obWV0YWRhdGEpO1xuICAgICAgICBzdXBlci5zZXRNZXRhZGF0YShib2R5LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldElhbVBvbGljeShvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBvcHRpb25zT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNPckNhbGxiYWNrIDogY2I7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXF1ZXN0ZWRQb2xpY3lWZXJzaW9uID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0ZWRQb2xpY3lWZXJzaW9uICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgSUFNIHBvbGljeSB2ZXJzaW9uIDEgaXMgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb24gPSBleHRlbmQodHJ1ZSwge30sIHsgb3B0aW9ucyB9KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJpOiAnLzpnZXRJYW1Qb2xpY3knLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSwgKGVyciwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRJYW1Qb2xpY3kocG9saWN5LCBvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ29iamVjdCcgPyBvcHRpb25zT3JDYWxsYmFjayA6IHt9O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNPckNhbGxiYWNrIDogY2I7XG4gICAgICAgIGlmIChwb2xpY3kudmVyc2lvbiAmJiBwb2xpY3kudmVyc2lvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IElBTSBwb2xpY3kgdmVyc2lvbiAxIGlzIHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29uID0gZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zLCB7IHBvbGljeSB9KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJpOiAnLzpzZXRJYW1Qb2xpY3knLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSwgKGVyciwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0ZXN0SWFtUGVybWlzc2lvbnMocGVybWlzc2lvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHBlcm1pc3Npb25zID0gYXJyaWZ5KHBlcm1pc3Npb25zKTtcbiAgICAgICAgY29uc3QganNvbiA9IGV4dGVuZCh0cnVlLCB7fSwgeyBwZXJtaXNzaW9ucyB9KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJpOiAnLzp0ZXN0SWFtUGVybWlzc2lvbnMnLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSwgKGVyciwgcmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGUgPSBUYWJsZTtcbi8qISBEZXZlbG9wZXIgRG9jdW1lbnRhdGlvblxuICpcbiAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIGF1dG8tcGFnaW5hdGVkLlxuICovXG5wYWdpbmF0b3JfMS5wYWdpbmF0b3IuZXh0ZW5kKFRhYmxlLCBbJ2dldFJvd3MnXSk7XG4vKiEgRGV2ZWxvcGVyIERvY3VtZW50YXRpb25cbiAqXG4gKiBBbGwgYXN5bmMgbWV0aG9kcyAoZXhjZXB0IGZvciBzdHJlYW1zKSB3aWxsIHJldHVybiBhIFByb21pc2UgaW4gdGhlIGV2ZW50XG4gKiB0aGF0IGEgY2FsbGJhY2sgaXMgb21pdHRlZC5cbiAqL1xuKDAsIHByb21pc2lmeV8xLnByb21pc2lmeUFsbCkoVGFibGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/bigquery/build/src/table.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/bigquery/package.json":
/*!**********************************************************!*\
  !*** ./node_modules/@google-cloud/bigquery/package.json ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@google-cloud/bigquery","description":"Google BigQuery Client Library for Node.js","version":"7.9.4","license":"Apache-2.0","author":"Google LLC","engines":{"node":">=14.0.0"},"repository":"googleapis/nodejs-bigquery","main":"./build/src/index.js","types":"./build/src/index.d.ts","files":["build/src","!build/src/**/*.map"],"keywords":["google apis client","google api client","google apis","google api","google","google cloud platform","google cloud","cloud","google bigquery","bigquery"],"scripts":{"prebenchmark":"npm run compile","benchmark":"node build/benchmark/bench.js benchmark/queries.json","docs":"jsdoc -c .jsdoc.js","lint":"gts check","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","test":"c8 mocha build/test","system-test":"mocha build/system-test --timeout 600000","presystem-test":"npm run compile","clean":"gts clean","compile":"tsc -p . && cp src/types.d.ts build/src/","fix":"gts fix","predocs":"npm run compile","prepare":"npm run compile","pretest":"npm run compile","docs-test":"linkinator docs","predocs-test":"npm run docs","types":"node scripts/gen-types.js","prelint":"cd samples; npm link ../; npm install","precompile":"gts clean"},"dependencies":{"@google-cloud/common":"^5.0.0","@google-cloud/paginator":"^5.0.2","@google-cloud/precise-date":"^4.0.0","@google-cloud/promisify":"4.0.0","arrify":"^2.0.1","big.js":"^6.0.0","duplexify":"^4.0.0","extend":"^3.0.2","is":"^3.3.0","stream-events":"^1.0.5","uuid":"^9.0.0"},"devDependencies":{"@google-cloud/storage":"^7.0.0","@types/big.js":"^6.2.0","@types/extend":"^3.0.1","@types/is":"0.0.25","@types/mocha":"^9.0.0","@types/node":"^20.0.0","@types/proxyquire":"^1.3.28","@types/sinon":"^10.0.0","@types/uuid":"^9.0.0","c8":"^9.0.0","codecov":"^3.5.0","discovery-tsd":"^0.3.0","eslint-plugin-prettier":"^5.0.0","gts":"^5.0.0","jsdoc":"^4.0.0","jsdoc-fresh":"^3.0.0","jsdoc-region-tag":"^3.0.0","linkinator":"^3.0.0","mocha":"^9.2.2","pack-n-play":"^2.0.0","prettier":"^3.0.0","proxyquire":"^2.1.0","sinon":"^18.0.0","nise":"6.0.0","path-to-regexp":"6.3.0","typescript":"^5.1.6"}}');

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/common/build/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@google-cloud/common/build/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2016 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.util = exports.ApiError = exports.ServiceObject = exports.Service = exports.Operation = void 0;\n/**\n * @type {module:common/operation}\n * @private\n */\nvar operation_1 = __webpack_require__(/*! ./operation */ \"(rsc)/./node_modules/@google-cloud/common/build/src/operation.js\");\nObject.defineProperty(exports, \"Operation\", ({ enumerable: true, get: function () { return operation_1.Operation; } }));\n/**\n * @type {module:common/service}\n * @private\n */\nvar service_1 = __webpack_require__(/*! ./service */ \"(rsc)/./node_modules/@google-cloud/common/build/src/service.js\");\nObject.defineProperty(exports, \"Service\", ({ enumerable: true, get: function () { return service_1.Service; } }));\n/**\n * @type {module:common/serviceObject}\n * @private\n */\nvar service_object_1 = __webpack_require__(/*! ./service-object */ \"(rsc)/./node_modules/@google-cloud/common/build/src/service-object.js\");\nObject.defineProperty(exports, \"ServiceObject\", ({ enumerable: true, get: function () { return service_object_1.ServiceObject; } }));\n/**\n * @type {module:common/util}\n * @private\n */\nvar util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@google-cloud/common/build/src/util.js\");\nObject.defineProperty(exports, \"ApiError\", ({ enumerable: true, get: function () { return util_1.ApiError; } }));\nObject.defineProperty(exports, \"util\", ({ enumerable: true, get: function () { return util_1.util; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9jb21tb24vYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixHQUFHLGVBQWUsR0FBRyxpQkFBaUI7QUFDN0Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3ZDLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsaUZBQVc7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywrRkFBa0I7QUFDakQsaURBQWdELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ2xJO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsMkVBQVE7QUFDN0IsNENBQTJDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzlHLHdDQUF1QyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUN0RyIsInNvdXJjZXMiOlsiL1VzZXJzL2thaXNlaS9EZXNrdG9wL20tdHJhY2VyLWFpL25vZGVfbW9kdWxlcy9AZ29vZ2xlLWNsb3VkL2NvbW1vbi9idWlsZC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbCA9IGV4cG9ydHMuQXBpRXJyb3IgPSBleHBvcnRzLlNlcnZpY2VPYmplY3QgPSBleHBvcnRzLlNlcnZpY2UgPSBleHBvcnRzLk9wZXJhdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogQHR5cGUge21vZHVsZTpjb21tb24vb3BlcmF0aW9ufVxuICogQHByaXZhdGVcbiAqL1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3BlcmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcGVyYXRpb25fMS5PcGVyYXRpb247IH0gfSk7XG4vKipcbiAqIEB0eXBlIHttb2R1bGU6Y29tbW9uL3NlcnZpY2V9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZpY2VfMS5TZXJ2aWNlOyB9IH0pO1xuLyoqXG4gKiBAdHlwZSB7bW9kdWxlOmNvbW1vbi9zZXJ2aWNlT2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIHNlcnZpY2Vfb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLW9iamVjdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZpY2VPYmplY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZpY2Vfb2JqZWN0XzEuU2VydmljZU9iamVjdDsgfSB9KTtcbi8qKlxuICogQHR5cGUge21vZHVsZTpjb21tb24vdXRpbH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBpRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxfMS5BcGlFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0aWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxfMS51dGlsOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/common/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/common/build/src/operation.js":
/*!******************************************************************!*\
  !*** ./node_modules/@google-cloud/common/build/src/operation.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2016 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Operation = void 0;\n/*!\n * @module common/operation\n */\nconst service_object_1 = __webpack_require__(/*! ./service-object */ \"(rsc)/./node_modules/@google-cloud/common/build/src/service-object.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass Operation extends service_object_1.ServiceObject {\n    /**\n     * An Operation object allows you to interact with APIs that take longer to\n     * process things.\n     *\n     * @constructor\n     * @alias module:common/operation\n     *\n     * @param {object} config - Configuration object.\n     * @param {module:common/service|module:common/serviceObject|module:common/grpcService|module:common/grpcServiceObject} config.parent - The parent object.\n     */\n    constructor(config) {\n        const methods = {\n            /**\n             * Checks to see if an operation exists.\n             */\n            exists: true,\n            /**\n             * Retrieves the operation.\n             */\n            get: true,\n            /**\n             * Retrieves metadata for the operation.\n             */\n            getMetadata: {\n                reqOpts: {\n                    name: config.id,\n                },\n            },\n        };\n        config = Object.assign({\n            baseUrl: '',\n        }, config);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        config.methods = (config.methods || methods);\n        super(config);\n        this.completeListeners = 0;\n        this.hasActiveListeners = false;\n        this.listenForEvents_();\n    }\n    /**\n     * Wraps the `complete` and `error` events in a Promise.\n     *\n     * @return {Promise}\n     */\n    promise() {\n        return new Promise((resolve, reject) => {\n            this.on('error', reject).on('complete', (metadata) => {\n                resolve([metadata]);\n            });\n        });\n    }\n    /**\n     * Begin listening for events on the operation. This method keeps track of how\n     * many \"complete\" listeners are registered and removed, making sure polling\n     * is handled automatically.\n     *\n     * As long as there is one active \"complete\" listener, the connection is open.\n     * When there are no more listeners, the polling stops.\n     *\n     * @private\n     */\n    listenForEvents_() {\n        this.on('newListener', (event) => {\n            if (event === 'complete') {\n                this.completeListeners++;\n                if (!this.hasActiveListeners) {\n                    this.hasActiveListeners = true;\n                    this.startPolling_();\n                }\n            }\n        });\n        this.on('removeListener', (event) => {\n            if (event === 'complete' && --this.completeListeners === 0) {\n                this.hasActiveListeners = false;\n            }\n        });\n    }\n    /**\n     * Poll for a status update. Returns null for an incomplete\n     * status, and metadata for a complete status.\n     *\n     * @private\n     */\n    poll_(callback) {\n        this.getMetadata((err, body) => {\n            if (err || body.error) {\n                callback(err || body.error);\n                return;\n            }\n            if (!body.done) {\n                callback(null);\n                return;\n            }\n            callback(null, body);\n        });\n    }\n    /**\n     * Poll `getMetadata` to check the operation's status. This runs a loop to\n     * ping the API on an interval.\n     *\n     * Note: This method is automatically called once a \"complete\" event handler\n     * is registered on the operation.\n     *\n     * @private\n     */\n    async startPolling_() {\n        if (!this.hasActiveListeners) {\n            return;\n        }\n        try {\n            const metadata = await (0, util_1.promisify)(this.poll_.bind(this))();\n            if (!metadata) {\n                setTimeout(this.startPolling_.bind(this), this.pollIntervalMs || 500);\n                return;\n            }\n            this.emit('complete', metadata);\n        }\n        catch (err) {\n            this.emit('error', err);\n        }\n    }\n}\nexports.Operation = Operation;\n//# sourceMappingURL=operation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9jb21tb24vYnVpbGQvc3JjL29wZXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBa0I7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLDZHQUE2RztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyIvVXNlcnMva2Fpc2VpL0Rlc2t0b3AvbS10cmFjZXItYWkvbm9kZV9tb2R1bGVzL0Bnb29nbGUtY2xvdWQvY29tbW9uL2J1aWxkL3NyYy9vcGVyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3BlcmF0aW9uID0gdm9pZCAwO1xuLyohXG4gKiBAbW9kdWxlIGNvbW1vbi9vcGVyYXRpb25cbiAqL1xuY29uc3Qgc2VydmljZV9vYmplY3RfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2Utb2JqZWN0XCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY2xhc3MgT3BlcmF0aW9uIGV4dGVuZHMgc2VydmljZV9vYmplY3RfMS5TZXJ2aWNlT2JqZWN0IHtcbiAgICAvKipcbiAgICAgKiBBbiBPcGVyYXRpb24gb2JqZWN0IGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCBBUElzIHRoYXQgdGFrZSBsb25nZXIgdG9cbiAgICAgKiBwcm9jZXNzIHRoaW5ncy5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6Y29tbW9uL29wZXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNvbW1vbi9zZXJ2aWNlfG1vZHVsZTpjb21tb24vc2VydmljZU9iamVjdHxtb2R1bGU6Y29tbW9uL2dycGNTZXJ2aWNlfG1vZHVsZTpjb21tb24vZ3JwY1NlcnZpY2VPYmplY3R9IGNvbmZpZy5wYXJlbnQgLSBUaGUgcGFyZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhbiBvcGVyYXRpb24gZXhpc3RzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleGlzdHM6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgdGhlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICByZXFPcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbmZpZy5pZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBiYXNlVXJsOiAnJyxcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uZmlnLm1ldGhvZHMgPSAoY29uZmlnLm1ldGhvZHMgfHwgbWV0aG9kcyk7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY29tcGxldGVMaXN0ZW5lcnMgPSAwO1xuICAgICAgICB0aGlzLmhhc0FjdGl2ZUxpc3RlbmVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpc3RlbkZvckV2ZW50c18oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHMgdGhlIGBjb21wbGV0ZWAgYW5kIGBlcnJvcmAgZXZlbnRzIGluIGEgUHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMub24oJ2Vycm9yJywgcmVqZWN0KS5vbignY29tcGxldGUnLCAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFttZXRhZGF0YV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCZWdpbiBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBvbiB0aGUgb3BlcmF0aW9uLiBUaGlzIG1ldGhvZCBrZWVwcyB0cmFjayBvZiBob3dcbiAgICAgKiBtYW55IFwiY29tcGxldGVcIiBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgYW5kIHJlbW92ZWQsIG1ha2luZyBzdXJlIHBvbGxpbmdcbiAgICAgKiBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBBcyBsb25nIGFzIHRoZXJlIGlzIG9uZSBhY3RpdmUgXCJjb21wbGV0ZVwiIGxpc3RlbmVyLCB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLlxuICAgICAqIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzLCB0aGUgcG9sbGluZyBzdG9wcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbGlzdGVuRm9yRXZlbnRzXygpIHtcbiAgICAgICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVMaXN0ZW5lcnMrKztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQWN0aXZlTGlzdGVuZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvbGxpbmdfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ2NvbXBsZXRlJyAmJiAtLXRoaXMuY29tcGxldGVMaXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0FjdGl2ZUxpc3RlbmVycyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9sbCBmb3IgYSBzdGF0dXMgdXBkYXRlLiBSZXR1cm5zIG51bGwgZm9yIGFuIGluY29tcGxldGVcbiAgICAgKiBzdGF0dXMsIGFuZCBtZXRhZGF0YSBmb3IgYSBjb21wbGV0ZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvbGxfKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2V0TWV0YWRhdGEoKGVyciwgYm9keSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciB8fCBib2R5LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyIHx8IGJvZHkuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYm9keS5kb25lKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYm9keSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2xsIGBnZXRNZXRhZGF0YWAgdG8gY2hlY2sgdGhlIG9wZXJhdGlvbidzIHN0YXR1cy4gVGhpcyBydW5zIGEgbG9vcCB0b1xuICAgICAqIHBpbmcgdGhlIEFQSSBvbiBhbiBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIG9uY2UgYSBcImNvbXBsZXRlXCIgZXZlbnQgaGFuZGxlclxuICAgICAqIGlzIHJlZ2lzdGVyZWQgb24gdGhlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRQb2xsaW5nXygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLnBvbGxfLmJpbmQodGhpcykpKCk7XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnN0YXJ0UG9sbGluZ18uYmluZCh0aGlzKSwgdGhpcy5wb2xsSW50ZXJ2YWxNcyB8fCA1MDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29tcGxldGUnLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk9wZXJhdGlvbiA9IE9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/common/build/src/operation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/common/build/src/service-object.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@google-cloud/common/build/src/service-object.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServiceObject = void 0;\n/*!\n * @module common/service-object\n */\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\");\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@google-cloud/common/build/src/util.js\");\n/**\n * ServiceObject is a base class, meant to be inherited from by a \"service\n * object,\" like a BigQuery dataset or Storage bucket.\n *\n * Most of the time, these objects share common functionality; they can be\n * created or deleted, and you can get or set their metadata.\n *\n * By inheriting from this class, a service object will be extended with these\n * shared behaviors. Note that any method can be overridden when the service\n * object requires specific behavior.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass ServiceObject extends events_1.EventEmitter {\n    /*\n     * @constructor\n     * @alias module:common/service-object\n     *\n     * @private\n     *\n     * @param {object} config - Configuration object.\n     * @param {string} config.baseUrl - The base URL to make API requests to.\n     * @param {string} config.createMethod - The method which creates this object.\n     * @param {string=} config.id - The identifier of the object. For example, the\n     *     name of a Storage bucket or Pub/Sub topic.\n     * @param {object=} config.methods - A map of each method name that should be inherited.\n     * @param {object} config.methods[].reqOpts - Default request options for this\n     *     particular method. A common use case is when `setMetadata` requires a\n     *     `PUT` method to override the default `PATCH`.\n     * @param {object} config.parent - The parent service instance. For example, an\n     *     instance of Storage if the object is Bucket.\n     */\n    constructor(config) {\n        super();\n        this.metadata = {};\n        this.baseUrl = config.baseUrl;\n        this.parent = config.parent; // Parent class.\n        this.id = config.id; // Name or ID (e.g. dataset ID, bucket name, etc).\n        this.createMethod = config.createMethod;\n        this.methods = config.methods || {};\n        this.interceptors = [];\n        this.pollIntervalMs = config.pollIntervalMs;\n        this.projectId = config.projectId;\n        if (config.methods) {\n            // This filters the ServiceObject instance (e.g. a \"File\") to only have\n            // the configured methods. We make a couple of exceptions for core-\n            // functionality (\"request()\" and \"getRequestInterceptors()\")\n            Object.getOwnPropertyNames(ServiceObject.prototype)\n                .filter(methodName => {\n                return (\n                // All ServiceObjects need `request` and `getRequestInterceptors`.\n                // clang-format off\n                !/^request/.test(methodName) &&\n                    !/^getRequestInterceptors/.test(methodName) &&\n                    // clang-format on\n                    // The ServiceObject didn't redefine the method.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this[methodName] ===\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        ServiceObject.prototype[methodName] &&\n                    // This method isn't wanted.\n                    !config.methods[methodName]);\n            })\n                .forEach(methodName => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                this[methodName] = undefined;\n            });\n        }\n    }\n    create(optionsOrCallback, callback) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const args = [this.id];\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        if (typeof optionsOrCallback === 'object') {\n            args.push(optionsOrCallback);\n        }\n        // Wrap the callback to return *this* instance of the object, not the\n        // newly-created one.\n        // tslint: disable-next-line no-any\n        function onCreate(...args) {\n            const [err, instance] = args;\n            if (!err) {\n                self.metadata = instance.metadata;\n                args[1] = self; // replace the created `instance` with this one.\n            }\n            callback(...args);\n        }\n        args.push(onCreate);\n        // eslint-disable-next-line prefer-spread\n        this.createMethod.apply(null, args);\n    }\n    delete(optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const ignoreNotFound = options.ignoreNotFound;\n        delete options.ignoreNotFound;\n        const methodConfig = (typeof this.methods.delete === 'object' && this.methods.delete) || {};\n        const reqOpts = extend(true, {\n            method: 'DELETE',\n            uri: '',\n        }, methodConfig.reqOpts, {\n            qs: options,\n        });\n        // The `request` method may have been overridden to hold any special\n        // behavior. Ensure we call the original `request` method.\n        ServiceObject.prototype.request.call(this, reqOpts, (err, ...args) => {\n            if (err) {\n                if (err.code === 404 && ignoreNotFound) {\n                    err = null;\n                }\n            }\n            callback(err, ...args);\n        });\n    }\n    exists(optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        this.get(options, err => {\n            if (err) {\n                if (err.code === 404) {\n                    callback(null, false);\n                }\n                else {\n                    callback(err);\n                }\n                return;\n            }\n            callback(null, true);\n        });\n    }\n    get(optionsOrCallback, cb) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const [opts, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const options = Object.assign({}, opts);\n        const autoCreate = options.autoCreate && typeof this.create === 'function';\n        delete options.autoCreate;\n        function onCreate(err, instance, apiResponse) {\n            if (err) {\n                if (err.code === 409) {\n                    self.get(options, callback);\n                    return;\n                }\n                callback(err, null, apiResponse);\n                return;\n            }\n            callback(null, instance, apiResponse);\n        }\n        this.getMetadata(options, (err, metadata) => {\n            if (err) {\n                if (err.code === 404 && autoCreate) {\n                    const args = [];\n                    if (Object.keys(options).length > 0) {\n                        args.push(options);\n                    }\n                    args.push(onCreate);\n                    self.create(...args);\n                    return;\n                }\n                callback(err, null, metadata);\n                return;\n            }\n            callback(null, self, metadata);\n        });\n    }\n    getMetadata(optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const methodConfig = (typeof this.methods.getMetadata === 'object' &&\n            this.methods.getMetadata) ||\n            {};\n        const reqOpts = extend(true, {\n            uri: '',\n        }, methodConfig.reqOpts, {\n            qs: options,\n        });\n        // The `request` method may have been overridden to hold any special\n        // behavior. Ensure we call the original `request` method.\n        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {\n            this.metadata = body;\n            callback(err, this.metadata, res);\n        });\n    }\n    /**\n     * Return the user's custom request interceptors.\n     */\n    getRequestInterceptors() {\n        // Interceptors should be returned in the order they were assigned.\n        const localInterceptors = this.interceptors\n            .filter(interceptor => typeof interceptor.request === 'function')\n            .map(interceptor => interceptor.request);\n        return this.parent.getRequestInterceptors().concat(localInterceptors);\n    }\n    setMetadata(metadata, optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const methodConfig = (typeof this.methods.setMetadata === 'object' &&\n            this.methods.setMetadata) ||\n            {};\n        const reqOpts = extend(true, {}, {\n            method: 'PATCH',\n            uri: '',\n        }, methodConfig.reqOpts, {\n            json: metadata,\n            qs: options,\n        });\n        // The `request` method may have been overridden to hold any special\n        // behavior. Ensure we call the original `request` method.\n        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {\n            this.metadata = body;\n            callback(err, this.metadata, res);\n        });\n    }\n    request_(reqOpts, callback) {\n        reqOpts = extend(true, {}, reqOpts);\n        if (this.projectId) {\n            reqOpts.projectId = this.projectId;\n        }\n        const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n        const uriComponents = [this.baseUrl, this.id || '', reqOpts.uri];\n        if (isAbsoluteUrl) {\n            uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n        }\n        reqOpts.uri = uriComponents\n            .filter(x => x.trim()) // Limit to non-empty strings.\n            .map(uriComponent => {\n            const trimSlashesRegex = /^\\/*|\\/*$/g;\n            return uriComponent.replace(trimSlashesRegex, '');\n        })\n            .join('/');\n        const childInterceptors = arrify(reqOpts.interceptors_);\n        const localInterceptors = [].slice.call(this.interceptors);\n        reqOpts.interceptors_ = childInterceptors.concat(localInterceptors);\n        if (reqOpts.shouldReturnStream) {\n            return this.parent.requestStream(reqOpts);\n        }\n        this.parent.request(reqOpts, callback);\n    }\n    request(reqOpts, callback) {\n        this.request_(reqOpts, callback);\n    }\n    /**\n     * Make an authenticated API request.\n     *\n     * @param {object} reqOpts - Request options that are passed to `request`.\n     * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n     */\n    requestStream(reqOpts) {\n        const opts = extend(true, reqOpts, { shouldReturnStream: true });\n        return this.request_(opts);\n    }\n}\nexports.ServiceObject = ServiceObject;\n(0, promisify_1.promisifyAll)(ServiceObject, { exclude: ['getRequestInterceptors'] });\n//# sourceMappingURL=service-object.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9jb21tb24vYnVpbGQvc3JjL3NlcnZpY2Utb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywyRUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwrQ0FBK0MscUNBQXFDO0FBQ3BGIiwic291cmNlcyI6WyIvVXNlcnMva2Fpc2VpL0Rlc2t0b3AvbS10cmFjZXItYWkvbm9kZV9tb2R1bGVzL0Bnb29nbGUtY2xvdWQvY29tbW9uL2J1aWxkL3NyYy9zZXJ2aWNlLW9iamVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE1IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2aWNlT2JqZWN0ID0gdm9pZCAwO1xuLyohXG4gKiBAbW9kdWxlIGNvbW1vbi9zZXJ2aWNlLW9iamVjdFxuICovXG5jb25zdCBwcm9taXNpZnlfMSA9IHJlcXVpcmUoXCJAZ29vZ2xlLWNsb3VkL3Byb21pc2lmeVwiKTtcbmNvbnN0IGFycmlmeSA9IHJlcXVpcmUoXCJhcnJpZnlcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbi8qKlxuICogU2VydmljZU9iamVjdCBpcyBhIGJhc2UgY2xhc3MsIG1lYW50IHRvIGJlIGluaGVyaXRlZCBmcm9tIGJ5IGEgXCJzZXJ2aWNlXG4gKiBvYmplY3QsXCIgbGlrZSBhIEJpZ1F1ZXJ5IGRhdGFzZXQgb3IgU3RvcmFnZSBidWNrZXQuXG4gKlxuICogTW9zdCBvZiB0aGUgdGltZSwgdGhlc2Ugb2JqZWN0cyBzaGFyZSBjb21tb24gZnVuY3Rpb25hbGl0eTsgdGhleSBjYW4gYmVcbiAqIGNyZWF0ZWQgb3IgZGVsZXRlZCwgYW5kIHlvdSBjYW4gZ2V0IG9yIHNldCB0aGVpciBtZXRhZGF0YS5cbiAqXG4gKiBCeSBpbmhlcml0aW5nIGZyb20gdGhpcyBjbGFzcywgYSBzZXJ2aWNlIG9iamVjdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGggdGhlc2VcbiAqIHNoYXJlZCBiZWhhdmlvcnMuIE5vdGUgdGhhdCBhbnkgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHdoZW4gdGhlIHNlcnZpY2VcbiAqIG9iamVjdCByZXF1aXJlcyBzcGVjaWZpYyBiZWhhdmlvci5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNsYXNzIFNlcnZpY2VPYmplY3QgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTpjb21tb24vc2VydmljZS1vYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5iYXNlVXJsIC0gVGhlIGJhc2UgVVJMIHRvIG1ha2UgQVBJIHJlcXVlc3RzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuY3JlYXRlTWV0aG9kIC0gVGhlIG1ldGhvZCB3aGljaCBjcmVhdGVzIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gY29uZmlnLmlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIG9iamVjdC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqICAgICBuYW1lIG9mIGEgU3RvcmFnZSBidWNrZXQgb3IgUHViL1N1YiB0b3BpYy5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IGNvbmZpZy5tZXRob2RzIC0gQSBtYXAgb2YgZWFjaCBtZXRob2QgbmFtZSB0aGF0IHNob3VsZCBiZSBpbmhlcml0ZWQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZy5tZXRob2RzW10ucmVxT3B0cyAtIERlZmF1bHQgcmVxdWVzdCBvcHRpb25zIGZvciB0aGlzXG4gICAgICogICAgIHBhcnRpY3VsYXIgbWV0aG9kLiBBIGNvbW1vbiB1c2UgY2FzZSBpcyB3aGVuIGBzZXRNZXRhZGF0YWAgcmVxdWlyZXMgYVxuICAgICAqICAgICBgUFVUYCBtZXRob2QgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYFBBVENIYC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnLnBhcmVudCAtIFRoZSBwYXJlbnQgc2VydmljZSBpbnN0YW5jZS4gRm9yIGV4YW1wbGUsIGFuXG4gICAgICogICAgIGluc3RhbmNlIG9mIFN0b3JhZ2UgaWYgdGhlIG9iamVjdCBpcyBCdWNrZXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gY29uZmlnLmJhc2VVcmw7XG4gICAgICAgIHRoaXMucGFyZW50ID0gY29uZmlnLnBhcmVudDsgLy8gUGFyZW50IGNsYXNzLlxuICAgICAgICB0aGlzLmlkID0gY29uZmlnLmlkOyAvLyBOYW1lIG9yIElEIChlLmcuIGRhdGFzZXQgSUQsIGJ1Y2tldCBuYW1lLCBldGMpLlxuICAgICAgICB0aGlzLmNyZWF0ZU1ldGhvZCA9IGNvbmZpZy5jcmVhdGVNZXRob2Q7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IGNvbmZpZy5tZXRob2RzIHx8IHt9O1xuICAgICAgICB0aGlzLmludGVyY2VwdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnBvbGxJbnRlcnZhbE1zID0gY29uZmlnLnBvbGxJbnRlcnZhbE1zO1xuICAgICAgICB0aGlzLnByb2plY3RJZCA9IGNvbmZpZy5wcm9qZWN0SWQ7XG4gICAgICAgIGlmIChjb25maWcubWV0aG9kcykge1xuICAgICAgICAgICAgLy8gVGhpcyBmaWx0ZXJzIHRoZSBTZXJ2aWNlT2JqZWN0IGluc3RhbmNlIChlLmcuIGEgXCJGaWxlXCIpIHRvIG9ubHkgaGF2ZVxuICAgICAgICAgICAgLy8gdGhlIGNvbmZpZ3VyZWQgbWV0aG9kcy4gV2UgbWFrZSBhIGNvdXBsZSBvZiBleGNlcHRpb25zIGZvciBjb3JlLVxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbGl0eSAoXCJyZXF1ZXN0KClcIiBhbmQgXCJnZXRSZXF1ZXN0SW50ZXJjZXB0b3JzKClcIilcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFNlcnZpY2VPYmplY3QucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIobWV0aG9kTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAvLyBBbGwgU2VydmljZU9iamVjdHMgbmVlZCBgcmVxdWVzdGAgYW5kIGBnZXRSZXF1ZXN0SW50ZXJjZXB0b3JzYC5cbiAgICAgICAgICAgICAgICAvLyBjbGFuZy1mb3JtYXQgb2ZmXG4gICAgICAgICAgICAgICAgIS9ecmVxdWVzdC8udGVzdChtZXRob2ROYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAhL15nZXRSZXF1ZXN0SW50ZXJjZXB0b3JzLy50ZXN0KG1ldGhvZE5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsYW5nLWZvcm1hdCBvblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgU2VydmljZU9iamVjdCBkaWRuJ3QgcmVkZWZpbmUgdGhlIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBTZXJ2aWNlT2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCB3YW50ZWQuXG4gICAgICAgICAgICAgICAgICAgICFjb25maWcubWV0aG9kc1ttZXRob2ROYW1lXSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZShvcHRpb25zT3JDYWxsYmFjaywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBhcmdzID0gW3RoaXMuaWRdO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9uc09yQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyYXAgdGhlIGNhbGxiYWNrIHRvIHJldHVybiAqdGhpcyogaW5zdGFuY2Ugb2YgdGhlIG9iamVjdCwgbm90IHRoZVxuICAgICAgICAvLyBuZXdseS1jcmVhdGVkIG9uZS5cbiAgICAgICAgLy8gdHNsaW50OiBkaXNhYmxlLW5leHQtbGluZSBuby1hbnlcbiAgICAgICAgZnVuY3Rpb24gb25DcmVhdGUoLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgW2VyciwgaW5zdGFuY2VdID0gYXJncztcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YSA9IGluc3RhbmNlLm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBzZWxmOyAvLyByZXBsYWNlIHRoZSBjcmVhdGVkIGBpbnN0YW5jZWAgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChvbkNyZWF0ZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgIHRoaXMuY3JlYXRlTWV0aG9kLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBkZWxldGUob3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRpb25zLCBjYWxsYmFja10gPSB1dGlsXzEudXRpbC5tYXliZU9wdGlvbnNPckNhbGxiYWNrKG9wdGlvbnNPckNhbGxiYWNrLCBjYik7XG4gICAgICAgIGNvbnN0IGlnbm9yZU5vdEZvdW5kID0gb3B0aW9ucy5pZ25vcmVOb3RGb3VuZDtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaWdub3JlTm90Rm91bmQ7XG4gICAgICAgIGNvbnN0IG1ldGhvZENvbmZpZyA9ICh0eXBlb2YgdGhpcy5tZXRob2RzLmRlbGV0ZSA9PT0gJ29iamVjdCcgJiYgdGhpcy5tZXRob2RzLmRlbGV0ZSkgfHwge307XG4gICAgICAgIGNvbnN0IHJlcU9wdHMgPSBleHRlbmQodHJ1ZSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIHVyaTogJycsXG4gICAgICAgIH0sIG1ldGhvZENvbmZpZy5yZXFPcHRzLCB7XG4gICAgICAgICAgICBxczogb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBgcmVxdWVzdGAgbWV0aG9kIG1heSBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB0byBob2xkIGFueSBzcGVjaWFsXG4gICAgICAgIC8vIGJlaGF2aW9yLiBFbnN1cmUgd2UgY2FsbCB0aGUgb3JpZ2luYWwgYHJlcXVlc3RgIG1ldGhvZC5cbiAgICAgICAgU2VydmljZU9iamVjdC5wcm90b3R5cGUucmVxdWVzdC5jYWxsKHRoaXMsIHJlcU9wdHMsIChlcnIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQwNCAmJiBpZ25vcmVOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBleGlzdHMob3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRpb25zLCBjYWxsYmFja10gPSB1dGlsXzEudXRpbC5tYXliZU9wdGlvbnNPckNhbGxiYWNrKG9wdGlvbnNPckNhbGxiYWNrLCBjYik7XG4gICAgICAgIHRoaXMuZ2V0KG9wdGlvbnMsIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQob3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgW29wdHMsIGNhbGxiYWNrXSA9IHV0aWxfMS51dGlsLm1heWJlT3B0aW9uc09yQ2FsbGJhY2sob3B0aW9uc09yQ2FsbGJhY2ssIGNiKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICBjb25zdCBhdXRvQ3JlYXRlID0gb3B0aW9ucy5hdXRvQ3JlYXRlICYmIHR5cGVvZiB0aGlzLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuYXV0b0NyZWF0ZTtcbiAgICAgICAgZnVuY3Rpb24gb25DcmVhdGUoZXJyLCBpbnN0YW5jZSwgYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQwOSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsLCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaW5zdGFuY2UsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldE1ldGFkYXRhKG9wdGlvbnMsIChlcnIsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MDQgJiYgYXV0b0NyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKG9uQ3JlYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcmVhdGUoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc2VsZiwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TWV0YWRhdGEob3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRpb25zLCBjYWxsYmFja10gPSB1dGlsXzEudXRpbC5tYXliZU9wdGlvbnNPckNhbGxiYWNrKG9wdGlvbnNPckNhbGxiYWNrLCBjYik7XG4gICAgICAgIGNvbnN0IG1ldGhvZENvbmZpZyA9ICh0eXBlb2YgdGhpcy5tZXRob2RzLmdldE1ldGFkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdGhpcy5tZXRob2RzLmdldE1ldGFkYXRhKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIGNvbnN0IHJlcU9wdHMgPSBleHRlbmQodHJ1ZSwge1xuICAgICAgICAgICAgdXJpOiAnJyxcbiAgICAgICAgfSwgbWV0aG9kQ29uZmlnLnJlcU9wdHMsIHtcbiAgICAgICAgICAgIHFzOiBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIGByZXF1ZXN0YCBtZXRob2QgbWF5IGhhdmUgYmVlbiBvdmVycmlkZGVuIHRvIGhvbGQgYW55IHNwZWNpYWxcbiAgICAgICAgLy8gYmVoYXZpb3IuIEVuc3VyZSB3ZSBjYWxsIHRoZSBvcmlnaW5hbCBgcmVxdWVzdGAgbWV0aG9kLlxuICAgICAgICBTZXJ2aWNlT2JqZWN0LnByb3RvdHlwZS5yZXF1ZXN0LmNhbGwodGhpcywgcmVxT3B0cywgKGVyciwgYm9keSwgcmVzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhID0gYm9keTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgdGhpcy5tZXRhZGF0YSwgcmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdXNlcidzIGN1c3RvbSByZXF1ZXN0IGludGVyY2VwdG9ycy5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SW50ZXJjZXB0b3JzKCkge1xuICAgICAgICAvLyBJbnRlcmNlcHRvcnMgc2hvdWxkIGJlIHJldHVybmVkIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgYXNzaWduZWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSW50ZXJjZXB0b3JzID0gdGhpcy5pbnRlcmNlcHRvcnNcbiAgICAgICAgICAgIC5maWx0ZXIoaW50ZXJjZXB0b3IgPT4gdHlwZW9mIGludGVyY2VwdG9yLnJlcXVlc3QgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAubWFwKGludGVyY2VwdG9yID0+IGludGVyY2VwdG9yLnJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0UmVxdWVzdEludGVyY2VwdG9ycygpLmNvbmNhdChsb2NhbEludGVyY2VwdG9ycyk7XG4gICAgfVxuICAgIHNldE1ldGFkYXRhKG1ldGFkYXRhLCBvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcbiAgICAgICAgY29uc3QgW29wdGlvbnMsIGNhbGxiYWNrXSA9IHV0aWxfMS51dGlsLm1heWJlT3B0aW9uc09yQ2FsbGJhY2sob3B0aW9uc09yQ2FsbGJhY2ssIGNiKTtcbiAgICAgICAgY29uc3QgbWV0aG9kQ29uZmlnID0gKHR5cGVvZiB0aGlzLm1ldGhvZHMuc2V0TWV0YWRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0aGlzLm1ldGhvZHMuc2V0TWV0YWRhdGEpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgY29uc3QgcmVxT3B0cyA9IGV4dGVuZCh0cnVlLCB7fSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgdXJpOiAnJyxcbiAgICAgICAgfSwgbWV0aG9kQ29uZmlnLnJlcU9wdHMsIHtcbiAgICAgICAgICAgIGpzb246IG1ldGFkYXRhLFxuICAgICAgICAgICAgcXM6IG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgYHJlcXVlc3RgIG1ldGhvZCBtYXkgaGF2ZSBiZWVuIG92ZXJyaWRkZW4gdG8gaG9sZCBhbnkgc3BlY2lhbFxuICAgICAgICAvLyBiZWhhdmlvci4gRW5zdXJlIHdlIGNhbGwgdGhlIG9yaWdpbmFsIGByZXF1ZXN0YCBtZXRob2QuXG4gICAgICAgIFNlcnZpY2VPYmplY3QucHJvdG90eXBlLnJlcXVlc3QuY2FsbCh0aGlzLCByZXFPcHRzLCAoZXJyLCBib2R5LCByZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEgPSBib2R5O1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB0aGlzLm1ldGFkYXRhLCByZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdF8ocmVxT3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgcmVxT3B0cyA9IGV4dGVuZCh0cnVlLCB7fSwgcmVxT3B0cyk7XG4gICAgICAgIGlmICh0aGlzLnByb2plY3RJZCkge1xuICAgICAgICAgICAgcmVxT3B0cy5wcm9qZWN0SWQgPSB0aGlzLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Fic29sdXRlVXJsID0gcmVxT3B0cy51cmkuaW5kZXhPZignaHR0cCcpID09PSAwO1xuICAgICAgICBjb25zdCB1cmlDb21wb25lbnRzID0gW3RoaXMuYmFzZVVybCwgdGhpcy5pZCB8fCAnJywgcmVxT3B0cy51cmldO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZVVybCkge1xuICAgICAgICAgICAgdXJpQ29tcG9uZW50cy5zcGxpY2UoMCwgdXJpQ29tcG9uZW50cy5pbmRleE9mKHJlcU9wdHMudXJpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxT3B0cy51cmkgPSB1cmlDb21wb25lbnRzXG4gICAgICAgICAgICAuZmlsdGVyKHggPT4geC50cmltKCkpIC8vIExpbWl0IHRvIG5vbi1lbXB0eSBzdHJpbmdzLlxuICAgICAgICAgICAgLm1hcCh1cmlDb21wb25lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJpbVNsYXNoZXNSZWdleCA9IC9eXFwvKnxcXC8qJC9nO1xuICAgICAgICAgICAgcmV0dXJuIHVyaUNvbXBvbmVudC5yZXBsYWNlKHRyaW1TbGFzaGVzUmVnZXgsICcnKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcvJyk7XG4gICAgICAgIGNvbnN0IGNoaWxkSW50ZXJjZXB0b3JzID0gYXJyaWZ5KHJlcU9wdHMuaW50ZXJjZXB0b3JzXyk7XG4gICAgICAgIGNvbnN0IGxvY2FsSW50ZXJjZXB0b3JzID0gW10uc2xpY2UuY2FsbCh0aGlzLmludGVyY2VwdG9ycyk7XG4gICAgICAgIHJlcU9wdHMuaW50ZXJjZXB0b3JzXyA9IGNoaWxkSW50ZXJjZXB0b3JzLmNvbmNhdChsb2NhbEludGVyY2VwdG9ycyk7XG4gICAgICAgIGlmIChyZXFPcHRzLnNob3VsZFJldHVyblN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJlcXVlc3RTdHJlYW0ocmVxT3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQucmVxdWVzdChyZXFPcHRzLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJlcXVlc3QocmVxT3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0XyhyZXFPcHRzLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgYW4gYXV0aGVudGljYXRlZCBBUEkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXFPcHRzIC0gUmVxdWVzdCBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byBgcmVxdWVzdGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcU9wdHMudXJpIC0gQSBVUkkgcmVsYXRpdmUgdG8gdGhlIGJhc2VVcmwuXG4gICAgICovXG4gICAgcmVxdWVzdFN0cmVhbShyZXFPcHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBleHRlbmQodHJ1ZSwgcmVxT3B0cywgeyBzaG91bGRSZXR1cm5TdHJlYW06IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfKG9wdHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmljZU9iamVjdCA9IFNlcnZpY2VPYmplY3Q7XG4oMCwgcHJvbWlzaWZ5XzEucHJvbWlzaWZ5QWxsKShTZXJ2aWNlT2JqZWN0LCB7IGV4Y2x1ZGU6IFsnZ2V0UmVxdWVzdEludGVyY2VwdG9ycyddIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1vYmplY3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/common/build/src/service-object.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/common/build/src/service.js":
/*!****************************************************************!*\
  !*** ./node_modules/@google-cloud/common/build/src/service.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Service = exports.DEFAULT_PROJECT_ID_TOKEN = void 0;\n/*!\n * @module common/service\n */\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@google-cloud/common/build/src/util.js\");\nexports.DEFAULT_PROJECT_ID_TOKEN = '{{projectId}}';\nclass Service {\n    /**\n     * Service is a base class, meant to be inherited from by a \"service,\" like\n     * BigQuery or Storage.\n     *\n     * This handles making authenticated requests by exposing a `makeReq_`\n     * function.\n     *\n     * @constructor\n     * @alias module:common/service\n     *\n     * @param {object} config - Configuration object.\n     * @param {string} config.baseUrl - The base URL to make API requests to.\n     * @param {string[]} config.scopes - The scopes required for the request.\n     * @param {object=} options - [Configuration object](#/docs).\n     */\n    constructor(config, options = {}) {\n        this.baseUrl = config.baseUrl;\n        this.apiEndpoint = config.apiEndpoint;\n        this.timeout = options.timeout;\n        this.globalInterceptors = arrify(options.interceptors_);\n        this.interceptors = [];\n        this.packageJson = config.packageJson;\n        this.projectId = options.projectId || exports.DEFAULT_PROJECT_ID_TOKEN;\n        this.projectIdRequired = config.projectIdRequired !== false;\n        this.providedUserAgent = options.userAgent;\n        const reqCfg = extend({}, config, {\n            projectIdRequired: this.projectIdRequired,\n            projectId: this.projectId,\n            authClient: options.authClient,\n            credentials: options.credentials,\n            keyFile: options.keyFilename,\n            email: options.email,\n            token: options.token,\n        });\n        this.makeAuthenticatedRequest =\n            util_1.util.makeAuthenticatedRequestFactory(reqCfg);\n        this.authClient = this.makeAuthenticatedRequest.authClient;\n        this.getCredentials = this.makeAuthenticatedRequest.getCredentials;\n        const isCloudFunctionEnv = !!process.env.FUNCTION_NAME;\n        if (isCloudFunctionEnv) {\n            this.interceptors.push({\n                request(reqOpts) {\n                    reqOpts.forever = false;\n                    return reqOpts;\n                },\n            });\n        }\n    }\n    /**\n     * Return the user's custom request interceptors.\n     */\n    getRequestInterceptors() {\n        // Interceptors should be returned in the order they were assigned.\n        return [].slice\n            .call(this.globalInterceptors)\n            .concat(this.interceptors)\n            .filter(interceptor => typeof interceptor.request === 'function')\n            .map(interceptor => interceptor.request);\n    }\n    getProjectId(callback) {\n        if (!callback) {\n            return this.getProjectIdAsync();\n        }\n        this.getProjectIdAsync().then(p => callback(null, p), callback);\n    }\n    async getProjectIdAsync() {\n        const projectId = await this.authClient.getProjectId();\n        if (this.projectId === exports.DEFAULT_PROJECT_ID_TOKEN && projectId) {\n            this.projectId = projectId;\n        }\n        return this.projectId;\n    }\n    request_(reqOpts, callback) {\n        reqOpts = extend(true, {}, reqOpts, { timeout: this.timeout });\n        const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n        const uriComponents = [this.baseUrl];\n        if (this.projectIdRequired) {\n            if (reqOpts.projectId) {\n                uriComponents.push('projects');\n                uriComponents.push(reqOpts.projectId);\n            }\n            else {\n                uriComponents.push('projects');\n                uriComponents.push(this.projectId);\n            }\n        }\n        uriComponents.push(reqOpts.uri);\n        if (isAbsoluteUrl) {\n            uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n        }\n        reqOpts.uri = uriComponents\n            .map(uriComponent => {\n            const trimSlashesRegex = /^\\/*|\\/*$/g;\n            return uriComponent.replace(trimSlashesRegex, '');\n        })\n            .join('/')\n            // Some URIs have colon separators.\n            // Bad: https://.../projects/:list\n            // Good: https://.../projects:list\n            .replace(/\\/:/g, ':');\n        const requestInterceptors = this.getRequestInterceptors();\n        arrify(reqOpts.interceptors_).forEach(interceptor => {\n            if (typeof interceptor.request === 'function') {\n                requestInterceptors.push(interceptor.request);\n            }\n        });\n        requestInterceptors.forEach(requestInterceptor => {\n            reqOpts = requestInterceptor(reqOpts);\n        });\n        delete reqOpts.interceptors_;\n        const pkg = this.packageJson;\n        let userAgent = util_1.util.getUserAgentFromPackageJson(pkg);\n        if (this.providedUserAgent) {\n            userAgent = `${this.providedUserAgent} ${userAgent}`;\n        }\n        reqOpts.headers = extend({}, reqOpts.headers, {\n            'User-Agent': userAgent,\n            'x-goog-api-client': `gl-node/${process.versions.node} gccl/${pkg.version}`,\n        });\n        if (reqOpts.shouldReturnStream) {\n            return this.makeAuthenticatedRequest(reqOpts);\n        }\n        else {\n            this.makeAuthenticatedRequest(reqOpts, callback);\n        }\n    }\n    /**\n     * Make an authenticated API request.\n     *\n     * @param {object} reqOpts - Request options that are passed to `request`.\n     * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n     * @param {function} callback - The callback function passed to `request`.\n     */\n    request(reqOpts, callback) {\n        Service.prototype.request_.call(this, reqOpts, callback);\n    }\n    /**\n     * Make an authenticated API request.\n     *\n     * @param {object} reqOpts - Request options that are passed to `request`.\n     * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n     */\n    requestStream(reqOpts) {\n        const opts = extend(true, reqOpts, { shouldReturnStream: true });\n        return Service.prototype.request_.call(this, opts);\n    }\n}\nexports.Service = Service;\n//# sourceMappingURL=service.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9jb21tb24vYnVpbGQvc3JjL3NlcnZpY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLDJFQUFRO0FBQy9CLGdDQUFnQyxNQUFNLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCLEVBQUUsVUFBVTtBQUMvRDtBQUNBLG1DQUFtQztBQUNuQztBQUNBLDRDQUE0Qyx1QkFBdUIsT0FBTyxZQUFZO0FBQ3RGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsNkNBQTZDLDBCQUEwQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9jb21tb24vYnVpbGQvc3JjL3NlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmljZSA9IGV4cG9ydHMuREVGQVVMVF9QUk9KRUNUX0lEX1RPS0VOID0gdm9pZCAwO1xuLyohXG4gKiBAbW9kdWxlIGNvbW1vbi9zZXJ2aWNlXG4gKi9cbmNvbnN0IGFycmlmeSA9IHJlcXVpcmUoXCJhcnJpZnlcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMuREVGQVVMVF9QUk9KRUNUX0lEX1RPS0VOID0gJ3t7cHJvamVjdElkfX0nO1xuY2xhc3MgU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogU2VydmljZSBpcyBhIGJhc2UgY2xhc3MsIG1lYW50IHRvIGJlIGluaGVyaXRlZCBmcm9tIGJ5IGEgXCJzZXJ2aWNlLFwiIGxpa2VcbiAgICAgKiBCaWdRdWVyeSBvciBTdG9yYWdlLlxuICAgICAqXG4gICAgICogVGhpcyBoYW5kbGVzIG1ha2luZyBhdXRoZW50aWNhdGVkIHJlcXVlc3RzIGJ5IGV4cG9zaW5nIGEgYG1ha2VSZXFfYFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTpjb21tb24vc2VydmljZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuYmFzZVVybCAtIFRoZSBiYXNlIFVSTCB0byBtYWtlIEFQSSByZXF1ZXN0cyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb25maWcuc2NvcGVzIC0gVGhlIHNjb3BlcyByZXF1aXJlZCBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIC0gW0NvbmZpZ3VyYXRpb24gb2JqZWN0XSgjL2RvY3MpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsO1xuICAgICAgICB0aGlzLmFwaUVuZHBvaW50ID0gY29uZmlnLmFwaUVuZHBvaW50O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuZ2xvYmFsSW50ZXJjZXB0b3JzID0gYXJyaWZ5KG9wdGlvbnMuaW50ZXJjZXB0b3JzXyk7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gW107XG4gICAgICAgIHRoaXMucGFja2FnZUpzb24gPSBjb25maWcucGFja2FnZUpzb247XG4gICAgICAgIHRoaXMucHJvamVjdElkID0gb3B0aW9ucy5wcm9qZWN0SWQgfHwgZXhwb3J0cy5ERUZBVUxUX1BST0pFQ1RfSURfVE9LRU47XG4gICAgICAgIHRoaXMucHJvamVjdElkUmVxdWlyZWQgPSBjb25maWcucHJvamVjdElkUmVxdWlyZWQgIT09IGZhbHNlO1xuICAgICAgICB0aGlzLnByb3ZpZGVkVXNlckFnZW50ID0gb3B0aW9ucy51c2VyQWdlbnQ7XG4gICAgICAgIGNvbnN0IHJlcUNmZyA9IGV4dGVuZCh7fSwgY29uZmlnLCB7XG4gICAgICAgICAgICBwcm9qZWN0SWRSZXF1aXJlZDogdGhpcy5wcm9qZWN0SWRSZXF1aXJlZCxcbiAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5wcm9qZWN0SWQsXG4gICAgICAgICAgICBhdXRoQ2xpZW50OiBvcHRpb25zLmF1dGhDbGllbnQsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogb3B0aW9ucy5jcmVkZW50aWFscyxcbiAgICAgICAgICAgIGtleUZpbGU6IG9wdGlvbnMua2V5RmlsZW5hbWUsXG4gICAgICAgICAgICBlbWFpbDogb3B0aW9ucy5lbWFpbCxcbiAgICAgICAgICAgIHRva2VuOiBvcHRpb25zLnRva2VuLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYWtlQXV0aGVudGljYXRlZFJlcXVlc3QgPVxuICAgICAgICAgICAgdXRpbF8xLnV0aWwubWFrZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0RmFjdG9yeShyZXFDZmcpO1xuICAgICAgICB0aGlzLmF1dGhDbGllbnQgPSB0aGlzLm1ha2VBdXRoZW50aWNhdGVkUmVxdWVzdC5hdXRoQ2xpZW50O1xuICAgICAgICB0aGlzLmdldENyZWRlbnRpYWxzID0gdGhpcy5tYWtlQXV0aGVudGljYXRlZFJlcXVlc3QuZ2V0Q3JlZGVudGlhbHM7XG4gICAgICAgIGNvbnN0IGlzQ2xvdWRGdW5jdGlvbkVudiA9ICEhcHJvY2Vzcy5lbnYuRlVOQ1RJT05fTkFNRTtcbiAgICAgICAgaWYgKGlzQ2xvdWRGdW5jdGlvbkVudikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdChyZXFPcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcU9wdHMuZm9yZXZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxT3B0cztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB1c2VyJ3MgY3VzdG9tIHJlcXVlc3QgaW50ZXJjZXB0b3JzLlxuICAgICAqL1xuICAgIGdldFJlcXVlc3RJbnRlcmNlcHRvcnMoKSB7XG4gICAgICAgIC8vIEludGVyY2VwdG9ycyBzaG91bGQgYmUgcmV0dXJuZWQgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBhc3NpZ25lZC5cbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmdsb2JhbEludGVyY2VwdG9ycylcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5pbnRlcmNlcHRvcnMpXG4gICAgICAgICAgICAuZmlsdGVyKGludGVyY2VwdG9yID0+IHR5cGVvZiBpbnRlcmNlcHRvci5yZXF1ZXN0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgLm1hcChpbnRlcmNlcHRvciA9PiBpbnRlcmNlcHRvci5yZXF1ZXN0KTtcbiAgICB9XG4gICAgZ2V0UHJvamVjdElkKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2plY3RJZEFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0SWRBc3luYygpLnRoZW4ocCA9PiBjYWxsYmFjayhudWxsLCBwKSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYyBnZXRQcm9qZWN0SWRBc3luYygpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gYXdhaXQgdGhpcy5hdXRoQ2xpZW50LmdldFByb2plY3RJZCgpO1xuICAgICAgICBpZiAodGhpcy5wcm9qZWN0SWQgPT09IGV4cG9ydHMuREVGQVVMVF9QUk9KRUNUX0lEX1RPS0VOICYmIHByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdElkO1xuICAgIH1cbiAgICByZXF1ZXN0XyhyZXFPcHRzLCBjYWxsYmFjaykge1xuICAgICAgICByZXFPcHRzID0gZXh0ZW5kKHRydWUsIHt9LCByZXFPcHRzLCB7IHRpbWVvdXQ6IHRoaXMudGltZW91dCB9KTtcbiAgICAgICAgY29uc3QgaXNBYnNvbHV0ZVVybCA9IHJlcU9wdHMudXJpLmluZGV4T2YoJ2h0dHAnKSA9PT0gMDtcbiAgICAgICAgY29uc3QgdXJpQ29tcG9uZW50cyA9IFt0aGlzLmJhc2VVcmxdO1xuICAgICAgICBpZiAodGhpcy5wcm9qZWN0SWRSZXF1aXJlZCkge1xuICAgICAgICAgICAgaWYgKHJlcU9wdHMucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgdXJpQ29tcG9uZW50cy5wdXNoKCdwcm9qZWN0cycpO1xuICAgICAgICAgICAgICAgIHVyaUNvbXBvbmVudHMucHVzaChyZXFPcHRzLnByb2plY3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmlDb21wb25lbnRzLnB1c2goJ3Byb2plY3RzJyk7XG4gICAgICAgICAgICAgICAgdXJpQ29tcG9uZW50cy5wdXNoKHRoaXMucHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cmlDb21wb25lbnRzLnB1c2gocmVxT3B0cy51cmkpO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZVVybCkge1xuICAgICAgICAgICAgdXJpQ29tcG9uZW50cy5zcGxpY2UoMCwgdXJpQ29tcG9uZW50cy5pbmRleE9mKHJlcU9wdHMudXJpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxT3B0cy51cmkgPSB1cmlDb21wb25lbnRzXG4gICAgICAgICAgICAubWFwKHVyaUNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmltU2xhc2hlc1JlZ2V4ID0gL15cXC8qfFxcLyokL2c7XG4gICAgICAgICAgICByZXR1cm4gdXJpQ29tcG9uZW50LnJlcGxhY2UodHJpbVNsYXNoZXNSZWdleCwgJycpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJy8nKVxuICAgICAgICAgICAgLy8gU29tZSBVUklzIGhhdmUgY29sb24gc2VwYXJhdG9ycy5cbiAgICAgICAgICAgIC8vIEJhZDogaHR0cHM6Ly8uLi4vcHJvamVjdHMvOmxpc3RcbiAgICAgICAgICAgIC8vIEdvb2Q6IGh0dHBzOi8vLi4uL3Byb2plY3RzOmxpc3RcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC86L2csICc6Jyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRvcnMgPSB0aGlzLmdldFJlcXVlc3RJbnRlcmNlcHRvcnMoKTtcbiAgICAgICAgYXJyaWZ5KHJlcU9wdHMuaW50ZXJjZXB0b3JzXykuZm9yRWFjaChpbnRlcmNlcHRvciA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SW50ZXJjZXB0b3JzLnB1c2goaW50ZXJjZXB0b3IucmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0SW50ZXJjZXB0b3JzLmZvckVhY2gocmVxdWVzdEludGVyY2VwdG9yID0+IHtcbiAgICAgICAgICAgIHJlcU9wdHMgPSByZXF1ZXN0SW50ZXJjZXB0b3IocmVxT3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgcmVxT3B0cy5pbnRlcmNlcHRvcnNfO1xuICAgICAgICBjb25zdCBwa2cgPSB0aGlzLnBhY2thZ2VKc29uO1xuICAgICAgICBsZXQgdXNlckFnZW50ID0gdXRpbF8xLnV0aWwuZ2V0VXNlckFnZW50RnJvbVBhY2thZ2VKc29uKHBrZyk7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVkVXNlckFnZW50KSB7XG4gICAgICAgICAgICB1c2VyQWdlbnQgPSBgJHt0aGlzLnByb3ZpZGVkVXNlckFnZW50fSAke3VzZXJBZ2VudH1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcU9wdHMuaGVhZGVycyA9IGV4dGVuZCh7fSwgcmVxT3B0cy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IHVzZXJBZ2VudCxcbiAgICAgICAgICAgICd4LWdvb2ctYXBpLWNsaWVudCc6IGBnbC1ub2RlLyR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSBnY2NsLyR7cGtnLnZlcnNpb259YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXFPcHRzLnNob3VsZFJldHVyblN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0KHJlcU9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWtlQXV0aGVudGljYXRlZFJlcXVlc3QocmVxT3B0cywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgYW4gYXV0aGVudGljYXRlZCBBUEkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXFPcHRzIC0gUmVxdWVzdCBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byBgcmVxdWVzdGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcU9wdHMudXJpIC0gQSBVUkkgcmVsYXRpdmUgdG8gdGhlIGJhc2VVcmwuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gcGFzc2VkIHRvIGByZXF1ZXN0YC5cbiAgICAgKi9cbiAgICByZXF1ZXN0KHJlcU9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIFNlcnZpY2UucHJvdG90eXBlLnJlcXVlc3RfLmNhbGwodGhpcywgcmVxT3B0cywgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIGFuIGF1dGhlbnRpY2F0ZWQgQVBJIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVxT3B0cyAtIFJlcXVlc3Qgb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gYHJlcXVlc3RgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXFPcHRzLnVyaSAtIEEgVVJJIHJlbGF0aXZlIHRvIHRoZSBiYXNlVXJsLlxuICAgICAqL1xuICAgIHJlcXVlc3RTdHJlYW0ocmVxT3B0cykge1xuICAgICAgICBjb25zdCBvcHRzID0gZXh0ZW5kKHRydWUsIHJlcU9wdHMsIHsgc2hvdWxkUmV0dXJuU3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gU2VydmljZS5wcm90b3R5cGUucmVxdWVzdF8uY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZpY2UgPSBTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/common/build/src/service.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/common/build/src/util.js":
/*!*************************************************************!*\
  !*** ./node_modules/@google-cloud/common/build/src/util.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.util = exports.Util = exports.PartialFailureError = exports.ApiError = void 0;\n/*!\n * @module common/util\n */\nconst projectify_1 = __webpack_require__(/*! @google-cloud/projectify */ \"(rsc)/./node_modules/@google-cloud/projectify/build/src/index.js\");\nconst htmlEntities = __webpack_require__(/*! html-entities */ \"(rsc)/./node_modules/html-entities/dist/commonjs/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\nconst retryRequest = __webpack_require__(/*! retry-request */ \"(rsc)/./node_modules/retry-request/index.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst teeny_request_1 = __webpack_require__(/*! teeny-request */ \"(rsc)/./node_modules/teeny-request/build/src/index.js\");\nconst service_1 = __webpack_require__(/*! ./service */ \"(rsc)/./node_modules/@google-cloud/common/build/src/service.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = __webpack_require__(/*! duplexify */ \"(rsc)/./node_modules/duplexify/index.js\");\nconst requestDefaults = {\n    timeout: 60000,\n    gzip: true,\n    forever: true,\n    pool: {\n        maxSockets: Infinity,\n    },\n};\n/**\n * Default behavior: Automatically retry retriable server errors.\n *\n * @const {boolean}\n * @private\n */\nconst AUTO_RETRY_DEFAULT = true;\n/**\n * Default behavior: Only attempt to retry retriable errors 3 times.\n *\n * @const {number}\n * @private\n */\nconst MAX_RETRY_DEFAULT = 3;\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nclass ApiError extends Error {\n    constructor(errorBodyOrMessage) {\n        super();\n        if (typeof errorBodyOrMessage !== 'object') {\n            this.message = errorBodyOrMessage || '';\n            return;\n        }\n        const errorBody = errorBodyOrMessage;\n        this.code = errorBody.code;\n        this.errors = errorBody.errors;\n        this.response = errorBody.response;\n        try {\n            this.errors = JSON.parse(this.response.body).error.errors;\n        }\n        catch (e) {\n            this.errors = errorBody.errors;\n        }\n        this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n        Error.captureStackTrace(this);\n    }\n    /**\n     * Pieces together an error message by combining all unique error messages\n     * returned from a single GoogleError\n     *\n     * @private\n     *\n     * @param {GoogleErrorBody} err The original error.\n     * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n     * @returns {string}\n     */\n    static createMultiErrorMessage(err, errors) {\n        const messages = new Set();\n        if (err.message) {\n            messages.add(err.message);\n        }\n        if (errors && errors.length) {\n            errors.forEach(({ message }) => messages.add(message));\n        }\n        else if (err.response && err.response.body) {\n            messages.add(htmlEntities.decode(err.response.body.toString()));\n        }\n        else if (!err.message) {\n            messages.add('A failure occurred during this request.');\n        }\n        let messageArr = Array.from(messages);\n        if (messageArr.length > 1) {\n            messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n            messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n            messageArr.push('\\n');\n        }\n        return messageArr.join('\\n');\n    }\n}\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\nclass PartialFailureError extends Error {\n    constructor(b) {\n        super();\n        const errorObject = b;\n        this.errors = errorObject.errors;\n        this.name = 'PartialFailureError';\n        this.response = errorObject.response;\n        this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n    }\n}\nexports.PartialFailureError = PartialFailureError;\nclass Util {\n    constructor() {\n        this.ApiError = ApiError;\n        this.PartialFailureError = PartialFailureError;\n    }\n    /**\n     * No op.\n     *\n     * @example\n     * function doSomething(callback) {\n     *   callback = callback || noop;\n     * }\n     */\n    noop() { }\n    /**\n     * Uniformly process an API response.\n     *\n     * @param {*} err - Error value.\n     * @param {*} resp - Response value.\n     * @param {*} body - Body value.\n     * @param {function} callback - The callback function.\n     */\n    handleResp(err, resp, body, callback) {\n        callback = callback || util.noop;\n        const parsedResp = extend(true, { err: err || null }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n        // Assign the parsed body to resp.body, even if { json: false } was passed\n        // as a request option.\n        // We assume that nobody uses the previously unparsed value of resp.body.\n        if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n            parsedResp.resp.body = parsedResp.body;\n        }\n        if (parsedResp.err && resp) {\n            parsedResp.err.response = resp;\n        }\n        callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n    }\n    /**\n     * Sniff an incoming HTTP response message for errors.\n     *\n     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.resp - The original response object.\n     */\n    parseHttpRespMessage(httpRespMessage) {\n        const parsedHttpRespMessage = {\n            resp: httpRespMessage,\n        };\n        if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n            // Unknown error. Format according to ApiError standard.\n            parsedHttpRespMessage.err = new ApiError({\n                errors: new Array(),\n                code: httpRespMessage.statusCode,\n                message: httpRespMessage.statusMessage,\n                response: httpRespMessage,\n            });\n        }\n        return parsedHttpRespMessage;\n    }\n    /**\n     * Parse the response body from an HTTP request.\n     *\n     * @param {object} body - The response body.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.body - The original body value provided\n     *     will try to be JSON.parse'd. If it's successful, the parsed value will\n     * be returned here, otherwise the original value and an error will be returned.\n     */\n    parseHttpRespBody(body) {\n        const parsedHttpRespBody = {\n            body,\n        };\n        if (typeof body === 'string') {\n            try {\n                parsedHttpRespBody.body = JSON.parse(body);\n            }\n            catch (err) {\n                parsedHttpRespBody.body = body;\n            }\n        }\n        if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n            // Error from JSON API.\n            parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n        }\n        return parsedHttpRespBody;\n    }\n    /**\n     * Take a Duplexify stream, fetch an authenticated connection header, and\n     * create an outgoing writable stream.\n     *\n     * @param {Duplexify} dup - Duplexify stream.\n     * @param {object} options - Configuration object.\n     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n     * @param {object} options.metadata - Metadata to send at the head of the request.\n     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n     * @param {string=} options.request.method - Default: \"POST\".\n     * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n     * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n     */\n    makeWritableStream(dup, options, onComplete) {\n        onComplete = onComplete || util.noop;\n        const writeStream = new ProgressStream();\n        writeStream.on('progress', evt => dup.emit('progress', evt));\n        dup.setWritable(writeStream);\n        const defaultReqOpts = {\n            method: 'POST',\n            qs: {\n                uploadType: 'multipart',\n            },\n            timeout: 0,\n            maxRetries: 0,\n        };\n        const metadata = options.metadata || {};\n        const reqOpts = extend(true, defaultReqOpts, options.request, {\n            multipart: [\n                {\n                    'Content-Type': 'application/json',\n                    body: JSON.stringify(metadata),\n                },\n                {\n                    'Content-Type': metadata.contentType || 'application/octet-stream',\n                    body: writeStream,\n                },\n            ],\n        });\n        options.makeAuthenticatedRequest(reqOpts, {\n            onAuthenticated(err, authenticatedReqOpts) {\n                if (err) {\n                    dup.destroy(err);\n                    return;\n                }\n                const request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n                request(authenticatedReqOpts, (err, resp, body) => {\n                    util.handleResp(err, resp, body, (err, data) => {\n                        if (err) {\n                            dup.destroy(err);\n                            return;\n                        }\n                        dup.emit('response', resp);\n                        onComplete(data);\n                    });\n                });\n            },\n        });\n    }\n    /**\n     * Returns true if the API request should be retried, given the error that was\n     * given the first time the request was attempted. This is used for rate limit\n     * related errors as well as intermittent server errors.\n     *\n     * @param {error} err - The API error to check if it is appropriate to retry.\n     * @return {boolean} True if the API request should be retried, false otherwise.\n     */\n    shouldRetryRequest(err) {\n        if (err) {\n            if ([408, 429, 500, 502, 503, 504].indexOf(err.code) !== -1) {\n                return true;\n            }\n            if (err.errors) {\n                for (const e of err.errors) {\n                    const reason = e.reason;\n                    if (reason === 'rateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason === 'userRateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason && reason.includes('EAI_AGAIN')) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get a function for making authenticated requests.\n     *\n     * @param {object} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {object=} config.credentials - Credentials object.\n     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n     * @param {boolean=} config.useAuthWithCustomEndpoint - If true, will authenticate when using a custom endpoint. Default: false.\n     * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n     * @param {array} config.scopes - Array of scopes required for the API.\n     */\n    makeAuthenticatedRequestFactory(config) {\n        const googleAutoAuthConfig = extend({}, config);\n        if (googleAutoAuthConfig.projectId === service_1.DEFAULT_PROJECT_ID_TOKEN) {\n            delete googleAutoAuthConfig.projectId;\n        }\n        let authClient;\n        if (googleAutoAuthConfig.authClient instanceof google_auth_library_1.GoogleAuth) {\n            // Use an existing `GoogleAuth`\n            authClient = googleAutoAuthConfig.authClient;\n        }\n        else {\n            // Pass an `AuthClient` to `GoogleAuth`, if available\n            const config = {\n                ...googleAutoAuthConfig,\n                authClient: googleAutoAuthConfig.authClient,\n            };\n            authClient = new google_auth_library_1.GoogleAuth(config);\n        }\n        function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n            let stream;\n            let projectId;\n            const reqConfig = extend({}, config);\n            let activeRequest_;\n            if (!optionsOrCallback) {\n                stream = duplexify();\n                reqConfig.stream = stream;\n            }\n            const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n            const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n            async function setProjectId() {\n                projectId = await authClient.getProjectId();\n            }\n            const onAuthenticated = async (err, authenticatedReqOpts) => {\n                const authLibraryError = err;\n                const autoAuthFailed = err &&\n                    err.message.indexOf('Could not load the default credentials') > -1;\n                if (autoAuthFailed) {\n                    // Even though authentication failed, the API might not actually\n                    // care.\n                    authenticatedReqOpts = reqOpts;\n                }\n                if (!err || autoAuthFailed) {\n                    try {\n                        // Try with existing `projectId` value\n                        authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n                        err = null;\n                    }\n                    catch (e) {\n                        if (e instanceof projectify_1.MissingProjectIdError) {\n                            // A `projectId` was required, but we don't have one.\n                            try {\n                                // Attempt to get the `projectId`\n                                await setProjectId();\n                                authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n                                err = null;\n                            }\n                            catch (e) {\n                                // Re-use the \"Could not load the default credentials error\" if\n                                // auto auth failed.\n                                err = err || e;\n                            }\n                        }\n                        else {\n                            // Some other error unrelated to missing `projectId`\n                            err = err || e;\n                        }\n                    }\n                }\n                if (err) {\n                    if (stream) {\n                        stream.destroy(err);\n                    }\n                    else {\n                        const fn = options && options.onAuthenticated\n                            ? options.onAuthenticated\n                            : callback;\n                        fn(err);\n                    }\n                    return;\n                }\n                if (options && options.onAuthenticated) {\n                    options.onAuthenticated(null, authenticatedReqOpts);\n                }\n                else {\n                    activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, (apiResponseError, ...params) => {\n                        if (apiResponseError &&\n                            apiResponseError.code === 401 &&\n                            authLibraryError) {\n                            // Re-use the \"Could not load the default credentials error\" if\n                            // the API request failed due to missing credentials.\n                            apiResponseError = authLibraryError;\n                        }\n                        callback(apiResponseError, ...params);\n                    });\n                }\n            };\n            const prepareRequest = async () => {\n                try {\n                    const getProjectId = async () => {\n                        if (config.projectId &&\n                            config.projectId !== service_1.DEFAULT_PROJECT_ID_TOKEN) {\n                            // The user provided a project ID. We don't need to check with the\n                            // auth client, it could be incorrect.\n                            return config.projectId;\n                        }\n                        if (config.projectIdRequired === false) {\n                            // A projectId is not required. Return the default.\n                            return service_1.DEFAULT_PROJECT_ID_TOKEN;\n                        }\n                        return setProjectId();\n                    };\n                    const authorizeRequest = async () => {\n                        if (reqConfig.customEndpoint &&\n                            !reqConfig.useAuthWithCustomEndpoint) {\n                            // Using a custom API override. Do not use `google-auth-library` for\n                            // authentication. (ex: connecting to a local Datastore server)\n                            return reqOpts;\n                        }\n                        else {\n                            return authClient.authorizeRequest(reqOpts);\n                        }\n                    };\n                    const [_projectId, authorizedReqOpts] = await Promise.all([\n                        getProjectId(),\n                        authorizeRequest(),\n                    ]);\n                    if (_projectId) {\n                        projectId = _projectId;\n                    }\n                    return onAuthenticated(null, authorizedReqOpts);\n                }\n                catch (e) {\n                    return onAuthenticated(e);\n                }\n            };\n            prepareRequest();\n            if (stream) {\n                return stream;\n            }\n            return {\n                abort() {\n                    setImmediate(() => {\n                        if (activeRequest_) {\n                            activeRequest_.abort();\n                            activeRequest_ = null;\n                        }\n                    });\n                },\n            };\n        }\n        const mar = makeAuthenticatedRequest;\n        mar.getCredentials = authClient.getCredentials.bind(authClient);\n        mar.authClient = authClient;\n        return mar;\n    }\n    /**\n     * Make a request through the `retryRequest` module with built-in error\n     * handling and exponential back off.\n     *\n     * @param {object} reqOpts - Request options in the format `request` expects.\n     * @param {object=} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {number=} config.maxRetries - Maximum number of automatic retries\n     *     attempted before returning the error. (default: 3)\n     * @param {object=} config.request - HTTP module for request calls.\n     * @param {function} callback - The callback function.\n     */\n    makeRequest(reqOpts, config, callback) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        let autoRetryValue = AUTO_RETRY_DEFAULT;\n        if (config.autoRetry !== undefined &&\n            ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined) {\n            throw new ApiError('autoRetry is deprecated. Use retryOptions.autoRetry instead.');\n        }\n        else if (config.autoRetry !== undefined) {\n            autoRetryValue = config.autoRetry;\n        }\n        else if (((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.autoRetry) !== undefined) {\n            autoRetryValue = config.retryOptions.autoRetry;\n        }\n        let maxRetryValue = MAX_RETRY_DEFAULT;\n        if (config.maxRetries && ((_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetries)) {\n            throw new ApiError('maxRetries is deprecated. Use retryOptions.maxRetries instead.');\n        }\n        else if (config.maxRetries) {\n            maxRetryValue = config.maxRetries;\n        }\n        else if ((_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.maxRetries) {\n            maxRetryValue = config.retryOptions.maxRetries;\n        }\n        const options = {\n            request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n            retries: autoRetryValue !== false ? maxRetryValue : 0,\n            noResponseRetries: autoRetryValue !== false ? maxRetryValue : 0,\n            shouldRetryFn(httpRespMessage) {\n                var _a, _b;\n                const err = util.parseHttpRespMessage(httpRespMessage).err;\n                if ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryableErrorFn) {\n                    return err && ((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryableErrorFn(err));\n                }\n                return err && util.shouldRetryRequest(err);\n            },\n            maxRetryDelay: (_e = config.retryOptions) === null || _e === void 0 ? void 0 : _e.maxRetryDelay,\n            retryDelayMultiplier: (_f = config.retryOptions) === null || _f === void 0 ? void 0 : _f.retryDelayMultiplier,\n            totalTimeout: (_g = config.retryOptions) === null || _g === void 0 ? void 0 : _g.totalTimeout,\n        };\n        if (typeof reqOpts.maxRetries === 'number') {\n            options.retries = reqOpts.maxRetries;\n        }\n        if (!config.stream) {\n            return retryRequest(reqOpts, options, (err, response, body) => {\n                util.handleResp(err, response, body, callback);\n            });\n        }\n        const dup = config.stream;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let requestStream;\n        const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n        if (isGetRequest) {\n            requestStream = retryRequest(reqOpts, options);\n            dup.setReadable(requestStream);\n        }\n        else {\n            // Streaming writable HTTP requests cannot be retried.\n            requestStream = options.request(reqOpts);\n            dup.setWritable(requestStream);\n        }\n        // Replay the Request events back to the stream.\n        requestStream\n            .on('error', dup.destroy.bind(dup))\n            .on('response', dup.emit.bind(dup, 'response'))\n            .on('complete', dup.emit.bind(dup, 'complete'));\n        dup.abort = requestStream.abort;\n        return dup;\n    }\n    /**\n     * Decorate the options about to be made in a request.\n     *\n     * @param {object} reqOpts - The options to be passed to `request`.\n     * @param {string} projectId - The project ID.\n     * @return {object} reqOpts - The decorated reqOpts.\n     */\n    decorateRequest(reqOpts, projectId) {\n        delete reqOpts.autoPaginate;\n        delete reqOpts.autoPaginateVal;\n        delete reqOpts.objectMode;\n        if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n            delete reqOpts.qs.autoPaginate;\n            delete reqOpts.qs.autoPaginateVal;\n            reqOpts.qs = (0, projectify_1.replaceProjectIdToken)(reqOpts.qs, projectId);\n        }\n        if (Array.isArray(reqOpts.multipart)) {\n            reqOpts.multipart = reqOpts.multipart.map(part => {\n                return (0, projectify_1.replaceProjectIdToken)(part, projectId);\n            });\n        }\n        if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n            delete reqOpts.json.autoPaginate;\n            delete reqOpts.json.autoPaginateVal;\n            reqOpts.json = (0, projectify_1.replaceProjectIdToken)(reqOpts.json, projectId);\n        }\n        reqOpts.uri = (0, projectify_1.replaceProjectIdToken)(reqOpts.uri, projectId);\n        return reqOpts;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isCustomType(unknown, module) {\n        function getConstructorName(obj) {\n            return obj.constructor && obj.constructor.name.toLowerCase();\n        }\n        const moduleNameParts = module.split('/');\n        const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n        const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n        if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n            return false;\n        }\n        let walkingModule = unknown;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (getConstructorName(walkingModule) === parentModuleName) {\n                return true;\n            }\n            walkingModule = walkingModule.parent;\n            if (!walkingModule) {\n                return false;\n            }\n        }\n    }\n    /**\n     * Create a properly-formatted User-Agent string from a package.json file.\n     *\n     * @param {object} packageJson - A module's package.json file.\n     * @return {string} userAgent - The formatted User-Agent string.\n     */\n    getUserAgentFromPackageJson(packageJson) {\n        const hyphenatedPackageName = packageJson.name\n            .replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n            .replace('/', '-'); // For UA spec-compliance purposes.\n        return hyphenatedPackageName + '/' + packageJson.version;\n    }\n    /**\n     * Given two parameters, figure out if this is either:\n     *  - Just a callback function\n     *  - An options object, and then a callback function\n     * @param optionsOrCallback An options object or callback.\n     * @param cb A potentially undefined callback.\n     */\n    maybeOptionsOrCallback(optionsOrCallback, cb) {\n        return typeof optionsOrCallback === 'function'\n            ? [{}, optionsOrCallback]\n            : [optionsOrCallback, cb];\n    }\n}\nexports.Util = Util;\n/**\n * Basic Passthrough Stream that records the number of bytes read\n * every time the cursor is moved.\n */\nclass ProgressStream extends stream_1.Transform {\n    constructor() {\n        super(...arguments);\n        this.bytesRead = 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _transform(chunk, encoding, callback) {\n        this.bytesRead += chunk.length;\n        this.emit('progress', { bytesWritten: this.bytesRead, contentLength: '*' });\n        this.push(chunk);\n        callback();\n    }\n}\nconst util = new Util();\nexports.util = util;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9jb21tb24vYnVpbGQvc3JjL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWSxHQUFHLDJCQUEyQixHQUFHLGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxrR0FBMEI7QUFDdkQscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLDhCQUE4QixtQkFBTyxDQUFDLHdGQUFxQjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQyxrRUFBZTtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyw0RUFBZTtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBVztBQUNyQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQWtEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9jb21tb24vYnVpbGQvc3JjL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbCA9IGV4cG9ydHMuVXRpbCA9IGV4cG9ydHMuUGFydGlhbEZhaWx1cmVFcnJvciA9IGV4cG9ydHMuQXBpRXJyb3IgPSB2b2lkIDA7XG4vKiFcbiAqIEBtb2R1bGUgY29tbW9uL3V0aWxcbiAqL1xuY29uc3QgcHJvamVjdGlmeV8xID0gcmVxdWlyZShcIkBnb29nbGUtY2xvdWQvcHJvamVjdGlmeVwiKTtcbmNvbnN0IGh0bWxFbnRpdGllcyA9IHJlcXVpcmUoXCJodG1sLWVudGl0aWVzXCIpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZShcImV4dGVuZFwiKTtcbmNvbnN0IGdvb2dsZV9hdXRoX2xpYnJhcnlfMSA9IHJlcXVpcmUoXCJnb29nbGUtYXV0aC1saWJyYXJ5XCIpO1xuY29uc3QgcmV0cnlSZXF1ZXN0ID0gcmVxdWlyZShcInJldHJ5LXJlcXVlc3RcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCB0ZWVueV9yZXF1ZXN0XzEgPSByZXF1aXJlKFwidGVlbnktcmVxdWVzdFwiKTtcbmNvbnN0IHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5Jyk7XG5jb25zdCByZXF1ZXN0RGVmYXVsdHMgPSB7XG4gICAgdGltZW91dDogNjAwMDAsXG4gICAgZ3ppcDogdHJ1ZSxcbiAgICBmb3JldmVyOiB0cnVlLFxuICAgIHBvb2w6IHtcbiAgICAgICAgbWF4U29ja2V0czogSW5maW5pdHksXG4gICAgfSxcbn07XG4vKipcbiAqIERlZmF1bHQgYmVoYXZpb3I6IEF1dG9tYXRpY2FsbHkgcmV0cnkgcmV0cmlhYmxlIHNlcnZlciBlcnJvcnMuXG4gKlxuICogQGNvbnN0IHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgQVVUT19SRVRSWV9ERUZBVUxUID0gdHJ1ZTtcbi8qKlxuICogRGVmYXVsdCBiZWhhdmlvcjogT25seSBhdHRlbXB0IHRvIHJldHJ5IHJldHJpYWJsZSBlcnJvcnMgMyB0aW1lcy5cbiAqXG4gKiBAY29uc3Qge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IE1BWF9SRVRSWV9ERUZBVUxUID0gMztcbi8qKlxuICogQ3VzdG9tIGVycm9yIHR5cGUgZm9yIEFQSSBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yQm9keSAtIEVycm9yIG9iamVjdC5cbiAqL1xuY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JCb2R5T3JNZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JCb2R5T3JNZXNzYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JCb2R5T3JNZXNzYWdlIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGVycm9yQm9keU9yTWVzc2FnZTtcbiAgICAgICAgdGhpcy5jb2RlID0gZXJyb3JCb2R5LmNvZGU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JCb2R5LmVycm9ycztcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IGVycm9yQm9keS5yZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gSlNPTi5wYXJzZSh0aGlzLnJlc3BvbnNlLmJvZHkpLmVycm9yLmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvckJvZHkuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IEFwaUVycm9yLmNyZWF0ZU11bHRpRXJyb3JNZXNzYWdlKGVycm9yQm9keSwgdGhpcy5lcnJvcnMpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGllY2VzIHRvZ2V0aGVyIGFuIGVycm9yIG1lc3NhZ2UgYnkgY29tYmluaW5nIGFsbCB1bmlxdWUgZXJyb3IgbWVzc2FnZXNcbiAgICAgKiByZXR1cm5lZCBmcm9tIGEgc2luZ2xlIEdvb2dsZUVycm9yXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtHb29nbGVFcnJvckJvZHl9IGVyciBUaGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICogQHBhcmFtIHtHb29nbGVJbm5lckVycm9yW119IFtlcnJvcnNdIElubmVyIGVycm9ycywgaWYgYW55LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU11bHRpRXJyb3JNZXNzYWdlKGVyciwgZXJyb3JzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmFkZChlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvcnMuZm9yRWFjaCgoeyBtZXNzYWdlIH0pID0+IG1lc3NhZ2VzLmFkZChtZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5hZGQoaHRtbEVudGl0aWVzLmRlY29kZShlcnIucmVzcG9uc2UuYm9keS50b1N0cmluZygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWVyci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5hZGQoJ0EgZmFpbHVyZSBvY2N1cnJlZCBkdXJpbmcgdGhpcyByZXF1ZXN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlQXJyID0gQXJyYXkuZnJvbShtZXNzYWdlcyk7XG4gICAgICAgIGlmIChtZXNzYWdlQXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VBcnIgPSBtZXNzYWdlQXJyLm1hcCgobWVzc2FnZSwgaSkgPT4gYCAgICAke2kgKyAxfS4gJHttZXNzYWdlfWApO1xuICAgICAgICAgICAgbWVzc2FnZUFyci51bnNoaWZ0KCdNdWx0aXBsZSBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHRoZSByZXF1ZXN0LiBQbGVhc2Ugc2VlIHRoZSBgZXJyb3JzYCBhcnJheSBmb3IgY29tcGxldGUgZGV0YWlscy5cXG4nKTtcbiAgICAgICAgICAgIG1lc3NhZ2VBcnIucHVzaCgnXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VBcnIuam9pbignXFxuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5BcGlFcnJvciA9IEFwaUVycm9yO1xuLyoqXG4gKiBDdXN0b20gZXJyb3IgdHlwZSBmb3IgcGFydGlhbCBlcnJvcnMgcmV0dXJuZWQgZnJvbSB0aGUgQVBJLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBiIC0gRXJyb3Igb2JqZWN0LlxuICovXG5jbGFzcyBQYXJ0aWFsRmFpbHVyZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgZXJyb3JPYmplY3QgPSBiO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9yT2JqZWN0LmVycm9ycztcbiAgICAgICAgdGhpcy5uYW1lID0gJ1BhcnRpYWxGYWlsdXJlRXJyb3InO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gZXJyb3JPYmplY3QucmVzcG9uc2U7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IEFwaUVycm9yLmNyZWF0ZU11bHRpRXJyb3JNZXNzYWdlKGVycm9yT2JqZWN0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJ0aWFsRmFpbHVyZUVycm9yID0gUGFydGlhbEZhaWx1cmVFcnJvcjtcbmNsYXNzIFV0aWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLkFwaUVycm9yID0gQXBpRXJyb3I7XG4gICAgICAgIHRoaXMuUGFydGlhbEZhaWx1cmVFcnJvciA9IFBhcnRpYWxGYWlsdXJlRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vIG9wLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBmdW5jdGlvbiBkb1NvbWV0aGluZyhjYWxsYmFjaykge1xuICAgICAqICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBub29wKCkgeyB9XG4gICAgLyoqXG4gICAgICogVW5pZm9ybWx5IHByb2Nlc3MgYW4gQVBJIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBlcnIgLSBFcnJvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHJlc3AgLSBSZXNwb25zZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IGJvZHkgLSBCb2R5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGhhbmRsZVJlc3AoZXJyLCByZXNwLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHV0aWwubm9vcDtcbiAgICAgICAgY29uc3QgcGFyc2VkUmVzcCA9IGV4dGVuZCh0cnVlLCB7IGVycjogZXJyIHx8IG51bGwgfSwgcmVzcCAmJiB1dGlsLnBhcnNlSHR0cFJlc3BNZXNzYWdlKHJlc3ApLCBib2R5ICYmIHV0aWwucGFyc2VIdHRwUmVzcEJvZHkoYm9keSkpO1xuICAgICAgICAvLyBBc3NpZ24gdGhlIHBhcnNlZCBib2R5IHRvIHJlc3AuYm9keSwgZXZlbiBpZiB7IGpzb246IGZhbHNlIH0gd2FzIHBhc3NlZFxuICAgICAgICAvLyBhcyBhIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBub2JvZHkgdXNlcyB0aGUgcHJldmlvdXNseSB1bnBhcnNlZCB2YWx1ZSBvZiByZXNwLmJvZHkuXG4gICAgICAgIGlmICghcGFyc2VkUmVzcC5lcnIgJiYgcmVzcCAmJiB0eXBlb2YgcGFyc2VkUmVzcC5ib2R5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcGFyc2VkUmVzcC5yZXNwLmJvZHkgPSBwYXJzZWRSZXNwLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZFJlc3AuZXJyICYmIHJlc3ApIHtcbiAgICAgICAgICAgIHBhcnNlZFJlc3AuZXJyLnJlc3BvbnNlID0gcmVzcDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhwYXJzZWRSZXNwLmVyciwgcGFyc2VkUmVzcC5ib2R5LCBwYXJzZWRSZXNwLnJlc3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTbmlmZiBhbiBpbmNvbWluZyBIVFRQIHJlc3BvbnNlIG1lc3NhZ2UgZm9yIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBodHRwUmVzcE1lc3NhZ2UgLSBBbiBpbmNvbWluZyBIVFRQIHJlc3BvbnNlIG1lc3NhZ2UgZnJvbSBgcmVxdWVzdGAuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBwYXJzZWRIdHRwUmVzcE1lc3NhZ2UgLSBUaGUgcGFyc2VkIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSB7P2Vycm9yfSBwYXJzZWRIdHRwUmVzcE1lc3NhZ2UuZXJyIC0gQW4gZXJyb3IgZGV0ZWN0ZWQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZEh0dHBSZXNwTWVzc2FnZS5yZXNwIC0gVGhlIG9yaWdpbmFsIHJlc3BvbnNlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwYXJzZUh0dHBSZXNwTWVzc2FnZShodHRwUmVzcE1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkSHR0cFJlc3BNZXNzYWdlID0ge1xuICAgICAgICAgICAgcmVzcDogaHR0cFJlc3BNZXNzYWdlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaHR0cFJlc3BNZXNzYWdlLnN0YXR1c0NvZGUgPCAyMDAgfHwgaHR0cFJlc3BNZXNzYWdlLnN0YXR1c0NvZGUgPiAyOTkpIHtcbiAgICAgICAgICAgIC8vIFVua25vd24gZXJyb3IuIEZvcm1hdCBhY2NvcmRpbmcgdG8gQXBpRXJyb3Igc3RhbmRhcmQuXG4gICAgICAgICAgICBwYXJzZWRIdHRwUmVzcE1lc3NhZ2UuZXJyID0gbmV3IEFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICBlcnJvcnM6IG5ldyBBcnJheSgpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGh0dHBSZXNwTWVzc2FnZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGh0dHBSZXNwTWVzc2FnZS5zdGF0dXNNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBodHRwUmVzcE1lc3NhZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkSHR0cFJlc3BNZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgcmVzcG9uc2UgYm9keSBmcm9tIGFuIEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5IC0gVGhlIHJlc3BvbnNlIGJvZHkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBwYXJzZWRIdHRwUmVzcE1lc3NhZ2UgLSBUaGUgcGFyc2VkIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSB7P2Vycm9yfSBwYXJzZWRIdHRwUmVzcE1lc3NhZ2UuZXJyIC0gQW4gZXJyb3IgZGV0ZWN0ZWQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZEh0dHBSZXNwTWVzc2FnZS5ib2R5IC0gVGhlIG9yaWdpbmFsIGJvZHkgdmFsdWUgcHJvdmlkZWRcbiAgICAgKiAgICAgd2lsbCB0cnkgdG8gYmUgSlNPTi5wYXJzZSdkLiBJZiBpdCdzIHN1Y2Nlc3NmdWwsIHRoZSBwYXJzZWQgdmFsdWUgd2lsbFxuICAgICAqIGJlIHJldHVybmVkIGhlcmUsIG90aGVyd2lzZSB0aGUgb3JpZ2luYWwgdmFsdWUgYW5kIGFuIGVycm9yIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgcGFyc2VIdHRwUmVzcEJvZHkoYm9keSkge1xuICAgICAgICBjb25zdCBwYXJzZWRIdHRwUmVzcEJvZHkgPSB7XG4gICAgICAgICAgICBib2R5LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZEh0dHBSZXNwQm9keS5ib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRIdHRwUmVzcEJvZHkuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZEh0dHBSZXNwQm9keS5ib2R5ICYmIHBhcnNlZEh0dHBSZXNwQm9keS5ib2R5LmVycm9yKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBmcm9tIEpTT04gQVBJLlxuICAgICAgICAgICAgcGFyc2VkSHR0cFJlc3BCb2R5LmVyciA9IG5ldyBBcGlFcnJvcihwYXJzZWRIdHRwUmVzcEJvZHkuYm9keS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZEh0dHBSZXNwQm9keTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZSBhIER1cGxleGlmeSBzdHJlYW0sIGZldGNoIGFuIGF1dGhlbnRpY2F0ZWQgY29ubmVjdGlvbiBoZWFkZXIsIGFuZFxuICAgICAqIGNyZWF0ZSBhbiBvdXRnb2luZyB3cml0YWJsZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0R1cGxleGlmeX0gZHVwIC0gRHVwbGV4aWZ5IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNvbW1vbi9jb25uZWN0aW9ufSBvcHRpb25zLmNvbm5lY3Rpb24gLSBBIGNvbm5lY3Rpb24gaW5zdGFuY2UgdXNlZCB0byBnZXQgYSB0b2tlbiB3aXRoIGFuZCBzZW5kIHRoZSByZXF1ZXN0IHRocm91Z2guXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubWV0YWRhdGEgLSBNZXRhZGF0YSB0byBzZW5kIGF0IHRoZSBoZWFkIG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnJlcXVlc3QgLSBSZXF1ZXN0IG9iamVjdCwgaW4gdGhlIGZvcm1hdCBvZiBhIHN0YW5kYXJkIE5vZGUuanMgaHR0cC5yZXF1ZXN0KCkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5yZXF1ZXN0Lm1ldGhvZCAtIERlZmF1bHQ6IFwiUE9TVFwiLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5yZXF1ZXN0LnFzLnVwbG9hZFR5cGUgLSBEZWZhdWx0OiBcIm11bHRpcGFydFwiLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5zdHJlYW1Db250ZW50VHlwZSAtIERlZmF1bHQ6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25Db21wbGV0ZSAtIENhbGxiYWNrLCBleGVjdXRlZCBhZnRlciB0aGUgd3JpdGFibGUgUmVxdWVzdCBzdHJlYW0gaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBtYWtlV3JpdGFibGVTdHJlYW0oZHVwLCBvcHRpb25zLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIG9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IHV0aWwubm9vcDtcbiAgICAgICAgY29uc3Qgd3JpdGVTdHJlYW0gPSBuZXcgUHJvZ3Jlc3NTdHJlYW0oKTtcbiAgICAgICAgd3JpdGVTdHJlYW0ub24oJ3Byb2dyZXNzJywgZXZ0ID0+IGR1cC5lbWl0KCdwcm9ncmVzcycsIGV2dCkpO1xuICAgICAgICBkdXAuc2V0V3JpdGFibGUod3JpdGVTdHJlYW0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0UmVxT3B0cyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1cGxvYWRUeXBlOiAnbXVsdGlwYXJ0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhIHx8IHt9O1xuICAgICAgICBjb25zdCByZXFPcHRzID0gZXh0ZW5kKHRydWUsIGRlZmF1bHRSZXFPcHRzLCBvcHRpb25zLnJlcXVlc3QsIHtcbiAgICAgICAgICAgIG11bHRpcGFydDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogbWV0YWRhdGEuY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHdyaXRlU3RyZWFtLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucy5tYWtlQXV0aGVudGljYXRlZFJlcXVlc3QocmVxT3B0cywge1xuICAgICAgICAgICAgb25BdXRoZW50aWNhdGVkKGVyciwgYXV0aGVudGljYXRlZFJlcU9wdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cC5kZXN0cm95KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRlZW55X3JlcXVlc3RfMS50ZWVueVJlcXVlc3QuZGVmYXVsdHMocmVxdWVzdERlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0KGF1dGhlbnRpY2F0ZWRSZXFPcHRzLCAoZXJyLCByZXNwLCBib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuaGFuZGxlUmVzcChlcnIsIHJlc3AsIGJvZHksIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXAuZGVzdHJveShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cC5lbWl0KCdyZXNwb25zZScsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBBUEkgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZCwgZ2l2ZW4gdGhlIGVycm9yIHRoYXQgd2FzXG4gICAgICogZ2l2ZW4gdGhlIGZpcnN0IHRpbWUgdGhlIHJlcXVlc3Qgd2FzIGF0dGVtcHRlZC4gVGhpcyBpcyB1c2VkIGZvciByYXRlIGxpbWl0XG4gICAgICogcmVsYXRlZCBlcnJvcnMgYXMgd2VsbCBhcyBpbnRlcm1pdHRlbnQgc2VydmVyIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXJyb3J9IGVyciAtIFRoZSBBUEkgZXJyb3IgdG8gY2hlY2sgaWYgaXQgaXMgYXBwcm9wcmlhdGUgdG8gcmV0cnkuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgQVBJIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzaG91bGRSZXRyeVJlcXVlc3QoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChbNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF0uaW5kZXhPZihlcnIuY29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlcnIuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGUucmVhc29uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhc29uID09PSAncmF0ZUxpbWl0RXhjZWVkZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhc29uID09PSAndXNlclJhdGVMaW1pdEV4Y2VlZGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24uaW5jbHVkZXMoJ0VBSV9BR0FJTicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGZ1bmN0aW9uIGZvciBtYWtpbmcgYXV0aGVudGljYXRlZCByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb25maWcuYXV0b1JldHJ5IC0gQXV0b21hdGljYWxseSByZXRyeSByZXF1ZXN0cyBpZiB0aGVcbiAgICAgKiAgICAgcmVzcG9uc2UgaXMgcmVsYXRlZCB0byByYXRlIGxpbWl0cyBvciBjZXJ0YWluIGludGVybWl0dGVudCBzZXJ2ZXJcbiAgICAgKiBlcnJvcnMuIFdlIHdpbGwgZXhwb25lbnRpYWxseSBiYWNrb2ZmIHN1YnNlcXVlbnQgcmVxdWVzdHMgYnkgZGVmYXVsdC5cbiAgICAgKiAoZGVmYXVsdDogdHJ1ZSlcbiAgICAgKiBAcGFyYW0ge29iamVjdD19IGNvbmZpZy5jcmVkZW50aWFscyAtIENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb25maWcuY3VzdG9tRW5kcG9pbnQgLSBJZiB0cnVlLCBqdXN0IHJldHVybiB0aGUgcHJvdmlkZWQgcmVxdWVzdCBvcHRpb25zLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb25maWcudXNlQXV0aFdpdGhDdXN0b21FbmRwb2ludCAtIElmIHRydWUsIHdpbGwgYXV0aGVudGljYXRlIHdoZW4gdXNpbmcgYSBjdXN0b20gZW5kcG9pbnQuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gY29uZmlnLmVtYWlsIC0gQWNjb3VudCBlbWFpbCBhZGRyZXNzLCByZXF1aXJlZCBmb3IgUEVNL1AxMiB1c2FnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGNvbmZpZy5tYXhSZXRyaWVzIC0gTWF4aW11bSBudW1iZXIgb2YgYXV0b21hdGljIHJldHJpZXMgYXR0ZW1wdGVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIGVycm9yLiAoZGVmYXVsdDogMylcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGNvbmZpZy5rZXlGaWxlIC0gUGF0aCB0byBhIC5qc29uLCAucGVtLCBvciAucDEyIGtleWZpbGUuXG4gICAgICogQHBhcmFtIHthcnJheX0gY29uZmlnLnNjb3BlcyAtIEFycmF5IG9mIHNjb3BlcyByZXF1aXJlZCBmb3IgdGhlIEFQSS5cbiAgICAgKi9cbiAgICBtYWtlQXV0aGVudGljYXRlZFJlcXVlc3RGYWN0b3J5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBnb29nbGVBdXRvQXV0aENvbmZpZyA9IGV4dGVuZCh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGdvb2dsZUF1dG9BdXRoQ29uZmlnLnByb2plY3RJZCA9PT0gc2VydmljZV8xLkRFRkFVTFRfUFJPSkVDVF9JRF9UT0tFTikge1xuICAgICAgICAgICAgZGVsZXRlIGdvb2dsZUF1dG9BdXRoQ29uZmlnLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXV0aENsaWVudDtcbiAgICAgICAgaWYgKGdvb2dsZUF1dG9BdXRoQ29uZmlnLmF1dGhDbGllbnQgaW5zdGFuY2VvZiBnb29nbGVfYXV0aF9saWJyYXJ5XzEuR29vZ2xlQXV0aCkge1xuICAgICAgICAgICAgLy8gVXNlIGFuIGV4aXN0aW5nIGBHb29nbGVBdXRoYFxuICAgICAgICAgICAgYXV0aENsaWVudCA9IGdvb2dsZUF1dG9BdXRoQ29uZmlnLmF1dGhDbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXNzIGFuIGBBdXRoQ2xpZW50YCB0byBgR29vZ2xlQXV0aGAsIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIC4uLmdvb2dsZUF1dG9BdXRoQ29uZmlnLFxuICAgICAgICAgICAgICAgIGF1dGhDbGllbnQ6IGdvb2dsZUF1dG9BdXRoQ29uZmlnLmF1dGhDbGllbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXV0aENsaWVudCA9IG5ldyBnb29nbGVfYXV0aF9saWJyYXJ5XzEuR29vZ2xlQXV0aChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBdXRoZW50aWNhdGVkUmVxdWVzdChyZXFPcHRzLCBvcHRpb25zT3JDYWxsYmFjaykge1xuICAgICAgICAgICAgbGV0IHN0cmVhbTtcbiAgICAgICAgICAgIGxldCBwcm9qZWN0SWQ7XG4gICAgICAgICAgICBjb25zdCByZXFDb25maWcgPSBleHRlbmQoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBsZXQgYWN0aXZlUmVxdWVzdF87XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNPckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtID0gZHVwbGV4aWZ5KCk7XG4gICAgICAgICAgICAgICAgcmVxQ29uZmlnLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdvYmplY3QnID8gb3B0aW9uc09yQ2FsbGJhY2sgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNPckNhbGxiYWNrIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gc2V0UHJvamVjdElkKCkge1xuICAgICAgICAgICAgICAgIHByb2plY3RJZCA9IGF3YWl0IGF1dGhDbGllbnQuZ2V0UHJvamVjdElkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbkF1dGhlbnRpY2F0ZWQgPSBhc3luYyAoZXJyLCBhdXRoZW50aWNhdGVkUmVxT3B0cykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhMaWJyYXJ5RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgY29uc3QgYXV0b0F1dGhGYWlsZWQgPSBlcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UuaW5kZXhPZignQ291bGQgbm90IGxvYWQgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMnKSA+IC0xO1xuICAgICAgICAgICAgICAgIGlmIChhdXRvQXV0aEZhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCBhdXRoZW50aWNhdGlvbiBmYWlsZWQsIHRoZSBBUEkgbWlnaHQgbm90IGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhcmUuXG4gICAgICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWRSZXFPcHRzID0gcmVxT3B0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIgfHwgYXV0b0F1dGhGYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB3aXRoIGV4aXN0aW5nIGBwcm9qZWN0SWRgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGVkUmVxT3B0cyA9IHV0aWwuZGVjb3JhdGVSZXF1ZXN0KGF1dGhlbnRpY2F0ZWRSZXFPcHRzLCBwcm9qZWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBwcm9qZWN0aWZ5XzEuTWlzc2luZ1Byb2plY3RJZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBgcHJvamVjdElkYCB3YXMgcmVxdWlyZWQsIGJ1dCB3ZSBkb24ndCBoYXZlIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCB0aGUgYHByb2plY3RJZGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0UHJvamVjdElkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWRSZXFPcHRzID0gdXRpbC5kZWNvcmF0ZVJlcXVlc3QoYXV0aGVudGljYXRlZFJlcU9wdHMsIHByb2plY3RJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXVzZSB0aGUgXCJDb3VsZCBub3QgbG9hZCB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyBlcnJvclwiIGlmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG8gYXV0aCBmYWlsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciB8fCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgdW5yZWxhdGVkIHRvIG1pc3NpbmcgYHByb2plY3RJZGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgfHwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkF1dGhlbnRpY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMub25BdXRoZW50aWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9uQXV0aGVudGljYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uQXV0aGVudGljYXRlZChudWxsLCBhdXRoZW50aWNhdGVkUmVxT3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZXF1ZXN0XyA9IHV0aWwubWFrZVJlcXVlc3QoYXV0aGVudGljYXRlZFJlcU9wdHMsIHJlcUNvbmZpZywgKGFwaVJlc3BvbnNlRXJyb3IsIC4uLnBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZXNwb25zZUVycm9yLmNvZGUgPT09IDQwMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhMaWJyYXJ5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS11c2UgdGhlIFwiQ291bGQgbm90IGxvYWQgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgZXJyb3JcIiBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBBUEkgcmVxdWVzdCBmYWlsZWQgZHVlIHRvIG1pc3NpbmcgY3JlZGVudGlhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVzcG9uc2VFcnJvciA9IGF1dGhMaWJyYXJ5RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhcGlSZXNwb25zZUVycm9yLCAuLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZVJlcXVlc3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0UHJvamVjdElkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5wcm9qZWN0SWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucHJvamVjdElkICE9PSBzZXJ2aWNlXzEuREVGQVVMVF9QUk9KRUNUX0lEX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgcHJvdmlkZWQgYSBwcm9qZWN0IElELiBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0aCBjbGllbnQsIGl0IGNvdWxkIGJlIGluY29ycmVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLnByb2plY3RJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcucHJvamVjdElkUmVxdWlyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBwcm9qZWN0SWQgaXMgbm90IHJlcXVpcmVkLiBSZXR1cm4gdGhlIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VfMS5ERUZBVUxUX1BST0pFQ1RfSURfVE9LRU47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJvamVjdElkKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6ZVJlcXVlc3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxQ29uZmlnLmN1c3RvbUVuZHBvaW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXJlcUNvbmZpZy51c2VBdXRoV2l0aEN1c3RvbUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgYSBjdXN0b20gQVBJIG92ZXJyaWRlLiBEbyBub3QgdXNlIGBnb29nbGUtYXV0aC1saWJyYXJ5YCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbi4gKGV4OiBjb25uZWN0aW5nIHRvIGEgbG9jYWwgRGF0YXN0b3JlIHNlcnZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxT3B0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoQ2xpZW50LmF1dGhvcml6ZVJlcXVlc3QocmVxT3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtfcHJvamVjdElkLCBhdXRob3JpemVkUmVxT3B0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRQcm9qZWN0SWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcml6ZVJlcXVlc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfcHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0SWQgPSBfcHJvamVjdElkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbkF1dGhlbnRpY2F0ZWQobnVsbCwgYXV0aG9yaXplZFJlcU9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25BdXRoZW50aWNhdGVkKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVwYXJlUmVxdWVzdCgpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVJlcXVlc3RfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUmVxdWVzdF8uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZXF1ZXN0XyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hciA9IG1ha2VBdXRoZW50aWNhdGVkUmVxdWVzdDtcbiAgICAgICAgbWFyLmdldENyZWRlbnRpYWxzID0gYXV0aENsaWVudC5nZXRDcmVkZW50aWFscy5iaW5kKGF1dGhDbGllbnQpO1xuICAgICAgICBtYXIuYXV0aENsaWVudCA9IGF1dGhDbGllbnQ7XG4gICAgICAgIHJldHVybiBtYXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgYSByZXF1ZXN0IHRocm91Z2ggdGhlIGByZXRyeVJlcXVlc3RgIG1vZHVsZSB3aXRoIGJ1aWx0LWluIGVycm9yXG4gICAgICogaGFuZGxpbmcgYW5kIGV4cG9uZW50aWFsIGJhY2sgb2ZmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlcU9wdHMgLSBSZXF1ZXN0IG9wdGlvbnMgaW4gdGhlIGZvcm1hdCBgcmVxdWVzdGAgZXhwZWN0cy5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbmZpZy5hdXRvUmV0cnkgLSBBdXRvbWF0aWNhbGx5IHJldHJ5IHJlcXVlc3RzIGlmIHRoZVxuICAgICAqICAgICByZXNwb25zZSBpcyByZWxhdGVkIHRvIHJhdGUgbGltaXRzIG9yIGNlcnRhaW4gaW50ZXJtaXR0ZW50IHNlcnZlclxuICAgICAqIGVycm9ycy4gV2Ugd2lsbCBleHBvbmVudGlhbGx5IGJhY2tvZmYgc3Vic2VxdWVudCByZXF1ZXN0cyBieSBkZWZhdWx0LlxuICAgICAqIChkZWZhdWx0OiB0cnVlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gY29uZmlnLm1heFJldHJpZXMgLSBNYXhpbXVtIG51bWJlciBvZiBhdXRvbWF0aWMgcmV0cmllc1xuICAgICAqICAgICBhdHRlbXB0ZWQgYmVmb3JlIHJldHVybmluZyB0aGUgZXJyb3IuIChkZWZhdWx0OiAzKVxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gY29uZmlnLnJlcXVlc3QgLSBIVFRQIG1vZHVsZSBmb3IgcmVxdWVzdCBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBtYWtlUmVxdWVzdChyZXFPcHRzLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgbGV0IGF1dG9SZXRyeVZhbHVlID0gQVVUT19SRVRSWV9ERUZBVUxUO1xuICAgICAgICBpZiAoY29uZmlnLmF1dG9SZXRyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKF9hID0gY29uZmlnLnJldHJ5T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9SZXRyeSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKCdhdXRvUmV0cnkgaXMgZGVwcmVjYXRlZC4gVXNlIHJldHJ5T3B0aW9ucy5hdXRvUmV0cnkgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuYXV0b1JldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF1dG9SZXRyeVZhbHVlID0gY29uZmlnLmF1dG9SZXRyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9iID0gY29uZmlnLnJldHJ5T3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmF1dG9SZXRyeSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXV0b1JldHJ5VmFsdWUgPSBjb25maWcucmV0cnlPcHRpb25zLmF1dG9SZXRyeTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF4UmV0cnlWYWx1ZSA9IE1BWF9SRVRSWV9ERUZBVUxUO1xuICAgICAgICBpZiAoY29uZmlnLm1heFJldHJpZXMgJiYgKChfYyA9IGNvbmZpZy5yZXRyeU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXhSZXRyaWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKCdtYXhSZXRyaWVzIGlzIGRlcHJlY2F0ZWQuIFVzZSByZXRyeU9wdGlvbnMubWF4UmV0cmllcyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICBtYXhSZXRyeVZhbHVlID0gY29uZmlnLm1heFJldHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKF9kID0gY29uZmlnLnJldHJ5T3B0aW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgIG1heFJldHJ5VmFsdWUgPSBjb25maWcucmV0cnlPcHRpb25zLm1heFJldHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHRlZW55X3JlcXVlc3RfMS50ZWVueVJlcXVlc3QuZGVmYXVsdHMocmVxdWVzdERlZmF1bHRzKSxcbiAgICAgICAgICAgIHJldHJpZXM6IGF1dG9SZXRyeVZhbHVlICE9PSBmYWxzZSA/IG1heFJldHJ5VmFsdWUgOiAwLFxuICAgICAgICAgICAgbm9SZXNwb25zZVJldHJpZXM6IGF1dG9SZXRyeVZhbHVlICE9PSBmYWxzZSA/IG1heFJldHJ5VmFsdWUgOiAwLFxuICAgICAgICAgICAgc2hvdWxkUmV0cnlGbihodHRwUmVzcE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHV0aWwucGFyc2VIdHRwUmVzcE1lc3NhZ2UoaHR0cFJlc3BNZXNzYWdlKS5lcnI7XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGNvbmZpZy5yZXRyeU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXRyeWFibGVFcnJvckZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgKChfYiA9IGNvbmZpZy5yZXRyeU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXRyeWFibGVFcnJvckZuKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIHV0aWwuc2hvdWxkUmV0cnlSZXF1ZXN0KGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4UmV0cnlEZWxheTogKF9lID0gY29uZmlnLnJldHJ5T3B0aW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm1heFJldHJ5RGVsYXksXG4gICAgICAgICAgICByZXRyeURlbGF5TXVsdGlwbGllcjogKF9mID0gY29uZmlnLnJldHJ5T3B0aW9ucykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnJldHJ5RGVsYXlNdWx0aXBsaWVyLFxuICAgICAgICAgICAgdG90YWxUaW1lb3V0OiAoX2cgPSBjb25maWcucmV0cnlPcHRpb25zKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cudG90YWxUaW1lb3V0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHJlcU9wdHMubWF4UmV0cmllcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmV0cmllcyA9IHJlcU9wdHMubWF4UmV0cmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5zdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeVJlcXVlc3QocmVxT3B0cywgb3B0aW9ucywgKGVyciwgcmVzcG9uc2UsIGJvZHkpID0+IHtcbiAgICAgICAgICAgICAgICB1dGlsLmhhbmRsZVJlc3AoZXJyLCByZXNwb25zZSwgYm9keSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHVwID0gY29uZmlnLnN0cmVhbTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IHJlcXVlc3RTdHJlYW07XG4gICAgICAgIGNvbnN0IGlzR2V0UmVxdWVzdCA9IChyZXFPcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSA9PT0gJ0dFVCc7XG4gICAgICAgIGlmIChpc0dldFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW0gPSByZXRyeVJlcXVlc3QocmVxT3B0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICBkdXAuc2V0UmVhZGFibGUocmVxdWVzdFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdHJlYW1pbmcgd3JpdGFibGUgSFRUUCByZXF1ZXN0cyBjYW5ub3QgYmUgcmV0cmllZC5cbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW0gPSBvcHRpb25zLnJlcXVlc3QocmVxT3B0cyk7XG4gICAgICAgICAgICBkdXAuc2V0V3JpdGFibGUocmVxdWVzdFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGF5IHRoZSBSZXF1ZXN0IGV2ZW50cyBiYWNrIHRvIHRoZSBzdHJlYW0uXG4gICAgICAgIHJlcXVlc3RTdHJlYW1cbiAgICAgICAgICAgIC5vbignZXJyb3InLCBkdXAuZGVzdHJveS5iaW5kKGR1cCkpXG4gICAgICAgICAgICAub24oJ3Jlc3BvbnNlJywgZHVwLmVtaXQuYmluZChkdXAsICdyZXNwb25zZScpKVxuICAgICAgICAgICAgLm9uKCdjb21wbGV0ZScsIGR1cC5lbWl0LmJpbmQoZHVwLCAnY29tcGxldGUnKSk7XG4gICAgICAgIGR1cC5hYm9ydCA9IHJlcXVlc3RTdHJlYW0uYWJvcnQ7XG4gICAgICAgIHJldHVybiBkdXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29yYXRlIHRoZSBvcHRpb25zIGFib3V0IHRvIGJlIG1hZGUgaW4gYSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlcU9wdHMgLSBUaGUgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gYHJlcXVlc3RgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0SWQgLSBUaGUgcHJvamVjdCBJRC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IHJlcU9wdHMgLSBUaGUgZGVjb3JhdGVkIHJlcU9wdHMuXG4gICAgICovXG4gICAgZGVjb3JhdGVSZXF1ZXN0KHJlcU9wdHMsIHByb2plY3RJZCkge1xuICAgICAgICBkZWxldGUgcmVxT3B0cy5hdXRvUGFnaW5hdGU7XG4gICAgICAgIGRlbGV0ZSByZXFPcHRzLmF1dG9QYWdpbmF0ZVZhbDtcbiAgICAgICAgZGVsZXRlIHJlcU9wdHMub2JqZWN0TW9kZTtcbiAgICAgICAgaWYgKHJlcU9wdHMucXMgIT09IG51bGwgJiYgdHlwZW9mIHJlcU9wdHMucXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxT3B0cy5xcy5hdXRvUGFnaW5hdGU7XG4gICAgICAgICAgICBkZWxldGUgcmVxT3B0cy5xcy5hdXRvUGFnaW5hdGVWYWw7XG4gICAgICAgICAgICByZXFPcHRzLnFzID0gKDAsIHByb2plY3RpZnlfMS5yZXBsYWNlUHJvamVjdElkVG9rZW4pKHJlcU9wdHMucXMsIHByb2plY3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxT3B0cy5tdWx0aXBhcnQpKSB7XG4gICAgICAgICAgICByZXFPcHRzLm11bHRpcGFydCA9IHJlcU9wdHMubXVsdGlwYXJ0Lm1hcChwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHByb2plY3RpZnlfMS5yZXBsYWNlUHJvamVjdElkVG9rZW4pKHBhcnQsIHByb2plY3RJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxT3B0cy5qc29uICE9PSBudWxsICYmIHR5cGVvZiByZXFPcHRzLmpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxT3B0cy5qc29uLmF1dG9QYWdpbmF0ZTtcbiAgICAgICAgICAgIGRlbGV0ZSByZXFPcHRzLmpzb24uYXV0b1BhZ2luYXRlVmFsO1xuICAgICAgICAgICAgcmVxT3B0cy5qc29uID0gKDAsIHByb2plY3RpZnlfMS5yZXBsYWNlUHJvamVjdElkVG9rZW4pKHJlcU9wdHMuanNvbiwgcHJvamVjdElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXFPcHRzLnVyaSA9ICgwLCBwcm9qZWN0aWZ5XzEucmVwbGFjZVByb2plY3RJZFRva2VuKShyZXFPcHRzLnVyaSwgcHJvamVjdElkKTtcbiAgICAgICAgcmV0dXJuIHJlcU9wdHM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaXNDdXN0b21UeXBlKHVua25vd24sIG1vZHVsZSkge1xuICAgICAgICBmdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZVBhcnRzID0gbW9kdWxlLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IHBhcmVudE1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lUGFydHNbMF0gJiYgbW9kdWxlTmFtZVBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1Yk1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lUGFydHNbMV0gJiYgbW9kdWxlTmFtZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdWJNb2R1bGVOYW1lICYmIGdldENvbnN0cnVjdG9yTmFtZSh1bmtub3duKSAhPT0gc3ViTW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3YWxraW5nTW9kdWxlID0gdW5rbm93bjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh3YWxraW5nTW9kdWxlKSA9PT0gcGFyZW50TW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fsa2luZ01vZHVsZSA9IHdhbGtpbmdNb2R1bGUucGFyZW50O1xuICAgICAgICAgICAgaWYgKCF3YWxraW5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHByb3Blcmx5LWZvcm1hdHRlZCBVc2VyLUFnZW50IHN0cmluZyBmcm9tIGEgcGFja2FnZS5qc29uIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFja2FnZUpzb24gLSBBIG1vZHVsZSdzIHBhY2thZ2UuanNvbiBmaWxlLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdXNlckFnZW50IC0gVGhlIGZvcm1hdHRlZCBVc2VyLUFnZW50IHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRVc2VyQWdlbnRGcm9tUGFja2FnZUpzb24ocGFja2FnZUpzb24pIHtcbiAgICAgICAgY29uc3QgaHlwaGVuYXRlZFBhY2thZ2VOYW1lID0gcGFja2FnZUpzb24ubmFtZVxuICAgICAgICAgICAgLnJlcGxhY2UoJ0Bnb29nbGUtY2xvdWQnLCAnZ2Nsb3VkLW5vZGUnKSAvLyBGb3IgbGVnYWN5IHB1cnBvc2VzLlxuICAgICAgICAgICAgLnJlcGxhY2UoJy8nLCAnLScpOyAvLyBGb3IgVUEgc3BlYy1jb21wbGlhbmNlIHB1cnBvc2VzLlxuICAgICAgICByZXR1cm4gaHlwaGVuYXRlZFBhY2thZ2VOYW1lICsgJy8nICsgcGFja2FnZUpzb24udmVyc2lvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdHdvIHBhcmFtZXRlcnMsIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBlaXRoZXI6XG4gICAgICogIC0gSnVzdCBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogIC0gQW4gb3B0aW9ucyBvYmplY3QsIGFuZCB0aGVuIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9uc09yQ2FsbGJhY2sgQW4gb3B0aW9ucyBvYmplY3Qgb3IgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGNiIEEgcG90ZW50aWFsbHkgdW5kZWZpbmVkIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG1heWJlT3B0aW9uc09yQ2FsbGJhY2sob3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gW3t9LCBvcHRpb25zT3JDYWxsYmFja11cbiAgICAgICAgICAgIDogW29wdGlvbnNPckNhbGxiYWNrLCBjYl07XG4gICAgfVxufVxuZXhwb3J0cy5VdGlsID0gVXRpbDtcbi8qKlxuICogQmFzaWMgUGFzc3Rocm91Z2ggU3RyZWFtIHRoYXQgcmVjb3JkcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAqIGV2ZXJ5IHRpbWUgdGhlIGN1cnNvciBpcyBtb3ZlZC5cbiAqL1xuY2xhc3MgUHJvZ3Jlc3NTdHJlYW0gZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ5dGVzUmVhZCA9IDA7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNSZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHsgYnl0ZXNXcml0dGVuOiB0aGlzLmJ5dGVzUmVhZCwgY29udGVudExlbmd0aDogJyonIH0pO1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IHV0aWwgPSBuZXcgVXRpbCgpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/common/build/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/paginator/build/src/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@google-cloud/paginator/build/src/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceStream = exports.paginator = exports.Paginator = void 0;\n/*!\n * @module common/paginator\n */\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\nconst resource_stream_1 = __webpack_require__(/*! ./resource-stream */ \"(rsc)/./node_modules/@google-cloud/paginator/build/src/resource-stream.js\");\nObject.defineProperty(exports, \"ResourceStream\", ({ enumerable: true, get: function () { return resource_stream_1.ResourceStream; } }));\n/*! Developer Documentation\n *\n * paginator is used to auto-paginate `nextQuery` methods as well as\n * streamifying them.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {\n *     search.query(nextQuery, function(err, results, nextQuery) {});\n *   });\n *\n * After:\n *\n *   search.query('done=true', function(err, results) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`.\n */\nclass Paginator {\n    /**\n     * Cache the original method, then overwrite it on the Class's prototype.\n     *\n     * @param {function} Class - The parent class of the methods to extend.\n     * @param {string|string[]} methodNames - Name(s) of the methods to extend.\n     */\n    // tslint:disable-next-line:variable-name\n    extend(Class, methodNames) {\n        methodNames = arrify(methodNames);\n        methodNames.forEach(methodName => {\n            const originalMethod = Class.prototype[methodName];\n            // map the original method to a private member\n            Class.prototype[methodName + '_'] = originalMethod;\n            // overwrite the original to auto-paginate\n            /* eslint-disable  @typescript-eslint/no-explicit-any */\n            Class.prototype[methodName] = function (...args) {\n                const parsedArguments = paginator.parseArguments_(args);\n                return paginator.run_(parsedArguments, originalMethod.bind(this));\n            };\n        });\n    }\n    /**\n     * Wraps paginated API calls in a readable object stream.\n     *\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {string} methodName - Name of the method to streamify.\n     * @return {function} - Wrapped function.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    streamify(methodName) {\n        return function (\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\n        ...args) {\n            const parsedArguments = paginator.parseArguments_(args);\n            const originalMethod = this[methodName + '_'] || this[methodName];\n            return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n        };\n    }\n    /**\n     * Parse a pseudo-array `arguments` for a query and callback.\n     *\n     * @param {array} args - The original `arguments` pseduo-array that the original\n     *     method received.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    parseArguments_(args) {\n        let query;\n        let autoPaginate = true;\n        let maxApiCalls = -1;\n        let maxResults = -1;\n        let callback;\n        const firstArgument = args[0];\n        const lastArgument = args[args.length - 1];\n        if (typeof firstArgument === 'function') {\n            callback = firstArgument;\n        }\n        else {\n            query = firstArgument;\n        }\n        if (typeof lastArgument === 'function') {\n            callback = lastArgument;\n        }\n        if (typeof query === 'object') {\n            query = extend(true, {}, query);\n            // Check if the user only asked for a certain amount of results.\n            if (query.maxResults && typeof query.maxResults === 'number') {\n                // `maxResults` is used API-wide.\n                maxResults = query.maxResults;\n            }\n            else if (typeof query.pageSize === 'number') {\n                // `pageSize` is Pub/Sub's `maxResults`.\n                maxResults = query.pageSize;\n            }\n            if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\n                maxApiCalls = query.maxApiCalls;\n                delete query.maxApiCalls;\n            }\n            // maxResults is the user specified limit.\n            if (maxResults !== -1 || query.autoPaginate === false) {\n                autoPaginate = false;\n            }\n        }\n        const parsedArguments = {\n            query: query || {},\n            autoPaginate,\n            maxApiCalls,\n            maxResults,\n            callback,\n        };\n        parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n        delete parsedArguments.streamOptions.autoPaginate;\n        delete parsedArguments.streamOptions.maxResults;\n        delete parsedArguments.streamOptions.pageSize;\n        return parsedArguments;\n    }\n    /**\n     * This simply checks to see if `autoPaginate` is set or not, if it's true\n     * then we buffer all results, otherwise simply call the original method.\n     *\n     * @param {array} parsedArguments - Parsed arguments from the original method\n     *     call.\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     */\n    run_(parsedArguments, originalMethod) {\n        const query = parsedArguments.query;\n        const callback = parsedArguments.callback;\n        if (!parsedArguments.autoPaginate) {\n            return originalMethod(query, callback);\n        }\n        const results = new Array();\n        let otherArgs = [];\n        const promise = new Promise((resolve, reject) => {\n            const stream = paginator.runAsStream_(parsedArguments, originalMethod);\n            stream\n                .on('error', reject)\n                .on('data', (data) => results.push(data))\n                .on('end', () => {\n                otherArgs = stream._otherArgs || [];\n                resolve(results);\n            });\n        });\n        if (!callback) {\n            return promise.then(results => [results, query, ...otherArgs]);\n        }\n        promise.then(results => callback(null, results, query, ...otherArgs), (err) => callback(err));\n    }\n    /**\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     * @return {stream} - Readable object stream.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    runAsStream_(parsedArguments, originalMethod) {\n        return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);\n    }\n}\nexports.Paginator = Paginator;\nconst paginator = new Paginator();\nexports.paginator = paginator;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wYWdpbmF0b3IvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLDBCQUEwQixtQkFBTyxDQUFDLG9HQUFtQjtBQUNyRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wYWdpbmF0b3IvYnVpbGQvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb3VyY2VTdHJlYW0gPSBleHBvcnRzLnBhZ2luYXRvciA9IGV4cG9ydHMuUGFnaW5hdG9yID0gdm9pZCAwO1xuLyohXG4gKiBAbW9kdWxlIGNvbW1vbi9wYWdpbmF0b3JcbiAqL1xuY29uc3QgYXJyaWZ5ID0gcmVxdWlyZShcImFycmlmeVwiKTtcbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoXCJleHRlbmRcIik7XG5jb25zdCByZXNvdXJjZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3Jlc291cmNlLXN0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc291cmNlU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvdXJjZV9zdHJlYW1fMS5SZXNvdXJjZVN0cmVhbTsgfSB9KTtcbi8qISBEZXZlbG9wZXIgRG9jdW1lbnRhdGlvblxuICpcbiAqIHBhZ2luYXRvciBpcyB1c2VkIHRvIGF1dG8tcGFnaW5hdGUgYG5leHRRdWVyeWAgbWV0aG9kcyBhcyB3ZWxsIGFzXG4gKiBzdHJlYW1pZnlpbmcgdGhlbS5cbiAqXG4gKiBCZWZvcmU6XG4gKlxuICogICBzZWFyY2gucXVlcnkoJ2RvbmU9dHJ1ZScsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cywgbmV4dFF1ZXJ5KSB7XG4gKiAgICAgc2VhcmNoLnF1ZXJ5KG5leHRRdWVyeSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzLCBuZXh0UXVlcnkpIHt9KTtcbiAqICAgfSk7XG4gKlxuICogQWZ0ZXI6XG4gKlxuICogICBzZWFyY2gucXVlcnkoJ2RvbmU9dHJ1ZScsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge30pO1xuICpcbiAqIE1ldGhvZHMgdG8gZXh0ZW5kIHNob3VsZCBiZSB3cml0dGVuIHRvIGFjY2VwdCBjYWxsYmFja3MgYW5kIHJldHVybiBhXG4gKiBgbmV4dFF1ZXJ5YC5cbiAqL1xuY2xhc3MgUGFnaW5hdG9yIHtcbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGUgb3JpZ2luYWwgbWV0aG9kLCB0aGVuIG92ZXJ3cml0ZSBpdCBvbiB0aGUgQ2xhc3MncyBwcm90b3R5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAtIFRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhlIG1ldGhvZHMgdG8gZXh0ZW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBtZXRob2ROYW1lcyAtIE5hbWUocykgb2YgdGhlIG1ldGhvZHMgdG8gZXh0ZW5kLlxuICAgICAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG4gICAgZXh0ZW5kKENsYXNzLCBtZXRob2ROYW1lcykge1xuICAgICAgICBtZXRob2ROYW1lcyA9IGFycmlmeShtZXRob2ROYW1lcyk7XG4gICAgICAgIG1ldGhvZE5hbWVzLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IENsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIC8vIG1hcCB0aGUgb3JpZ2luYWwgbWV0aG9kIHRvIGEgcHJpdmF0ZSBtZW1iZXJcbiAgICAgICAgICAgIENsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ18nXSA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICAgICAgLy8gb3ZlcndyaXRlIHRoZSBvcmlnaW5hbCB0byBhdXRvLXBhZ2luYXRlXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmd1bWVudHMgPSBwYWdpbmF0b3IucGFyc2VBcmd1bWVudHNfKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWdpbmF0b3IucnVuXyhwYXJzZWRBcmd1bWVudHMsIG9yaWdpbmFsTWV0aG9kLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBzIHBhZ2luYXRlZCBBUEkgY2FsbHMgaW4gYSByZWFkYWJsZSBvYmplY3Qgc3RyZWFtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgc2ltcGx5IGNhbGxzIHRoZSBuZXh0UXVlcnkgcmVjdXJzaXZlbHksIGVtaXR0aW5nIHJlc3VsdHMgdG8gYVxuICAgICAqIHN0cmVhbS4gVGhlIHN0cmVhbSBlbmRzIHdoZW4gYG5leHRRdWVyeWAgaXMgbnVsbC5cbiAgICAgKlxuICAgICAqIGBtYXhSZXN1bHRzYCB3aWxsIGFjdCBhcyBhIGNhcCBmb3IgaG93IG1hbnkgcmVzdWx0cyBhcmUgZmV0Y2hlZCBhbmQgZW1pdHRlZFxuICAgICAqIHRvIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIE5hbWUgb2YgdGhlIG1ldGhvZCB0byBzdHJlYW1pZnkuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IC0gV3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgIHN0cmVhbWlmeShtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlICBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgICAgIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3VtZW50cyA9IHBhZ2luYXRvci5wYXJzZUFyZ3VtZW50c18oYXJncyk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IHRoaXNbbWV0aG9kTmFtZSArICdfJ10gfHwgdGhpc1ttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBwYWdpbmF0b3IucnVuQXNTdHJlYW1fKHBhcnNlZEFyZ3VtZW50cywgb3JpZ2luYWxNZXRob2QuYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgcHNldWRvLWFycmF5IGBhcmd1bWVudHNgIGZvciBhIHF1ZXJ5IGFuZCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyZ3MgLSBUaGUgb3JpZ2luYWwgYGFyZ3VtZW50c2AgcHNlZHVvLWFycmF5IHRoYXQgdGhlIG9yaWdpbmFsXG4gICAgICogICAgIG1ldGhvZCByZWNlaXZlZC5cbiAgICAgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgIHBhcnNlQXJndW1lbnRzXyhhcmdzKSB7XG4gICAgICAgIGxldCBxdWVyeTtcbiAgICAgICAgbGV0IGF1dG9QYWdpbmF0ZSA9IHRydWU7XG4gICAgICAgIGxldCBtYXhBcGlDYWxscyA9IC0xO1xuICAgICAgICBsZXQgbWF4UmVzdWx0cyA9IC0xO1xuICAgICAgICBsZXQgY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IGZpcnN0QXJndW1lbnQgPSBhcmdzWzBdO1xuICAgICAgICBjb25zdCBsYXN0QXJndW1lbnQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmd1bWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmaXJzdEFyZ3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVlcnkgPSBmaXJzdEFyZ3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGFzdEFyZ3VtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGxhc3RBcmd1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcXVlcnkgPSBleHRlbmQodHJ1ZSwge30sIHF1ZXJ5KTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB1c2VyIG9ubHkgYXNrZWQgZm9yIGEgY2VydGFpbiBhbW91bnQgb2YgcmVzdWx0cy5cbiAgICAgICAgICAgIGlmIChxdWVyeS5tYXhSZXN1bHRzICYmIHR5cGVvZiBxdWVyeS5tYXhSZXN1bHRzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGBtYXhSZXN1bHRzYCBpcyB1c2VkIEFQSS13aWRlLlxuICAgICAgICAgICAgICAgIG1heFJlc3VsdHMgPSBxdWVyeS5tYXhSZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHF1ZXJ5LnBhZ2VTaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGBwYWdlU2l6ZWAgaXMgUHViL1N1YidzIGBtYXhSZXN1bHRzYC5cbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzID0gcXVlcnkucGFnZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVlcnkubWF4QXBpQ2FsbHMgJiYgdHlwZW9mIHF1ZXJ5Lm1heEFwaUNhbGxzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG1heEFwaUNhbGxzID0gcXVlcnkubWF4QXBpQ2FsbHM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5Lm1heEFwaUNhbGxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWF4UmVzdWx0cyBpcyB0aGUgdXNlciBzcGVjaWZpZWQgbGltaXQuXG4gICAgICAgICAgICBpZiAobWF4UmVzdWx0cyAhPT0gLTEgfHwgcXVlcnkuYXV0b1BhZ2luYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGF1dG9QYWdpbmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZEFyZ3VtZW50cyA9IHtcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSB8fCB7fSxcbiAgICAgICAgICAgIGF1dG9QYWdpbmF0ZSxcbiAgICAgICAgICAgIG1heEFwaUNhbGxzLFxuICAgICAgICAgICAgbWF4UmVzdWx0cyxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBwYXJzZWRBcmd1bWVudHMuc3RyZWFtT3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgcGFyc2VkQXJndW1lbnRzLnF1ZXJ5KTtcbiAgICAgICAgZGVsZXRlIHBhcnNlZEFyZ3VtZW50cy5zdHJlYW1PcHRpb25zLmF1dG9QYWdpbmF0ZTtcbiAgICAgICAgZGVsZXRlIHBhcnNlZEFyZ3VtZW50cy5zdHJlYW1PcHRpb25zLm1heFJlc3VsdHM7XG4gICAgICAgIGRlbGV0ZSBwYXJzZWRBcmd1bWVudHMuc3RyZWFtT3B0aW9ucy5wYWdlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZEFyZ3VtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzaW1wbHkgY2hlY2tzIHRvIHNlZSBpZiBgYXV0b1BhZ2luYXRlYCBpcyBzZXQgb3Igbm90LCBpZiBpdCdzIHRydWVcbiAgICAgKiB0aGVuIHdlIGJ1ZmZlciBhbGwgcmVzdWx0cywgb3RoZXJ3aXNlIHNpbXBseSBjYWxsIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXJzZWRBcmd1bWVudHMgLSBQYXJzZWQgYXJndW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAqICAgICBjYWxsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PXxzdHJpbmc9fSBwYXJzZWRBcmd1bWVudHMucXVlcnkgLSBRdWVyeSBvYmplY3QuIFRoaXMgaXMgbW9zdFxuICAgICAqICAgICBjb21tb25seSBhbiBvYmplY3QsIGJ1dCB0byBtYWtlIHRoZSBBUEkgbW9yZSBzaW1wbGUsIGl0IGNhbiBhbHNvIGJlIGFcbiAgICAgKiAgICAgc3RyaW5nIGluIHNvbWUgcGxhY2VzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBwYXJzZWRBcmd1bWVudHMuY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcnNlZEFyZ3VtZW50cy5hdXRvUGFnaW5hdGUgLSBBdXRvLXBhZ2luYXRpb24gZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcnNlZEFyZ3VtZW50cy5tYXhBcGlDYWxscyAtIE1heGltdW0gQVBJIGNhbGxzIHRvIG1ha2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnNlZEFyZ3VtZW50cy5tYXhSZXN1bHRzIC0gTWF4aW11bSByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcmlnaW5hbE1ldGhvZCAtIFRoZSBjYWNoZWQgbWV0aG9kIHRoYXQgYWNjZXB0cyBhIGNhbGxiYWNrXG4gICAgICogICAgIGFuZCByZXR1cm5zIGBuZXh0UXVlcnlgIHRvIHJlY2VpdmUgbW9yZSByZXN1bHRzLlxuICAgICAqL1xuICAgIHJ1bl8ocGFyc2VkQXJndW1lbnRzLCBvcmlnaW5hbE1ldGhvZCkge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHBhcnNlZEFyZ3VtZW50cy5xdWVyeTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBwYXJzZWRBcmd1bWVudHMuY2FsbGJhY2s7XG4gICAgICAgIGlmICghcGFyc2VkQXJndW1lbnRzLmF1dG9QYWdpbmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kKHF1ZXJ5LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBsZXQgb3RoZXJBcmdzID0gW107XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBwYWdpbmF0b3IucnVuQXNTdHJlYW1fKHBhcnNlZEFyZ3VtZW50cywgb3JpZ2luYWxNZXRob2QpO1xuICAgICAgICAgICAgc3RyZWFtXG4gICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICAgICAgICAub24oJ2RhdGEnLCAoZGF0YSkgPT4gcmVzdWx0cy5wdXNoKGRhdGEpKVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG90aGVyQXJncyA9IHN0cmVhbS5fb3RoZXJBcmdzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVzdWx0cyA9PiBbcmVzdWx0cywgcXVlcnksIC4uLm90aGVyQXJnc10pO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2UudGhlbihyZXN1bHRzID0+IGNhbGxiYWNrKG51bGwsIHJlc3VsdHMsIHF1ZXJ5LCAuLi5vdGhlckFyZ3MpLCAoZXJyKSA9PiBjYWxsYmFjayhlcnIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2ltcGx5IGNhbGxzIHRoZSBuZXh0UXVlcnkgcmVjdXJzaXZlbHksIGVtaXR0aW5nIHJlc3VsdHMgdG8gYVxuICAgICAqIHN0cmVhbS4gVGhlIHN0cmVhbSBlbmRzIHdoZW4gYG5leHRRdWVyeWAgaXMgbnVsbC5cbiAgICAgKlxuICAgICAqIGBtYXhSZXN1bHRzYCB3aWxsIGFjdCBhcyBhIGNhcCBmb3IgaG93IG1hbnkgcmVzdWx0cyBhcmUgZmV0Y2hlZCBhbmQgZW1pdHRlZFxuICAgICAqIHRvIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdD18c3RyaW5nPX0gcGFyc2VkQXJndW1lbnRzLnF1ZXJ5IC0gUXVlcnkgb2JqZWN0LiBUaGlzIGlzIG1vc3RcbiAgICAgKiAgICAgY29tbW9ubHkgYW4gb2JqZWN0LCBidXQgdG8gbWFrZSB0aGUgQVBJIG1vcmUgc2ltcGxlLCBpdCBjYW4gYWxzbyBiZSBhXG4gICAgICogICAgIHN0cmluZyBpbiBzb21lIHBsYWNlcy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gcGFyc2VkQXJndW1lbnRzLmNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJzZWRBcmd1bWVudHMuYXV0b1BhZ2luYXRlIC0gQXV0by1wYWdpbmF0aW9uIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJzZWRBcmd1bWVudHMubWF4QXBpQ2FsbHMgLSBNYXhpbXVtIEFQSSBjYWxscyB0byBtYWtlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJzZWRBcmd1bWVudHMubWF4UmVzdWx0cyAtIE1heGltdW0gcmVzdWx0cyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3JpZ2luYWxNZXRob2QgLSBUaGUgY2FjaGVkIG1ldGhvZCB0aGF0IGFjY2VwdHMgYSBjYWxsYmFja1xuICAgICAqICAgICBhbmQgcmV0dXJucyBgbmV4dFF1ZXJ5YCB0byByZWNlaXZlIG1vcmUgcmVzdWx0cy5cbiAgICAgKiBAcmV0dXJuIHtzdHJlYW19IC0gUmVhZGFibGUgb2JqZWN0IHN0cmVhbS5cbiAgICAgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgIHJ1bkFzU3RyZWFtXyhwYXJzZWRBcmd1bWVudHMsIG9yaWdpbmFsTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVzb3VyY2Vfc3RyZWFtXzEuUmVzb3VyY2VTdHJlYW0ocGFyc2VkQXJndW1lbnRzLCBvcmlnaW5hbE1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5QYWdpbmF0b3IgPSBQYWdpbmF0b3I7XG5jb25zdCBwYWdpbmF0b3IgPSBuZXcgUGFnaW5hdG9yKCk7XG5leHBvcnRzLnBhZ2luYXRvciA9IHBhZ2luYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/paginator/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/paginator/build/src/resource-stream.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@google-cloud/paginator/build/src/resource-stream.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceStream = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nclass ResourceStream extends stream_1.Transform {\n    constructor(args, requestFn) {\n        const options = Object.assign({ objectMode: true }, args.streamOptions);\n        super(options);\n        this._ended = false;\n        this._maxApiCalls = args.maxApiCalls === -1 ? Infinity : args.maxApiCalls;\n        this._nextQuery = args.query;\n        this._reading = false;\n        this._requestFn = requestFn;\n        this._requestsMade = 0;\n        this._resultsToSend = args.maxResults === -1 ? Infinity : args.maxResults;\n        this._otherArgs = [];\n    }\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    end(...args) {\n        this._ended = true;\n        return super.end(...args);\n    }\n    _read() {\n        if (this._reading) {\n            return;\n        }\n        this._reading = true;\n        // Wrap in a try/catch to catch input linting errors, e.g.\n        // an invalid BigQuery query. These errors are thrown in an\n        // async fashion, which makes them un-catchable by the user.\n        try {\n            this._requestFn(this._nextQuery, (err, results, nextQuery, ...otherArgs) => {\n                if (err) {\n                    this.destroy(err);\n                    return;\n                }\n                this._otherArgs = otherArgs;\n                this._nextQuery = nextQuery;\n                if (this._resultsToSend !== Infinity) {\n                    results = results.splice(0, this._resultsToSend);\n                    this._resultsToSend -= results.length;\n                }\n                let more = true;\n                for (const result of results) {\n                    if (this._ended) {\n                        break;\n                    }\n                    more = this.push(result);\n                }\n                const isFinished = !this._nextQuery || this._resultsToSend < 1;\n                const madeMaxCalls = ++this._requestsMade >= this._maxApiCalls;\n                if (isFinished || madeMaxCalls) {\n                    this.end();\n                }\n                if (more && !this._ended) {\n                    setImmediate(() => this._read());\n                }\n                this._reading = false;\n            });\n        }\n        catch (e) {\n            this.destroy(e);\n        }\n    }\n}\nexports.ResourceStream = ResourceStream;\n//# sourceMappingURL=resource-stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wYWdpbmF0b3IvYnVpbGQvc3JjL3Jlc291cmNlLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiL1VzZXJzL2thaXNlaS9EZXNrdG9wL20tdHJhY2VyLWFpL25vZGVfbW9kdWxlcy9AZ29vZ2xlLWNsb3VkL3BhZ2luYXRvci9idWlsZC9zcmMvcmVzb3VyY2Utc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb3VyY2VTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jbGFzcyBSZXNvdXJjZVN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoYXJncywgcmVxdWVzdEZuKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgb2JqZWN0TW9kZTogdHJ1ZSB9LCBhcmdzLnN0cmVhbU9wdGlvbnMpO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWF4QXBpQ2FsbHMgPSBhcmdzLm1heEFwaUNhbGxzID09PSAtMSA/IEluZmluaXR5IDogYXJncy5tYXhBcGlDYWxscztcbiAgICAgICAgdGhpcy5fbmV4dFF1ZXJ5ID0gYXJncy5xdWVyeTtcbiAgICAgICAgdGhpcy5fcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0Rm4gPSByZXF1ZXN0Rm47XG4gICAgICAgIHRoaXMuX3JlcXVlc3RzTWFkZSA9IDA7XG4gICAgICAgIHRoaXMuX3Jlc3VsdHNUb1NlbmQgPSBhcmdzLm1heFJlc3VsdHMgPT09IC0xID8gSW5maW5pdHkgOiBhcmdzLm1heFJlc3VsdHM7XG4gICAgICAgIHRoaXMuX290aGVyQXJncyA9IFtdO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgIGVuZCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2VuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCguLi5hcmdzKTtcbiAgICB9XG4gICAgX3JlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVhZGluZyA9IHRydWU7XG4gICAgICAgIC8vIFdyYXAgaW4gYSB0cnkvY2F0Y2ggdG8gY2F0Y2ggaW5wdXQgbGludGluZyBlcnJvcnMsIGUuZy5cbiAgICAgICAgLy8gYW4gaW52YWxpZCBCaWdRdWVyeSBxdWVyeS4gVGhlc2UgZXJyb3JzIGFyZSB0aHJvd24gaW4gYW5cbiAgICAgICAgLy8gYXN5bmMgZmFzaGlvbiwgd2hpY2ggbWFrZXMgdGhlbSB1bi1jYXRjaGFibGUgYnkgdGhlIHVzZXIuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0Rm4odGhpcy5fbmV4dFF1ZXJ5LCAoZXJyLCByZXN1bHRzLCBuZXh0UXVlcnksIC4uLm90aGVyQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb3RoZXJBcmdzID0gb3RoZXJBcmdzO1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRRdWVyeSA9IG5leHRRdWVyeTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVzdWx0c1RvU2VuZCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc3BsaWNlKDAsIHRoaXMuX3Jlc3VsdHNUb1NlbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHRzVG9TZW5kIC09IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbW9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vcmUgPSB0aGlzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGaW5pc2hlZCA9ICF0aGlzLl9uZXh0UXVlcnkgfHwgdGhpcy5fcmVzdWx0c1RvU2VuZCA8IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFkZU1heENhbGxzID0gKyt0aGlzLl9yZXF1ZXN0c01hZGUgPj0gdGhpcy5fbWF4QXBpQ2FsbHM7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXNoZWQgfHwgbWFkZU1heENhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtb3JlICYmICF0aGlzLl9lbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fcmVhZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVzb3VyY2VTdHJlYW0gPSBSZXNvdXJjZVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlLXN0cmVhbS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/paginator/build/src/resource-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/precise-date/build/src/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@google-cloud/precise-date/build/src/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PreciseDate = void 0;\nconst FULL_ISO_REG = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d{4,9}Z/;\nconst NO_BIG_INT = 'BigInt only available in Node >= v10.7. Consider using getFullTimeString instead.';\nvar Sign;\n(function (Sign) {\n    Sign[Sign[\"NEGATIVE\"] = -1] = \"NEGATIVE\";\n    Sign[Sign[\"POSITIVE\"] = 1] = \"POSITIVE\";\n    Sign[Sign[\"ZERO\"] = 0] = \"ZERO\";\n})(Sign || (Sign = {}));\n/**\n * The native Date object.\n * @external Date\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date}\n */\n/**\n * @typedef {array} DateTuple\n * @property {number} 0 Represents seconds of UTC time since Unix epoch\n *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n *     9999-12-31T23:59:59Z inclusive.\n * @property {number} 1 Non-negative fractions of a second at nanosecond\n *     resolution. Negative second values with fractions must still have\n *     non-negative nanos values that count forward in time. Must be from 0 to\n *     999,999,999 inclusive.\n */\n/**\n * @typedef {object} DateStruct\n * @property {number} seconds Represents seconds of UTC time since Unix epoch\n *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n *     9999-12-31T23:59:59Z inclusive.\n * @property {number} nanos Non-negative fractions of a second at nanosecond\n *     resolution. Negative second values with fractions must still have\n *     non-negative nanos values that count forward in time. Must be from 0 to\n *     999,999,999 inclusive.\n */\n/**\n * Date object with nanosecond precision. Supports all standard Date arguments\n * in addition to several custom types as noted below.\n *\n * @class\n * @extends external:Date\n *\n * @param {number|string|bigint|Date|DateTuple|DateStruct} [time] The time\n *     value.\n * @param {...number} [dateFields] Additional date fields (month, date, hours,\n *     minutes, seconds, milliseconds, microseconds, nanoseconds).\n *\n * @example <caption>With a RFC 3339 formatted string.</caption>\n * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n *\n * @example <caption>With a nanosecond timestamp string.</caption>\n * const date = new PreciseDate('1549622069481320032');\n *\n * @example <caption>With a BigInt (requires Node >= v10.7)</caption>\n * const date = new PreciseDate(1549622069481320032n);\n *\n * @example <caption>With a tuple containing seconds and nanoseconds.</caption>\n * const date = new PreciseDate([1549622069, 481320032]);\n *\n * @example <caption>With an object containing `seconds` and `nanos`</caption>\n * const date = new PreciseDate({seconds: 1549622069, nanos: 481320032});\n *\n * @example <caption>Specifiying date fields</caption>\n * const date = new PreciseDate(2018, 5, 14, 41, 11, 34, 123, 874, 321);\n */\nclass PreciseDate extends Date {\n    constructor(time) {\n        super();\n        this._micros = 0;\n        this._nanos = 0;\n        if (time && typeof time !== 'number' && !(time instanceof Date)) {\n            this.setFullTime(PreciseDate.parseFull(time));\n            return;\n        }\n        // eslint-disable-next-line prefer-rest-params\n        const args = Array.from(arguments);\n        const dateFields = args.slice(0, 7);\n        const date = new Date(...dateFields);\n        const nanos = args.length === 9 ? args.pop() : 0;\n        const micros = args.length === 8 ? args.pop() : 0;\n        this.setTime(date.getTime());\n        this.setMicroseconds(micros);\n        this.setNanoseconds(nanos);\n    }\n    /**\n     * Returns the specified date represented in nanoseconds according to\n     * universal time.\n     *\n     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.\n     * Use {@link PreciseDate#getFullTimeString} to get the time as a string.\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @throws {error} If `BigInt` is unavailable.\n     * @returns {bigint}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getFullTime());\n     * // expected output: 1549622069481145231n\n     */\n    getFullTime() {\n        if (typeof BigInt !== 'function') {\n            throw new Error(NO_BIG_INT);\n        }\n        return BigInt(this.getFullTimeString());\n    }\n    /**\n     * Returns a string of the specified date represented in nanoseconds according\n     * to universal time.\n     *\n     * @returns {string}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getFullTimeString());\n     * // expected output: \"1549622069481145231\"\n     */\n    getFullTimeString() {\n        const seconds = this._getSeconds();\n        let nanos = this._getNanos();\n        if (nanos && Math.sign(seconds) === Sign.NEGATIVE) {\n            nanos = 1e9 - nanos;\n        }\n        return `${seconds}${padLeft(nanos, 9)}`;\n    }\n    /**\n     * Returns the microseconds in the specified date according to universal time.\n     *\n     * @returns {number}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145Z');\n     *\n     * console.log(date.getMicroseconds());\n     * // expected output: 145\n     */\n    getMicroseconds() {\n        return this._micros;\n    }\n    /**\n     * Returns the nanoseconds in the specified date according to universal time.\n     *\n     * @returns {number}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getNanoseconds());\n     * // expected output: 231\n     */\n    getNanoseconds() {\n        return this._nanos;\n    }\n    /**\n     * Sets the microseconds for a specified date according to universal time.\n     *\n     * @param {number} microseconds A number representing the microseconds.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example\n     * const date = new PreciseDate();\n     *\n     * date.setMicroseconds(149);\n     *\n     * console.log(date.getMicroseconds());\n     * // expected output: 149\n     */\n    setMicroseconds(micros) {\n        const abs = Math.abs(micros);\n        let millis = this.getUTCMilliseconds();\n        if (abs >= 1000) {\n            millis += Math.floor(abs / 1000) * Math.sign(micros);\n            micros %= 1000;\n        }\n        if (Math.sign(micros) === Sign.NEGATIVE) {\n            millis -= 1;\n            micros += 1000;\n        }\n        this._micros = micros;\n        this.setUTCMilliseconds(millis);\n        return this.getFullTimeString();\n    }\n    /**\n     * Sets the nanoseconds for a specified date according to universal time.\n     *\n     * @param {number} nanoseconds A number representing the nanoseconds.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example\n     * const date = new PreciseDate();\n     *\n     * date.setNanoseconds(231);\n     *\n     * console.log(date.getNanoseconds());\n     * // expected output: 231\n     */\n    setNanoseconds(nanos) {\n        const abs = Math.abs(nanos);\n        let micros = this._micros;\n        if (abs >= 1000) {\n            micros += Math.floor(abs / 1000) * Math.sign(nanos);\n            nanos %= 1000;\n        }\n        if (Math.sign(nanos) === Sign.NEGATIVE) {\n            micros -= 1;\n            nanos += 1000;\n        }\n        this._nanos = nanos;\n        return this.setMicroseconds(micros);\n    }\n    /**\n     * Sets the PreciseDate object to the time represented by a number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * @param {bigint|number|string} time Value representing the number of\n     *     nanoseconds since January 1, 1970, 00:00:00 UTC.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time (effectively, the value of\n     *     the argument).\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @example <caption>With a nanosecond string.</caption>\n     * const date = new PreciseDate();\n     * date.setFullTime('1549622069481145231');\n     *\n     * @example <caption>With a BigInt</caption>\n     * date.setFullTime(1549622069481145231n);\n     */\n    setFullTime(time) {\n        if (typeof time !== 'string') {\n            time = time.toString();\n        }\n        const sign = Math.sign(Number(time));\n        time = time.replace(/^-/, '');\n        const seconds = Number(time.substr(0, time.length - 9)) * sign;\n        const nanos = Number(time.substr(-9)) * sign;\n        this.setTime(seconds * 1000);\n        return this.setNanoseconds(nanos);\n    }\n    /**\n     * Sets the PreciseDate object to the time represented by a number of\n     * milliseconds since January 1, 1970, 00:00:00 UTC. Calling this method will\n     * reset both the microseconds and nanoseconds to 0.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime|Date#setTime}\n     *\n     * @param {number} time Value representing the number of milliseconds since\n     *     January 1, 1970, 00:00:00 UTC.\n     * @returns {string} The number of milliseconds between January 1, 1970,\n     *     00:00:00 UTC and the updated date (effectively, the value of the\n     *     argument).\n     */\n    setTime(time) {\n        this._micros = 0;\n        this._nanos = 0;\n        return super.setTime(time);\n    }\n    /**\n     * Returns a string in RFC 3339 format. Unlike the native `Date#toISOString`,\n     * this will return 9 digits to represent sub-second precision.\n     *\n     * @see {@link https://tools.ietf.org/html/rfc3339|RFC 3339}\n     *\n     * @returns {string}\n     *\n     * @example\n     * const date = new PreciseDate(1549622069481145231n);\n     *\n     * console.log(date.toISOString());\n     * // expected output: \"2019-02-08T10:34:29.481145231Z\"\n     */\n    toISOString() {\n        const micros = padLeft(this._micros, 3);\n        const nanos = padLeft(this._nanos, 3);\n        return super.toISOString().replace(/z$/i, `${micros}${nanos}Z`);\n    }\n    /**\n     * Returns an object representing the specified date according to universal\n     * time.\n     *\n     * @see {@link https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#timestamp|google.protobuf.Timestamp}\n     *\n     * @returns {DateStruct}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.toStruct());\n     * // expected output: {seconds: 1549622069, nanos: 481145231}\n     */\n    toStruct() {\n        let seconds = this._getSeconds();\n        const nanos = this._getNanos();\n        const sign = Math.sign(seconds);\n        // These objects are essentially a mirror of protobuf timestamps.\n        // `nanos` must always count forward in time, even if the date is <= Unix\n        // epoch. To do this we just need to count backwards 1 second and return the\n        // nanoseconds as is.\n        if (sign === Sign.NEGATIVE && nanos) {\n            seconds -= 1;\n        }\n        return { seconds, nanos };\n    }\n    /**\n     * Returns a tuple representing the specified date according to universal\n     * time.\n     *\n     * @returns {DateTuple}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.toTuple());\n     * // expected output: [1549622069, 481145231]\n     */\n    toTuple() {\n        const { seconds, nanos } = this.toStruct();\n        return [seconds, nanos];\n    }\n    /**\n     * Returns the total number of seconds in the specified date since Unix epoch.\n     * Numbers representing < epoch will be negative.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n    _getSeconds() {\n        const time = this.getTime();\n        const sign = Math.sign(time);\n        return Math.floor(Math.abs(time) / 1000) * sign;\n    }\n    /**\n     * Returns the sub-second precision of the specified date. This will always be\n     * a positive number.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n    _getNanos() {\n        const msInNanos = this.getUTCMilliseconds() * 1e6;\n        const microsInNanos = this._micros * 1000;\n        return this._nanos + msInNanos + microsInNanos;\n    }\n    /**\n     * Parses a precise time.\n     *\n     * @static\n     *\n     * @param {string|bigint|DateTuple|DateStruct} time The precise time value.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example <caption>From a RFC 3339 formatted string.</caption>\n     * const time = PreciseDate.parseFull('2019-02-08T10:34:29.481145231Z');\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a nanosecond timestamp string.</caption>\n     * const time = PreciseDate.parseFull('1549622069481145231');\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a BigInt (requires Node >= v10.7)</caption>\n     * const time = PreciseDate.parseFull(1549622069481145231n);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a tuple.</caption>\n     * const time = PreciseDate.parseFull([1549622069, 481145231]);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From an object.</caption>\n     * const struct = {seconds: 1549622069, nanos: 481145231};\n     * const time = PreciseDate.parseFull(struct);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     */\n    static parseFull(time) {\n        const date = new PreciseDate();\n        if (Array.isArray(time)) {\n            const [seconds, nanos] = time;\n            time = { seconds, nanos };\n        }\n        if (isFullTime(time)) {\n            date.setFullTime(time);\n        }\n        else if (isStruct(time)) {\n            const { seconds, nanos } = parseProto(time);\n            date.setTime(seconds * 1000);\n            date.setNanoseconds(nanos);\n        }\n        else if (isFullISOString(time)) {\n            date.setFullTime(parseFullISO(time));\n        }\n        else {\n            date.setTime(new Date(time).getTime());\n        }\n        return date.getFullTimeString();\n    }\n    /**\n     * Accepts the same number parameters as the PreciseDate constructor, but\n     * treats them as UTC. It returns a string that represents the number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @static\n     *\n     * @throws {error} If `BigInt` is unavailable.\n     *\n     * @param {...number} [dateFields] The date fields.\n     * @returns {bigint}\n     *\n     * @example\n     * const time = PreciseDate.fullUTC(2019, 1, 8, 10, 34, 29, 481, 145, 231);\n     * console.log(time); // expected output: 1549622069481145231n\n     */\n    static fullUTC(...args) {\n        if (typeof BigInt !== 'function') {\n            throw new Error(NO_BIG_INT);\n        }\n        return BigInt(PreciseDate.fullUTCString(...args));\n    }\n    /**\n     * Accepts the same number parameters as the PreciseDate constructor, but\n     * treats them as UTC. It returns a string that represents the number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * @static\n     *\n     * @param {...number} [dateFields] The date fields.\n     * @returns {string}\n     *\n     * @example\n     * const time = PreciseDate.fullUTCString(2019, 1, 8, 10, 34, 29, 481, 145,\n     * 231); console.log(time); // expected output: '1549622069481145231'\n     */\n    static fullUTCString(...args) {\n        const milliseconds = Date.UTC(...args.slice(0, 7));\n        const date = new PreciseDate(milliseconds);\n        if (args.length === 9) {\n            date.setNanoseconds(args.pop());\n        }\n        if (args.length === 8) {\n            date.setMicroseconds(args.pop());\n        }\n        return date.getFullTimeString();\n    }\n}\nexports.PreciseDate = PreciseDate;\n/**\n * Parses a RFC 3339 formatted string representation of the date, and returns\n * a string representing the nanoseconds since January 1, 1970, 00:00:00.\n *\n * @private\n *\n * @param {string} time The RFC 3339 formatted string.\n * @returns {string}\n */\nfunction parseFullISO(time) {\n    let digits = '0';\n    time = time.replace(/\\.(\\d+)/, ($0, $1) => {\n        digits = $1;\n        return '.000';\n    });\n    const nanos = Number(padRight(digits, 9));\n    const date = new PreciseDate(time);\n    return date.setNanoseconds(nanos);\n}\n/**\n * Normalizes a {@link google.protobuf.Timestamp} object.\n *\n * @private\n *\n * @param {google.protobuf.Timestamp} timestamp The timestamp object.\n * @returns {DateStruct}\n */\nfunction parseProto({ seconds = 0, nanos = 0 }) {\n    if (typeof seconds.toNumber === 'function') {\n        seconds = seconds.toNumber();\n    }\n    seconds = Number(seconds);\n    nanos = Number(nanos);\n    return { seconds, nanos };\n}\n/**\n * Checks to see if time value is specified in nanoseconds. We assume that all\n * BigInt and string timestamps represent nanoseconds.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isFullTime(time) {\n    return (typeof time === 'bigint' || (typeof time === 'string' && /^\\d+$/.test(time)));\n}\n/**\n * Checks to see if time value is a {@link DateStruct}.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isStruct(time) {\n    return ((typeof time === 'object' &&\n        typeof time.seconds !== 'undefined') ||\n        typeof time.nanos === 'number');\n}\n/**\n * Checks to see if the time value is a RFC 3339 formatted string.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isFullISOString(time) {\n    return typeof time === 'string' && FULL_ISO_REG.test(time);\n}\n/**\n * Pads a number/string with \"0\" to the left.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} min The min size of the padded string.\n * @returns {string}\n */\nfunction padLeft(n, min) {\n    const padding = getPadding(n, min);\n    return `${padding}${n}`;\n}\n/**\n * Pads a number/string with \"0\" to the right.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} min The min size of the padded string.\n * @returns {string}\n */\nfunction padRight(n, min) {\n    const padding = getPadding(n, min);\n    return `${n}${padding}`;\n}\n/**\n * Creates padding based on current size and min size needed.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} [min=3] The min size of the padded string.\n * @returns {string}\n */\nfunction getPadding(n, min) {\n    const size = Math.max(min - n.toString().length, 0);\n    return '0'.repeat(size);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wcmVjaXNlLWRhdGUvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQix5QkFBeUIsRUFBRSw0Q0FBNEMsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRDtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsRUFBRSxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxFQUFFLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMva2Fpc2VpL0Rlc2t0b3AvbS10cmFjZXItYWkvbm9kZV9tb2R1bGVzL0Bnb29nbGUtY2xvdWQvcHJlY2lzZS1kYXRlL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByZWNpc2VEYXRlID0gdm9pZCAwO1xuY29uc3QgRlVMTF9JU09fUkVHID0gL1xcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkezQsOX1aLztcbmNvbnN0IE5PX0JJR19JTlQgPSAnQmlnSW50IG9ubHkgYXZhaWxhYmxlIGluIE5vZGUgPj0gdjEwLjcuIENvbnNpZGVyIHVzaW5nIGdldEZ1bGxUaW1lU3RyaW5nIGluc3RlYWQuJztcbnZhciBTaWduO1xuKGZ1bmN0aW9uIChTaWduKSB7XG4gICAgU2lnbltTaWduW1wiTkVHQVRJVkVcIl0gPSAtMV0gPSBcIk5FR0FUSVZFXCI7XG4gICAgU2lnbltTaWduW1wiUE9TSVRJVkVcIl0gPSAxXSA9IFwiUE9TSVRJVkVcIjtcbiAgICBTaWduW1NpZ25bXCJaRVJPXCJdID0gMF0gPSBcIlpFUk9cIjtcbn0pKFNpZ24gfHwgKFNpZ24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmF0aXZlIERhdGUgb2JqZWN0LlxuICogQGV4dGVybmFsIERhdGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGV9XG4gKi9cbi8qKlxuICogQHR5cGVkZWYge2FycmF5fSBEYXRlVHVwbGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAwIFJlcHJlc2VudHMgc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoXG4gKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICogICAgIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAxIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxuICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXG4gKiAgICAgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlcyB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZSBmcm9tIDAgdG9cbiAqICAgICA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRGF0ZVN0cnVjdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNlY29uZHMgUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gKiAgICAgOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5hbm9zIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxuICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXG4gKiAgICAgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlcyB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZSBmcm9tIDAgdG9cbiAqICAgICA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXG4gKi9cbi8qKlxuICogRGF0ZSBvYmplY3Qgd2l0aCBuYW5vc2Vjb25kIHByZWNpc2lvbi4gU3VwcG9ydHMgYWxsIHN0YW5kYXJkIERhdGUgYXJndW1lbnRzXG4gKiBpbiBhZGRpdGlvbiB0byBzZXZlcmFsIGN1c3RvbSB0eXBlcyBhcyBub3RlZCBiZWxvdy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIGV4dGVybmFsOkRhdGVcbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8YmlnaW50fERhdGV8RGF0ZVR1cGxlfERhdGVTdHJ1Y3R9IFt0aW1lXSBUaGUgdGltZVxuICogICAgIHZhbHVlLlxuICogQHBhcmFtIHsuLi5udW1iZXJ9IFtkYXRlRmllbGRzXSBBZGRpdGlvbmFsIGRhdGUgZmllbGRzIChtb250aCwgZGF0ZSwgaG91cnMsXG4gKiAgICAgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgUkZDIDMzMzkgZm9ybWF0dGVkIHN0cmluZy48L2NhcHRpb24+XG4gKiBjb25zdCBkYXRlID0gbmV3IFByZWNpc2VEYXRlKCcyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVonKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgbmFub3NlY29uZCB0aW1lc3RhbXAgc3RyaW5nLjwvY2FwdGlvbj5cbiAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzE1NDk2MjIwNjk0ODEzMjAwMzInKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgQmlnSW50IChyZXF1aXJlcyBOb2RlID49IHYxMC43KTwvY2FwdGlvbj5cbiAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoMTU0OTYyMjA2OTQ4MTMyMDAzMm4pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPldpdGggYSB0dXBsZSBjb250YWluaW5nIHNlY29uZHMgYW5kIG5hbm9zZWNvbmRzLjwvY2FwdGlvbj5cbiAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoWzE1NDk2MjIwNjksIDQ4MTMyMDAzMl0pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPldpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHNlY29uZHNgIGFuZCBgbmFub3NgPC9jYXB0aW9uPlxuICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSh7c2Vjb25kczogMTU0OTYyMjA2OSwgbmFub3M6IDQ4MTMyMDAzMn0pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNwZWNpZml5aW5nIGRhdGUgZmllbGRzPC9jYXB0aW9uPlxuICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSgyMDE4LCA1LCAxNCwgNDEsIDExLCAzNCwgMTIzLCA4NzQsIDMyMSk7XG4gKi9cbmNsYXNzIFByZWNpc2VEYXRlIGV4dGVuZHMgRGF0ZSB7XG4gICAgY29uc3RydWN0b3IodGltZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9taWNyb3MgPSAwO1xuICAgICAgICB0aGlzLl9uYW5vcyA9IDA7XG4gICAgICAgIGlmICh0aW1lICYmIHR5cGVvZiB0aW1lICE9PSAnbnVtYmVyJyAmJiAhKHRpbWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRGdWxsVGltZShQcmVjaXNlRGF0ZS5wYXJzZUZ1bGwodGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICAgICAgY29uc3QgZGF0ZUZpZWxkcyA9IGFyZ3Muc2xpY2UoMCwgNyk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSguLi5kYXRlRmllbGRzKTtcbiAgICAgICAgY29uc3QgbmFub3MgPSBhcmdzLmxlbmd0aCA9PT0gOSA/IGFyZ3MucG9wKCkgOiAwO1xuICAgICAgICBjb25zdCBtaWNyb3MgPSBhcmdzLmxlbmd0aCA9PT0gOCA/IGFyZ3MucG9wKCkgOiAwO1xuICAgICAgICB0aGlzLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICB0aGlzLnNldE1pY3Jvc2Vjb25kcyhtaWNyb3MpO1xuICAgICAgICB0aGlzLnNldE5hbm9zZWNvbmRzKG5hbm9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIGRhdGUgcmVwcmVzZW50ZWQgaW4gbmFub3NlY29uZHMgYWNjb3JkaW5nIHRvXG4gICAgICogdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiAqKk5PVEU6KiogQmVjYXVzZSB0aGlzIG1ldGhvZCByZXR1cm5zIGEgYEJpZ0ludGAgaXQgcmVxdWlyZXMgTm9kZSA+PSB2MTAuNy5cbiAgICAgKiBVc2Uge0BsaW5rIFByZWNpc2VEYXRlI2dldEZ1bGxUaW1lU3RyaW5nfSB0byBnZXQgdGhlIHRpbWUgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1iaWdpbnR8QmlnSW50fVxuICAgICAqXG4gICAgICogQHRocm93cyB7ZXJyb3J9IElmIGBCaWdJbnRgIGlzIHVuYXZhaWxhYmxlLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1MjMxWicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS5nZXRGdWxsVGltZSgpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IDE1NDk2MjIwNjk0ODExNDUyMzFuXG4gICAgICovXG4gICAgZ2V0RnVsbFRpbWUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQmlnSW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTk9fQklHX0lOVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLmdldEZ1bGxUaW1lU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBzcGVjaWZpZWQgZGF0ZSByZXByZXNlbnRlZCBpbiBuYW5vc2Vjb25kcyBhY2NvcmRpbmdcbiAgICAgKiB0byB1bml2ZXJzYWwgdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1MjMxWicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS5nZXRGdWxsVGltZVN0cmluZygpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IFwiMTU0OTYyMjA2OTQ4MTE0NTIzMVwiXG4gICAgICovXG4gICAgZ2V0RnVsbFRpbWVTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSB0aGlzLl9nZXRTZWNvbmRzKCk7XG4gICAgICAgIGxldCBuYW5vcyA9IHRoaXMuX2dldE5hbm9zKCk7XG4gICAgICAgIGlmIChuYW5vcyAmJiBNYXRoLnNpZ24oc2Vjb25kcykgPT09IFNpZ24uTkVHQVRJVkUpIHtcbiAgICAgICAgICAgIG5hbm9zID0gMWU5IC0gbmFub3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3NlY29uZHN9JHtwYWRMZWZ0KG5hbm9zLCA5KX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaWNyb3NlY29uZHMgaW4gdGhlIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1WicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS5nZXRNaWNyb3NlY29uZHMoKSk7XG4gICAgICogLy8gZXhwZWN0ZWQgb3V0cHV0OiAxNDVcbiAgICAgKi9cbiAgICBnZXRNaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taWNyb3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbm9zZWNvbmRzIGluIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBkYXRlID0gbmV3IFByZWNpc2VEYXRlKCcyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVonKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUuZ2V0TmFub3NlY29uZHMoKSk7XG4gICAgICogLy8gZXhwZWN0ZWQgb3V0cHV0OiAyMzFcbiAgICAgKi9cbiAgICBnZXROYW5vc2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaWNyb3NlY29uZHMgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pY3Jvc2Vjb25kcyBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG1pY3Jvc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFub3NlY29uZHMgaW4gdGhlXG4gICAgICogICAgIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSgpO1xuICAgICAqXG4gICAgICogZGF0ZS5zZXRNaWNyb3NlY29uZHMoMTQ5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUuZ2V0TWljcm9zZWNvbmRzKCkpO1xuICAgICAqIC8vIGV4cGVjdGVkIG91dHB1dDogMTQ5XG4gICAgICovXG4gICAgc2V0TWljcm9zZWNvbmRzKG1pY3Jvcykge1xuICAgICAgICBjb25zdCBhYnMgPSBNYXRoLmFicyhtaWNyb3MpO1xuICAgICAgICBsZXQgbWlsbGlzID0gdGhpcy5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgaWYgKGFicyA+PSAxMDAwKSB7XG4gICAgICAgICAgICBtaWxsaXMgKz0gTWF0aC5mbG9vcihhYnMgLyAxMDAwKSAqIE1hdGguc2lnbihtaWNyb3MpO1xuICAgICAgICAgICAgbWljcm9zICU9IDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguc2lnbihtaWNyb3MpID09PSBTaWduLk5FR0FUSVZFKSB7XG4gICAgICAgICAgICBtaWxsaXMgLT0gMTtcbiAgICAgICAgICAgIG1pY3JvcyArPSAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21pY3JvcyA9IG1pY3JvcztcbiAgICAgICAgdGhpcy5zZXRVVENNaWxsaXNlY29uZHMobWlsbGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RnVsbFRpbWVTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbmFub3NlY29uZHMgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5hbm9zZWNvbmRzIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbmFub3NlY29uZHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIGluIHRoZVxuICAgICAqICAgICBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoKTtcbiAgICAgKlxuICAgICAqIGRhdGUuc2V0TmFub3NlY29uZHMoMjMxKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUuZ2V0TmFub3NlY29uZHMoKSk7XG4gICAgICogLy8gZXhwZWN0ZWQgb3V0cHV0OiAyMzFcbiAgICAgKi9cbiAgICBzZXROYW5vc2Vjb25kcyhuYW5vcykge1xuICAgICAgICBjb25zdCBhYnMgPSBNYXRoLmFicyhuYW5vcyk7XG4gICAgICAgIGxldCBtaWNyb3MgPSB0aGlzLl9taWNyb3M7XG4gICAgICAgIGlmIChhYnMgPj0gMTAwMCkge1xuICAgICAgICAgICAgbWljcm9zICs9IE1hdGguZmxvb3IoYWJzIC8gMTAwMCkgKiBNYXRoLnNpZ24obmFub3MpO1xuICAgICAgICAgICAgbmFub3MgJT0gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5zaWduKG5hbm9zKSA9PT0gU2lnbi5ORUdBVElWRSkge1xuICAgICAgICAgICAgbWljcm9zIC09IDE7XG4gICAgICAgICAgICBuYW5vcyArPSAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25hbm9zID0gbmFub3M7XG4gICAgICAgIHJldHVybiB0aGlzLnNldE1pY3Jvc2Vjb25kcyhtaWNyb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBQcmVjaXNlRGF0ZSBvYmplY3QgdG8gdGhlIHRpbWUgcmVwcmVzZW50ZWQgYnkgYSBudW1iZXIgb2ZcbiAgICAgKiBuYW5vc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAsIDAwOjAwOjAwIFVUQy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YmlnaW50fG51bWJlcnxzdHJpbmd9IHRpbWUgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2ZcbiAgICAgKiAgICAgbmFub3NlY29uZHMgc2luY2UgSmFudWFyeSAxLCAxOTcwLCAwMDowMDowMCBVVEMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIGluIHRoZVxuICAgICAqICAgICBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUgKGVmZmVjdGl2ZWx5LCB0aGUgdmFsdWUgb2ZcbiAgICAgKiAgICAgdGhlIGFyZ3VtZW50KS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWJpZ2ludHxCaWdJbnR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgbmFub3NlY29uZCBzdHJpbmcuPC9jYXB0aW9uPlxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoKTtcbiAgICAgKiBkYXRlLnNldEZ1bGxUaW1lKCcxNTQ5NjIyMDY5NDgxMTQ1MjMxJyk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgQmlnSW50PC9jYXB0aW9uPlxuICAgICAqIGRhdGUuc2V0RnVsbFRpbWUoMTU0OTYyMjA2OTQ4MTE0NTIzMW4pO1xuICAgICAqL1xuICAgIHNldEZ1bGxUaW1lKHRpbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGltZSA9IHRpbWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKE51bWJlcih0aW1lKSk7XG4gICAgICAgIHRpbWUgPSB0aW1lLnJlcGxhY2UoL14tLywgJycpO1xuICAgICAgICBjb25zdCBzZWNvbmRzID0gTnVtYmVyKHRpbWUuc3Vic3RyKDAsIHRpbWUubGVuZ3RoIC0gOSkpICogc2lnbjtcbiAgICAgICAgY29uc3QgbmFub3MgPSBOdW1iZXIodGltZS5zdWJzdHIoLTkpKSAqIHNpZ247XG4gICAgICAgIHRoaXMuc2V0VGltZShzZWNvbmRzICogMTAwMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNldE5hbm9zZWNvbmRzKG5hbm9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUHJlY2lzZURhdGUgb2JqZWN0IHRvIHRoZSB0aW1lIHJlcHJlc2VudGVkIGJ5IGEgbnVtYmVyIG9mXG4gICAgICogbWlsbGlzZWNvbmRzIHNpbmNlIEphbnVhcnkgMSwgMTk3MCwgMDA6MDA6MDAgVVRDLiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGxcbiAgICAgKiByZXNldCBib3RoIHRoZSBtaWNyb3NlY29uZHMgYW5kIG5hbm9zZWNvbmRzIHRvIDAuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldFRpbWV8RGF0ZSNzZXRUaW1lfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgICogICAgIEphbnVhcnkgMSwgMTk3MCwgMDA6MDA6MDAgVVRDLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gSmFudWFyeSAxLCAxOTcwLFxuICAgICAqICAgICAwMDowMDowMCBVVEMgYW5kIHRoZSB1cGRhdGVkIGRhdGUgKGVmZmVjdGl2ZWx5LCB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICogICAgIGFyZ3VtZW50KS5cbiAgICAgKi9cbiAgICBzZXRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy5fbWljcm9zID0gMDtcbiAgICAgICAgdGhpcy5fbmFub3MgPSAwO1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0VGltZSh0aW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBpbiBSRkMgMzMzOSBmb3JtYXQuIFVubGlrZSB0aGUgbmF0aXZlIGBEYXRlI3RvSVNPU3RyaW5nYCxcbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIDkgZGlnaXRzIHRvIHJlcHJlc2VudCBzdWItc2Vjb25kIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5fFJGQyAzMzM5fVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSgxNTQ5NjIyMDY5NDgxMTQ1MjMxbik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhkYXRlLnRvSVNPU3RyaW5nKCkpO1xuICAgICAqIC8vIGV4cGVjdGVkIG91dHB1dDogXCIyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVpcIlxuICAgICAqL1xuICAgIHRvSVNPU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBtaWNyb3MgPSBwYWRMZWZ0KHRoaXMuX21pY3JvcywgMyk7XG4gICAgICAgIGNvbnN0IG5hbm9zID0gcGFkTGVmdCh0aGlzLl9uYW5vcywgMyk7XG4gICAgICAgIHJldHVybiBzdXBlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL3okL2ksIGAke21pY3Jvc30ke25hbm9zfVpgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsXG4gICAgICogdGltZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9yZWZlcmVuY2UvZ29vZ2xlLnByb3RvYnVmI3RpbWVzdGFtcHxnb29nbGUucHJvdG9idWYuVGltZXN0YW1wfVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RhdGVTdHJ1Y3R9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1MjMxWicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS50b1N0cnVjdCgpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IHtzZWNvbmRzOiAxNTQ5NjIyMDY5LCBuYW5vczogNDgxMTQ1MjMxfVxuICAgICAqL1xuICAgIHRvU3RydWN0KCkge1xuICAgICAgICBsZXQgc2Vjb25kcyA9IHRoaXMuX2dldFNlY29uZHMoKTtcbiAgICAgICAgY29uc3QgbmFub3MgPSB0aGlzLl9nZXROYW5vcygpO1xuICAgICAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKHNlY29uZHMpO1xuICAgICAgICAvLyBUaGVzZSBvYmplY3RzIGFyZSBlc3NlbnRpYWxseSBhIG1pcnJvciBvZiBwcm90b2J1ZiB0aW1lc3RhbXBzLlxuICAgICAgICAvLyBgbmFub3NgIG11c3QgYWx3YXlzIGNvdW50IGZvcndhcmQgaW4gdGltZSwgZXZlbiBpZiB0aGUgZGF0ZSBpcyA8PSBVbml4XG4gICAgICAgIC8vIGVwb2NoLiBUbyBkbyB0aGlzIHdlIGp1c3QgbmVlZCB0byBjb3VudCBiYWNrd2FyZHMgMSBzZWNvbmQgYW5kIHJldHVybiB0aGVcbiAgICAgICAgLy8gbmFub3NlY29uZHMgYXMgaXMuXG4gICAgICAgIGlmIChzaWduID09PSBTaWduLk5FR0FUSVZFICYmIG5hbm9zKSB7XG4gICAgICAgICAgICBzZWNvbmRzIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHR1cGxlIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbFxuICAgICAqIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RGF0ZVR1cGxlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBkYXRlID0gbmV3IFByZWNpc2VEYXRlKCcyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVonKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUudG9UdXBsZSgpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IFsxNTQ5NjIyMDY5LCA0ODExNDUyMzFdXG4gICAgICovXG4gICAgdG9UdXBsZSgpIHtcbiAgICAgICAgY29uc3QgeyBzZWNvbmRzLCBuYW5vcyB9ID0gdGhpcy50b1N0cnVjdCgpO1xuICAgICAgICByZXR1cm4gW3NlY29uZHMsIG5hbm9zXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIHNlY29uZHMgaW4gdGhlIHNwZWNpZmllZCBkYXRlIHNpbmNlIFVuaXggZXBvY2guXG4gICAgICogTnVtYmVycyByZXByZXNlbnRpbmcgPCBlcG9jaCB3aWxsIGJlIG5lZ2F0aXZlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgX2dldFNlY29uZHMoKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbih0aW1lKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5hYnModGltZSkgLyAxMDAwKSAqIHNpZ247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN1Yi1zZWNvbmQgcHJlY2lzaW9uIG9mIHRoZSBzcGVjaWZpZWQgZGF0ZS4gVGhpcyB3aWxsIGFsd2F5cyBiZVxuICAgICAqIGEgcG9zaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgX2dldE5hbm9zKCkge1xuICAgICAgICBjb25zdCBtc0luTmFub3MgPSB0aGlzLmdldFVUQ01pbGxpc2Vjb25kcygpICogMWU2O1xuICAgICAgICBjb25zdCBtaWNyb3NJbk5hbm9zID0gdGhpcy5fbWljcm9zICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbm9zICsgbXNJbk5hbm9zICsgbWljcm9zSW5OYW5vcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgcHJlY2lzZSB0aW1lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YmlnaW50fERhdGVUdXBsZXxEYXRlU3RydWN0fSB0aW1lIFRoZSBwcmVjaXNlIHRpbWUgdmFsdWUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIGluIHRoZVxuICAgICAqICAgICBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gcm9tIGEgUkZDIDMzMzkgZm9ybWF0dGVkIHN0cmluZy48L2NhcHRpb24+XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbCgnMjAxOS0wMi0wOFQxMDozNDoyOS40ODExNDUyMzFaJyk7XG4gICAgICogY29uc29sZS5sb2codGltZSk7IC8vIGV4cGVjdGVkIG91dHB1dDogXCIxNTQ5NjIyMDY5NDgxMTQ1MjMxXCJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZyb20gYSBuYW5vc2Vjb25kIHRpbWVzdGFtcCBzdHJpbmcuPC9jYXB0aW9uPlxuICAgICAqIGNvbnN0IHRpbWUgPSBQcmVjaXNlRGF0ZS5wYXJzZUZ1bGwoJzE1NDk2MjIwNjk0ODExNDUyMzEnKTtcbiAgICAgKiBjb25zb2xlLmxvZyh0aW1lKTsgLy8gZXhwZWN0ZWQgb3V0cHV0OiBcIjE1NDk2MjIwNjk0ODExNDUyMzFcIlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RnJvbSBhIEJpZ0ludCAocmVxdWlyZXMgTm9kZSA+PSB2MTAuNyk8L2NhcHRpb24+XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbCgxNTQ5NjIyMDY5NDgxMTQ1MjMxbik7XG4gICAgICogY29uc29sZS5sb2codGltZSk7IC8vIGV4cGVjdGVkIG91dHB1dDogXCIxNTQ5NjIyMDY5NDgxMTQ1MjMxXCJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZyb20gYSB0dXBsZS48L2NhcHRpb24+XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbChbMTU0OTYyMjA2OSwgNDgxMTQ1MjMxXSk7XG4gICAgICogY29uc29sZS5sb2codGltZSk7IC8vIGV4cGVjdGVkIG91dHB1dDogXCIxNTQ5NjIyMDY5NDgxMTQ1MjMxXCJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZyb20gYW4gb2JqZWN0LjwvY2FwdGlvbj5cbiAgICAgKiBjb25zdCBzdHJ1Y3QgPSB7c2Vjb25kczogMTU0OTYyMjA2OSwgbmFub3M6IDQ4MTE0NTIzMX07XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbChzdHJ1Y3QpO1xuICAgICAqIGNvbnNvbGUubG9nKHRpbWUpOyAvLyBleHBlY3RlZCBvdXRwdXQ6IFwiMTU0OTYyMjA2OTQ4MTE0NTIzMVwiXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRnVsbCh0aW1lKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGltZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtzZWNvbmRzLCBuYW5vc10gPSB0aW1lO1xuICAgICAgICAgICAgdGltZSA9IHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdWxsVGltZSh0aW1lKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsVGltZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0cnVjdCh0aW1lKSkge1xuICAgICAgICAgICAgY29uc3QgeyBzZWNvbmRzLCBuYW5vcyB9ID0gcGFyc2VQcm90byh0aW1lKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShzZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgICBkYXRlLnNldE5hbm9zZWNvbmRzKG5hbm9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bGxJU09TdHJpbmcodGltZSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFRpbWUocGFyc2VGdWxsSVNPKHRpbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShuZXcgRGF0ZSh0aW1lKS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxUaW1lU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgdGhlIHNhbWUgbnVtYmVyIHBhcmFtZXRlcnMgYXMgdGhlIFByZWNpc2VEYXRlIGNvbnN0cnVjdG9yLCBidXRcbiAgICAgKiB0cmVhdHMgdGhlbSBhcyBVVEMuIEl0IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBuYW5vc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAsIDAwOjAwOjAwIFVUQy5cbiAgICAgKlxuICAgICAqICoqTk9URToqKiBCZWNhdXNlIHRoaXMgbWV0aG9kIHJldHVybnMgYSBgQmlnSW50YCBpdCByZXF1aXJlcyBOb2RlID49IHYxMC43LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYmlnaW50fEJpZ0ludH1cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge2Vycm9yfSBJZiBgQmlnSW50YCBpcyB1bmF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4ubnVtYmVyfSBbZGF0ZUZpZWxkc10gVGhlIGRhdGUgZmllbGRzLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRpbWUgPSBQcmVjaXNlRGF0ZS5mdWxsVVRDKDIwMTksIDEsIDgsIDEwLCAzNCwgMjksIDQ4MSwgMTQ1LCAyMzEpO1xuICAgICAqIGNvbnNvbGUubG9nKHRpbWUpOyAvLyBleHBlY3RlZCBvdXRwdXQ6IDE1NDk2MjIwNjk0ODExNDUyMzFuXG4gICAgICovXG4gICAgc3RhdGljIGZ1bGxVVEMoLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIEJpZ0ludCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE5PX0JJR19JTlQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQoUHJlY2lzZURhdGUuZnVsbFVUQ1N0cmluZyguLi5hcmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgdGhlIHNhbWUgbnVtYmVyIHBhcmFtZXRlcnMgYXMgdGhlIFByZWNpc2VEYXRlIGNvbnN0cnVjdG9yLCBidXRcbiAgICAgKiB0cmVhdHMgdGhlbSBhcyBVVEMuIEl0IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBuYW5vc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAsIDAwOjAwOjAwIFVUQy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4ubnVtYmVyfSBbZGF0ZUZpZWxkc10gVGhlIGRhdGUgZmllbGRzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRpbWUgPSBQcmVjaXNlRGF0ZS5mdWxsVVRDU3RyaW5nKDIwMTksIDEsIDgsIDEwLCAzNCwgMjksIDQ4MSwgMTQ1LFxuICAgICAqIDIzMSk7IGNvbnNvbGUubG9nKHRpbWUpOyAvLyBleHBlY3RlZCBvdXRwdXQ6ICcxNTQ5NjIyMDY5NDgxMTQ1MjMxJ1xuICAgICAqL1xuICAgIHN0YXRpYyBmdWxsVVRDU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmRzID0gRGF0ZS5VVEMoLi4uYXJncy5zbGljZSgwLCA3KSk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUobWlsbGlzZWNvbmRzKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA5KSB7XG4gICAgICAgICAgICBkYXRlLnNldE5hbm9zZWNvbmRzKGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRNaWNyb3NlY29uZHMoYXJncy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFRpbWVTdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLlByZWNpc2VEYXRlID0gUHJlY2lzZURhdGU7XG4vKipcbiAqIFBhcnNlcyBhIFJGQyAzMzM5IGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGUsIGFuZCByZXR1cm5zXG4gKiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIHNpbmNlIEphbnVhcnkgMSwgMTk3MCwgMDA6MDA6MDAuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZSBUaGUgUkZDIDMzMzkgZm9ybWF0dGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRnVsbElTTyh0aW1lKSB7XG4gICAgbGV0IGRpZ2l0cyA9ICcwJztcbiAgICB0aW1lID0gdGltZS5yZXBsYWNlKC9cXC4oXFxkKykvLCAoJDAsICQxKSA9PiB7XG4gICAgICAgIGRpZ2l0cyA9ICQxO1xuICAgICAgICByZXR1cm4gJy4wMDAnO1xuICAgIH0pO1xuICAgIGNvbnN0IG5hbm9zID0gTnVtYmVyKHBhZFJpZ2h0KGRpZ2l0cywgOSkpO1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUodGltZSk7XG4gICAgcmV0dXJuIGRhdGUuc2V0TmFub3NlY29uZHMobmFub3MpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIGEge0BsaW5rIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXB9IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Z29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcH0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2JqZWN0LlxuICogQHJldHVybnMge0RhdGVTdHJ1Y3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvdG8oeyBzZWNvbmRzID0gMCwgbmFub3MgPSAwIH0pIHtcbiAgICBpZiAodHlwZW9mIHNlY29uZHMudG9OdW1iZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgc2Vjb25kcyA9IE51bWJlcihzZWNvbmRzKTtcbiAgICBuYW5vcyA9IE51bWJlcihuYW5vcyk7XG4gICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbn1cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aW1lIHZhbHVlIGlzIHNwZWNpZmllZCBpbiBuYW5vc2Vjb25kcy4gV2UgYXNzdW1lIHRoYXQgYWxsXG4gKiBCaWdJbnQgYW5kIHN0cmluZyB0aW1lc3RhbXBzIHJlcHJlc2VudCBuYW5vc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdGltZSBUaGUgdGltZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Z1bGxUaW1lKHRpbWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB0aW1lID09PSAnYmlnaW50JyB8fCAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnICYmIC9eXFxkKyQvLnRlc3QodGltZSkpKTtcbn1cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aW1lIHZhbHVlIGlzIGEge0BsaW5rIERhdGVTdHJ1Y3R9LlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHsqfSB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RydWN0KHRpbWUpIHtcbiAgICByZXR1cm4gKCh0eXBlb2YgdGltZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHRpbWUuc2Vjb25kcyAhPT0gJ3VuZGVmaW5lZCcpIHx8XG4gICAgICAgIHR5cGVvZiB0aW1lLm5hbm9zID09PSAnbnVtYmVyJyk7XG59XG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHRpbWUgdmFsdWUgaXMgYSBSRkMgMzMzOSBmb3JtYXR0ZWQgc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHsqfSB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRnVsbElTT1N0cmluZyh0aW1lKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJyAmJiBGVUxMX0lTT19SRUcudGVzdCh0aW1lKTtcbn1cbi8qKlxuICogUGFkcyBhIG51bWJlci9zdHJpbmcgd2l0aCBcIjBcIiB0byB0aGUgbGVmdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbiBUaGUgbnVtYmVyL3N0cmluZyB0byBwYWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW4gc2l6ZSBvZiB0aGUgcGFkZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhZExlZnQobiwgbWluKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IGdldFBhZGRpbmcobiwgbWluKTtcbiAgICByZXR1cm4gYCR7cGFkZGluZ30ke259YDtcbn1cbi8qKlxuICogUGFkcyBhIG51bWJlci9zdHJpbmcgd2l0aCBcIjBcIiB0byB0aGUgcmlnaHQuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG4gVGhlIG51bWJlci9zdHJpbmcgdG8gcGFkLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluIHNpemUgb2YgdGhlIHBhZGRlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwYWRSaWdodChuLCBtaW4pIHtcbiAgICBjb25zdCBwYWRkaW5nID0gZ2V0UGFkZGluZyhuLCBtaW4pO1xuICAgIHJldHVybiBgJHtufSR7cGFkZGluZ31gO1xufVxuLyoqXG4gKiBDcmVhdGVzIHBhZGRpbmcgYmFzZWQgb24gY3VycmVudCBzaXplIGFuZCBtaW4gc2l6ZSBuZWVkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG4gVGhlIG51bWJlci9zdHJpbmcgdG8gcGFkLlxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49M10gVGhlIG1pbiBzaXplIG9mIHRoZSBwYWRkZWQgc3RyaW5nLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0UGFkZGluZyhuLCBtaW4pIHtcbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgobWluIC0gbi50b1N0cmluZygpLmxlbmd0aCwgMCk7XG4gICAgcmV0dXJuICcwJy5yZXBlYXQoc2l6ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/precise-date/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/projectify/build/src/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@google-cloud/projectify/build/src/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MissingProjectIdError = exports.replaceProjectIdToken = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Populate the `{{projectId}}` placeholder.\n *\n * @throws {Error} If a projectId is required, but one is not provided.\n *\n * @param {*} - Any input value that may contain a placeholder. Arrays and objects will be looped.\n * @param {string} projectId - A projectId. If not provided\n * @return {*} - The original argument with all placeholders populated.\n */\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nfunction replaceProjectIdToken(value, projectId) {\n    if (Array.isArray(value)) {\n        value = value.map(v => replaceProjectIdToken(v, projectId));\n    }\n    if (value !== null &&\n        typeof value === 'object' &&\n        !(value instanceof Buffer) &&\n        !(value instanceof stream_1.Stream) &&\n        typeof value.hasOwnProperty === 'function') {\n        for (const opt in value) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (value.hasOwnProperty(opt)) {\n                value[opt] = replaceProjectIdToken(value[opt], projectId);\n            }\n        }\n    }\n    if (typeof value === 'string' &&\n        value.indexOf('{{projectId}}') > -1) {\n        if (!projectId || projectId === '{{projectId}}') {\n            throw new MissingProjectIdError();\n        }\n        value = value.replace(/{{projectId}}/g, projectId);\n    }\n    return value;\n}\nexports.replaceProjectIdToken = replaceProjectIdToken;\n/**\n * Custom error type for missing project ID errors.\n */\nclass MissingProjectIdError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = `Sorry, we cannot connect to Cloud Services without a project\n    ID. You may specify one with an environment variable named\n    \"GOOGLE_CLOUD_PROJECT\".`.replace(/ +/g, ' ');\n    }\n}\nexports.MissingProjectIdError = MissingProjectIdError;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wcm9qZWN0aWZ5L2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw2QkFBNkI7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEMsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyIvVXNlcnMva2Fpc2VpL0Rlc2t0b3AvbS10cmFjZXItYWkvbm9kZV9tb2R1bGVzL0Bnb29nbGUtY2xvdWQvcHJvamVjdGlmeS9idWlsZC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pc3NpbmdQcm9qZWN0SWRFcnJvciA9IGV4cG9ydHMucmVwbGFjZVByb2plY3RJZFRva2VuID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuLy8gQ29weXJpZ2h0IDIwMTQgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFBvcHVsYXRlIHRoZSBge3twcm9qZWN0SWR9fWAgcGxhY2Vob2xkZXIuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIGEgcHJvamVjdElkIGlzIHJlcXVpcmVkLCBidXQgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0geyp9IC0gQW55IGlucHV0IHZhbHVlIHRoYXQgbWF5IGNvbnRhaW4gYSBwbGFjZWhvbGRlci4gQXJyYXlzIGFuZCBvYmplY3RzIHdpbGwgYmUgbG9vcGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZCAtIEEgcHJvamVjdElkLiBJZiBub3QgcHJvdmlkZWRcbiAqIEByZXR1cm4geyp9IC0gVGhlIG9yaWdpbmFsIGFyZ3VtZW50IHdpdGggYWxsIHBsYWNlaG9sZGVycyBwb3B1bGF0ZWQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gcmVwbGFjZVByb2plY3RJZFRva2VuKHZhbHVlLCBwcm9qZWN0SWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodiA9PiByZXBsYWNlUHJvamVjdElkVG9rZW4odiwgcHJvamVjdElkKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpICYmXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBzdHJlYW1fMS5TdHJlYW0pICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKGNvbnN0IG9wdCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtvcHRdID0gcmVwbGFjZVByb2plY3RJZFRva2VuKHZhbHVlW29wdF0sIHByb2plY3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdmFsdWUuaW5kZXhPZigne3twcm9qZWN0SWR9fScpID4gLTEpIHtcbiAgICAgICAgaWYgKCFwcm9qZWN0SWQgfHwgcHJvamVjdElkID09PSAne3twcm9qZWN0SWR9fScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvamVjdElkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL3t7cHJvamVjdElkfX0vZywgcHJvamVjdElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5yZXBsYWNlUHJvamVjdElkVG9rZW4gPSByZXBsYWNlUHJvamVjdElkVG9rZW47XG4vKipcbiAqIEN1c3RvbSBlcnJvciB0eXBlIGZvciBtaXNzaW5nIHByb2plY3QgSUQgZXJyb3JzLlxuICovXG5jbGFzcyBNaXNzaW5nUHJvamVjdElkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBTb3JyeSwgd2UgY2Fubm90IGNvbm5lY3QgdG8gQ2xvdWQgU2VydmljZXMgd2l0aG91dCBhIHByb2plY3RcbiAgICBJRC4gWW91IG1heSBzcGVjaWZ5IG9uZSB3aXRoIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVkXG4gICAgXCJHT09HTEVfQ0xPVURfUFJPSkVDVFwiLmAucmVwbGFjZSgvICsvZywgJyAnKTtcbiAgICB9XG59XG5leHBvcnRzLk1pc3NpbmdQcm9qZWN0SWRFcnJvciA9IE1pc3NpbmdQcm9qZWN0SWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/projectify/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@google-cloud/promisify/build/src/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* eslint-disable prefer-rest-params */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.callbackifyAll = exports.callbackify = exports.promisifyAll = exports.promisify = void 0;\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\nfunction promisify(originalMethod, options) {\n    if (originalMethod.promisified_) {\n        return originalMethod;\n    }\n    options = options || {};\n    const slice = Array.prototype.slice;\n    // tslint:disable-next-line:no-any\n    const wrapper = function () {\n        let last;\n        for (last = arguments.length - 1; last >= 0; last--) {\n            const arg = arguments[last];\n            if (typeof arg === 'undefined') {\n                continue; // skip trailing undefined.\n            }\n            if (typeof arg !== 'function') {\n                break; // non-callback last argument found.\n            }\n            return originalMethod.apply(this, arguments);\n        }\n        // peel trailing undefined.\n        const args = slice.call(arguments, 0, last + 1);\n        // tslint:disable-next-line:variable-name\n        let PromiseCtor = Promise;\n        // Because dedupe will likely create a single install of\n        // @google-cloud/common to be shared amongst all modules, we need to\n        // localize it at the Service level.\n        if (this && this.Promise) {\n            PromiseCtor = this.Promise;\n        }\n        return new PromiseCtor((resolve, reject) => {\n            // tslint:disable-next-line:no-any\n            args.push((...args) => {\n                const callbackArgs = slice.call(args);\n                const err = callbackArgs.shift();\n                if (err) {\n                    return reject(err);\n                }\n                if (options.singular && callbackArgs.length === 1) {\n                    resolve(callbackArgs[0]);\n                }\n                else {\n                    resolve(callbackArgs);\n                }\n            });\n            originalMethod.apply(this, args);\n        });\n    };\n    wrapper.promisified_ = true;\n    return wrapper;\n}\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\nfunction promisifyAll(Class, options) {\n    const exclude = (options && options.exclude) || [];\n    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n    const methods = ownPropertyNames.filter(methodName => {\n        // clang-format off\n        return (!exclude.includes(methodName) &&\n            typeof Class.prototype[methodName] === 'function' && // is it a function?\n            !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) // is it promisable?\n        );\n        // clang-format on\n    });\n    methods.forEach(methodName => {\n        const originalMethod = Class.prototype[methodName];\n        if (!originalMethod.promisified_) {\n            Class.prototype[methodName] = exports.promisify(originalMethod, options);\n        }\n    });\n}\nexports.promisifyAll = promisifyAll;\n/**\n * Wraps a promisy type function to conditionally call a callback function.\n *\n * @param {function} originalMethod - The method to callbackify.\n * @param {object=} options - Callback options.\n * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.\n * @return {function} wrapped\n */\nfunction callbackify(originalMethod) {\n    if (originalMethod.callbackified_) {\n        return originalMethod;\n    }\n    // tslint:disable-next-line:no-any\n    const wrapper = function () {\n        if (typeof arguments[arguments.length - 1] !== 'function') {\n            return originalMethod.apply(this, arguments);\n        }\n        const cb = Array.prototype.pop.call(arguments);\n        originalMethod.apply(this, arguments).then(\n        // tslint:disable-next-line:no-any\n        (res) => {\n            res = Array.isArray(res) ? res : [res];\n            cb(null, ...res);\n        }, (err) => cb(err));\n    };\n    wrapper.callbackified_ = true;\n    return wrapper;\n}\nexports.callbackify = callbackify;\n/**\n * Callbackifies certain Class methods. This will not callbackify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\nfunction callbackifyAll(\n// tslint:disable-next-line:variable-name\nClass, options) {\n    const exclude = (options && options.exclude) || [];\n    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n    const methods = ownPropertyNames.filter(methodName => {\n        // clang-format off\n        return (!exclude.includes(methodName) &&\n            typeof Class.prototype[methodName] === 'function' && // is it a function?\n            !/^_|(Stream|_)|^constructor$/.test(methodName) // is it callbackifyable?\n        );\n        // clang-format on\n    });\n    methods.forEach(methodName => {\n        const originalMethod = Class.prototype[methodName];\n        if (!originalMethod.callbackified_) {\n            Class.prototype[methodName] = exports.callbackify(originalMethod);\n        }\n    });\n}\nexports.callbackifyAll = callbackifyAll;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wcm9taXNpZnkvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYWlzZWkvRGVza3RvcC9tLXRyYWNlci1haS9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wcm9taXNpZnkvYnVpbGQvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGxiYWNraWZ5QWxsID0gZXhwb3J0cy5jYWxsYmFja2lmeSA9IGV4cG9ydHMucHJvbWlzaWZ5QWxsID0gZXhwb3J0cy5wcm9taXNpZnkgPSB2b2lkIDA7XG4vKipcbiAqIFdyYXBzIGEgY2FsbGJhY2sgc3R5bGUgZnVuY3Rpb24gdG8gY29uZGl0aW9uYWxseSByZXR1cm4gYSBwcm9taXNlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9yaWdpbmFsTWV0aG9kIC0gVGhlIG1ldGhvZCB0byBwcm9taXNpZnkuXG4gKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgLSBQcm9taXNlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2luZ3VsYXIgLSBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggc2luZ2xlIGFyZyBpbnN0ZWFkIG9mIGFuIGFycmF5LlxuICogQHJldHVybiB7ZnVuY3Rpb259IHdyYXBwZWRcbiAqL1xuZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsTWV0aG9kLCBvcHRpb25zKSB7XG4gICAgaWYgKG9yaWdpbmFsTWV0aG9kLnByb21pc2lmaWVkXykge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2Q7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBjb25zdCB3cmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgZm9yIChsYXN0ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmd1bWVudHNbbGFzdF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB0cmFpbGluZyB1bmRlZmluZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBub24tY2FsbGJhY2sgbGFzdCBhcmd1bWVudCBmb3VuZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlZWwgdHJhaWxpbmcgdW5kZWZpbmVkLlxuICAgICAgICBjb25zdCBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGxhc3QgKyAxKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbiAgICAgICAgbGV0IFByb21pc2VDdG9yID0gUHJvbWlzZTtcbiAgICAgICAgLy8gQmVjYXVzZSBkZWR1cGUgd2lsbCBsaWtlbHkgY3JlYXRlIGEgc2luZ2xlIGluc3RhbGwgb2ZcbiAgICAgICAgLy8gQGdvb2dsZS1jbG91ZC9jb21tb24gdG8gYmUgc2hhcmVkIGFtb25nc3QgYWxsIG1vZHVsZXMsIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gbG9jYWxpemUgaXQgYXQgdGhlIFNlcnZpY2UgbGV2ZWwuXG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMuUHJvbWlzZSkge1xuICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSB0aGlzLlByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ3RvcigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICBhcmdzLnB1c2goKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja0FyZ3MgPSBzbGljZS5jYWxsKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IGNhbGxiYWNrQXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaW5ndWxhciAmJiBjYWxsYmFja0FyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2FsbGJhY2tBcmdzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2FsbGJhY2tBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHdyYXBwZXIucHJvbWlzaWZpZWRfID0gdHJ1ZTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbn1cbmV4cG9ydHMucHJvbWlzaWZ5ID0gcHJvbWlzaWZ5O1xuLyoqXG4gKiBQcm9taXNpZmllcyBjZXJ0YWluIENsYXNzIG1ldGhvZHMuIFRoaXMgd2lsbCBub3QgcHJvbWlzaWZ5IHByaXZhdGUgb3JcbiAqIHN0cmVhbWluZyBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOmNvbW1vbi9zZXJ2aWNlfSBDbGFzcyAtIFNlcnZpY2UgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbmZ1bmN0aW9uIHByb21pc2lmeUFsbChDbGFzcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGV4Y2x1ZGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmV4Y2x1ZGUpIHx8IFtdO1xuICAgIGNvbnN0IG93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhDbGFzcy5wcm90b3R5cGUpO1xuICAgIGNvbnN0IG1ldGhvZHMgPSBvd25Qcm9wZXJ0eU5hbWVzLmZpbHRlcihtZXRob2ROYW1lID0+IHtcbiAgICAgICAgLy8gY2xhbmctZm9ybWF0IG9mZlxuICAgICAgICByZXR1cm4gKCFleGNsdWRlLmluY2x1ZGVzKG1ldGhvZE5hbWUpICYmXG4gICAgICAgICAgICB0eXBlb2YgQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdID09PSAnZnVuY3Rpb24nICYmIC8vIGlzIGl0IGEgZnVuY3Rpb24/XG4gICAgICAgICAgICAhLyheX3woU3RyZWFtfF8pfHByb21pc2UkKXxeY29uc3RydWN0b3IkLy50ZXN0KG1ldGhvZE5hbWUpIC8vIGlzIGl0IHByb21pc2FibGU/XG4gICAgICAgICk7XG4gICAgICAgIC8vIGNsYW5nLWZvcm1hdCBvblxuICAgIH0pO1xuICAgIG1ldGhvZHMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICghb3JpZ2luYWxNZXRob2QucHJvbWlzaWZpZWRfKSB7XG4gICAgICAgICAgICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBleHBvcnRzLnByb21pc2lmeShvcmlnaW5hbE1ldGhvZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMucHJvbWlzaWZ5QWxsID0gcHJvbWlzaWZ5QWxsO1xuLyoqXG4gKiBXcmFwcyBhIHByb21pc3kgdHlwZSBmdW5jdGlvbiB0byBjb25kaXRpb25hbGx5IGNhbGwgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcmlnaW5hbE1ldGhvZCAtIFRoZSBtZXRob2QgdG8gY2FsbGJhY2tpZnkuXG4gKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgLSBDYWxsYmFjayBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNpbmd1bGFyIC0gUGFzcyB0byB0aGUgY2FsbGJhY2sgYSBzaW5nbGUgYXJnIGluc3RlYWQgb2YgYW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gd3JhcHBlZFxuICovXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbE1ldGhvZCkge1xuICAgIGlmIChvcmlnaW5hbE1ldGhvZC5jYWxsYmFja2lmaWVkXykge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2Q7XG4gICAgfVxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBjb25zdCB3cmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNiID0gQXJyYXkucHJvdG90eXBlLnBvcC5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAocmVzKSA9PiB7XG4gICAgICAgICAgICByZXMgPSBBcnJheS5pc0FycmF5KHJlcykgPyByZXMgOiBbcmVzXTtcbiAgICAgICAgICAgIGNiKG51bGwsIC4uLnJlcyk7XG4gICAgICAgIH0sIChlcnIpID0+IGNiKGVycikpO1xuICAgIH07XG4gICAgd3JhcHBlci5jYWxsYmFja2lmaWVkXyA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4vKipcbiAqIENhbGxiYWNraWZpZXMgY2VydGFpbiBDbGFzcyBtZXRob2RzLiBUaGlzIHdpbGwgbm90IGNhbGxiYWNraWZ5IHByaXZhdGUgb3JcbiAqIHN0cmVhbWluZyBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOmNvbW1vbi9zZXJ2aWNlfSBDbGFzcyAtIFNlcnZpY2UgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2FsbGJhY2tpZnlBbGwoXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuQ2xhc3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBleGNsdWRlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5leGNsdWRlKSB8fCBbXTtcbiAgICBjb25zdCBvd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQ2xhc3MucHJvdG90eXBlKTtcbiAgICBjb25zdCBtZXRob2RzID0gb3duUHJvcGVydHlOYW1lcy5maWx0ZXIobWV0aG9kTmFtZSA9PiB7XG4gICAgICAgIC8vIGNsYW5nLWZvcm1hdCBvZmZcbiAgICAgICAgcmV0dXJuICghZXhjbHVkZS5pbmNsdWRlcyhtZXRob2ROYW1lKSAmJlxuICAgICAgICAgICAgdHlwZW9mIENsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBpcyBpdCBhIGZ1bmN0aW9uP1xuICAgICAgICAgICAgIS9eX3woU3RyZWFtfF8pfF5jb25zdHJ1Y3RvciQvLnRlc3QobWV0aG9kTmFtZSkgLy8gaXMgaXQgY2FsbGJhY2tpZnlhYmxlP1xuICAgICAgICApO1xuICAgICAgICAvLyBjbGFuZy1mb3JtYXQgb25cbiAgICB9KTtcbiAgICBtZXRob2RzLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAoIW9yaWdpbmFsTWV0aG9kLmNhbGxiYWNraWZpZWRfKSB7XG4gICAgICAgICAgICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBleHBvcnRzLmNhbGxiYWNraWZ5KG9yaWdpbmFsTWV0aG9kKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeUFsbCA9IGNhbGxiYWNraWZ5QWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/promisify/build/src/index.js\n");

/***/ })

};
;